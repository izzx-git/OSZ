# file opened: terminal.asm
  1   0000              ;Terminal - приложение для OS GMX
  2   0000                 device ZXSPECTRUM128
  3   0000              	include "../os_defs.asm"
# file opened: ../os_defs.asm
  1+  0000              ;Список всех вызовов (функций) ОС GMX
  2+  0000
  3+  0000              ;Включить в свой код (в начале файла):
  4+  0000              	; include os_defs.asm
  5+  0000
  6+  0000              ;Использовать только имена функций, коды могут поменяться
  7+  0000
  8+  0000              ;например:
  9+  0000              	; org PROGSTART
 10+  0000              	; ../include os_defs.asm
 11+  0000              	; ld hl,text
 12+  0000              	; OS_PRINTZ ;печать	до кода 0
 13+  0000
 14+  0000              ;сохранность регистров не гарантируется
 15+  0000              ;на выходе обычно (но не всегда) CY=1 = ошибка
 16+  0000
 17+  0000              PROGSTART equ #8000 ;адрес старта приложений
 18+  0000
 19+  0000
 20+  0000              ;короткие вызовы (именные RST) -------------------------
 21+  0000
 22+  0000              ;печать символа в консоль (ускоренная)
 23+  0000              	MACRO OS_PRINT_CHARF ;a=char
 24+  0000 ~            	rst #10
 25+  0000              	ENDM
 26+  0000
 27+  0000
 28+  0000              ;передача управления ОС до следующего прерывания (когда придёт очередь процесса в следующий раз);
 29+  0000              ;все регистры сохраняются
 30+  0000              ;рекомендуется использовать вместо обычного halt
 31+  0000              	MACRO OS_WAIT
 32+  0000 ~            	rst #18
 33+  0000              	ENDM
 34+  0000
 35+  0000              	; MACRO OS_
 36+  0000              	; rst #28
 37+  0000              	; ENDM
 38+  0000
 39+  0000              	; MACRO OS_
 40+  0000              	; rst #30
 41+  0000              	; ENDM
 42+  0000
 43+  0000
 44+  0000
 45+  0000              ;вызовы через единую точку входа RST #20 ----------------
 46+  0000
 47+  0000              ;вывод в консоль --------------------
 48+  0000
 49+  0000              ;очистить консоль
 50+  0000              	macro OS_CLS ;clear visible area of terminal
 51+  0000 ~                ld c,#00
 52+  0000 ~                rst #20
 53+  0000                  endm
 54+  0000
 55+  0000              ;установить позицию курсора в консоли
 56+  0000                  macro OS_SET_XY ;de=yx ;SET CURSOR POSITION
 57+  0000 ~                ld c,#01
 58+  0000 ~                rst #20
 59+  0000                  endm
 60+  0000
 61+  0000              ;печать символа в консоль
 62+  0000                  macro OS_PRINT_CHAR ;a=char
 63+  0000 ~                ld c,#02
 64+  0000 ~                rst #20
 65+  0000                  endm
 66+  0000
 67+  0000              ;заполнение строки одним символом
 68+  0000                  macro OS_FILL_LINE ;; H - line ; A - char
 69+  0000 ~                ld c,#03
 70+  0000 ~                rst #20
 71+  0000                  endm
 72+  0000
 73+  0000              ;покрасить строку цветом
 74+  0000                  macro OS_PAINT_LINE ;a - line, b - color
 75+  0000 ~                ld c,#04
 76+  0000 ~                rst #20
 77+  0000                  endm
 78+  0000
 79+  0000
 80+  0000                  ; macro OS_ ;
 81+  0000                  ; ld c,#05
 82+  0000                  ; rst #20
 83+  0000                  ; endm
 84+  0000
 85+  0000              ;установить цвет текста в консоли;
 86+  0000                  macro OS_SET_COLOR ;a = color, b = color 2 (highlight)
 87+  0000 ~                ld c,#06
 88+  0000 ~                rst #20
 89+  0000                  endm
 90+  0000
 91+  0000                  ; macro OS_ ;
 92+  0000                  ; ld c,#07
 93+  0000                  ; rst #20
 94+  0000                  ; endm
 95+  0000
 96+  0000                  ; macro OS_ ;
 97+  0000                  ; ld c,#08
 98+  0000                  ; rst #20
 99+  0000                  ; endm
100+  0000
101+  0000
102+  0000
103+  0000              ;печать в консоль до кода 0
104+  0000                  macro OS_PRINTZ ;hl=text ;PRINT to 0
105+  0000 ~                ld c,#09
106+  0000 ~                rst #20
107+  0000                  endm
108+  0000
109+  0000
110+  0000              ;прочитать байт из порта uart
111+  0000              ;вх:
112+  0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart или нет данных для приёма
113+  0000              ;вых: A - считанный байт
114+  0000                  macro OS_UART_READ
115+  0000 ~                ld c,#0a
116+  0000 ~                rst #20
117+  0000                  endm
118+  0000
119+  0000              ;записать байт в порт uart
120+  0000              ;вх: A -байт
121+  0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
122+  0000                  macro OS_UART_WRITE
123+  0000 ~                ld c,#0b
124+  0000 ~                rst #20
125+  0000                  endm
126+  0000
127+  0000              ;закрыть соединение ESP
128+  0000              ;вх:
129+  0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
130+  0000                  macro OS_ESP_CLOSE
131+  0000 ~                ld c,#0c
132+  0000 ~                rst #20
133+  0000                  endm
134+  0000
135+  0000              ;установить соединение ESP (CIPSTART);
136+  0000              ;вх: a - тип соединения 0-tcp, 1-udp, 2-ssl; 3-прямое соединение с портом; hl - строка адрес, de - строка порт
137+  0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
138+  0000              ;вых: ix - адрес в таблице соединений (ix+2 - флаг открытия =1 - открыто, 255 - ошибка);
139+  0000                  macro OS_ESP_OPEN
140+  0000 ~                ld c,#0d
141+  0000 ~                rst #20
142+  0000                  endm
143+  0000
144+  0000              ;послать запрос ESP (CIPSEND);
145+  0000              ;вх: hl - адрес данных, de - длина данных
146+  0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
147+  0000              ;вых: ix - адрес в таблице соединений (ix+4 - флаг =1 - отправлено, 255 - ошибка)
148+  0000                  macro OS_ESP_SEND
149+  0000 ~                ld c,#0e
150+  0000 ~                rst #20
151+  0000                  endm
152+  0000
153+  0000              ;получить пакет ESP (+IPD);
154+  0000              ;вх: hl - адрес для данных
155+  0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
156+  0000              ;вых: ix - адрес в таблице соединений (ix+6 - флаг =1 - принято, 255 - ошибка)
157+  0000                  macro OS_ESP_GET
158+  0000 ~                ld c,#0f
159+  0000 ~                rst #20
160+  0000                  endm
161+  0000
162+  0000              ;ввод с консоли ----------------------
163+  0000
164+  0000              ;получить код нажатой клавиши
165+  0000                  macro OS_GET_CHAR ;read char from stdin (out: A=char, 255-no char)
166+  0000 ~                ld c,#10
167+  0000 ~                rst #20
168+  0000                  endm
169+  0000
170+  0000
171+  0000              ;процессы ----------------------------
172+  0000
173+  0000              ;запустить процесс
174+  0000              ;вх: hl - имя файла (заканчивается на 0)
175+  0000                  macro OS_PROC_RUN ;
176+  0000 ~                ld c,#11
177+  0000 ~                rst #20
178+  0000                  endm
179+  0000
180+  0000              ;установить фокус
181+  0000              ;вх: a - id процесса
182+  0000                  macro OS_PROC_SET_FOCUS ;
183+  0000 ~                ld c,#12
184+  0000 ~                rst #20
185+  0000                  endm
186+  0000
187+  0000              ;закрыть процесс
188+  0000              ;вх: A - ID процесса. Если A=0, закрыть текущий (себя)
189+  0000              ;останавливается процесс и освобождаются все его страницы памяти, файлы, соединения
190+  0000                  macro OS_PROC_CLOSE ;
191+  0000 ~                ld c,#13
192+  0000 ~                rst #20
193+  0000                  endm
194+  0000
195+  0000
196+  0000              ;прерывания --------------------------
197+  0000
198+  0000              ;установка адреса обработчика прерываний процесса;
199+  0000                  ; macro OS_SET_INTER ;(HL - address, A = 1 - On, A = 0 - Off)
200+  0000                  ; ld c,#14
201+  0000                  ; rst #20
202+  0000                  ; endm
203+  0000
204+  0000
205+  0000              ;плеер AY ----------------------------
206+  0000
207+  0000              ;инициализация плеера AY;
208+  0000                  macro OS_VTPL_INIT ;(HL - address music)
209+  0000 ~                ld c,#15
210+  0000 ~                rst #20
211+  0000                  endm
212+  0000
213+  0000              ;запустить плеер AY (система будет сама вызывать его каждое прерывание);
214+  0000                  macro OS_VTPL_PLAY ;()
215+  0000 ~                ld c,#16
216+  0000 ~                rst #20
217+  0000                  endm
218+  0000
219+  0000              ;заглушить плеер AY;
220+  0000                  macro OS_VTPL_MUTE ;()
221+  0000 ~                ld c,#17
222+  0000 ~                rst #20
223+  0000                  endm
224+  0000
225+  0000              ;получить значение переменной плеера;
226+  0000                  macro OS_GET_VTPL_SETUP ;(out: HL - setup address)
227+  0000 ~                ld c,#18
228+  0000 ~                rst #20
229+  0000                  endm
230+  0000
231+  0000
232+  0000              ;прочие ------------------------------
233+  0000
234+  0000
235+  0000              ;скопировать данные из страницы в страницу
236+  0000              ;вх: hl - откуда (абсолютный адрес 0-ffff); de - куда; ix - длина; a - страница слот2; b - страница слот3;
237+  0000                  macro OS_RAM_COPY
238+  0000 ~                ld c,#19
239+  0000 ~                rst #20
240+  0000                  endm
241+  0000
242+  0000              ;получить дополнительную страницу памяти;
243+  0000                  macro OS_GET_PAGE ;(out A - number page)
244+  0000 ~                ld c,#1a
245+  0000 ~                rst #20
246+  0000                  endm
247+  0000
248+  0000              ;включить страницу в слот 2 (#8000); предварительно зарезервировать страницу OS_GET_PAGE
249+  0000                  macro OS_SET_PAGE_SLOT2 ;(A - page number)
250+  0000 ~                ld c,#1b
251+  0000 ~                rst #20
252+  0000                  endm
253+  0000
254+  0000              ;включить страницу в слот 3 (#C000); предварительно зарезервировать страницу OS_GET_PAGE
255+  0000                  macro OS_SET_PAGE_SLOT3 ;(A - page number)
256+  0000 ~                ld c,#1c
257+  0000 ~                rst #20
258+  0000                  endm
259+  0000
260+  0000              ;включить экран N;
261+  0000              ;вх: A - номер экрана (5, 7, #39, #3a; 0 = текстовый)
262+  0000              ;переключать может только приложение в фокусе
263+  0000              ;если режим не текстовый, то приложение работает только когда в фокусе. Иначе временно останавливается.
264+  0000              ;при переключении процессов сохраняется только экран #39
265+  0000                  macro OS_SET_SCREEN ;
266+  0000 ~                ld c,#1d
267+  0000 ~                rst #20
268+  0000                  endm
269+  0000
270+  0000
271+  0000              ;получить номера страниц процесса;
272+  0000              ;вх:
273+  0000              ;вых: b, c - страницы в слотах 2, 3
274+  0000                  macro OS_GET_MAIN_PAGES ;
275+  0000 ~                ld c,#1e
276+  0000 ~                rst #20
277+  0000                  endm
278+  0000
279+  0000              ;получить значение системного таймера
280+  0000                  macro OS_GET_TIMER ;(out: HL, DE - timer)
281+  0000 ~                ld c,#1F
282+  0000 ~                rst #20
283+  0000                  endm
284+  0000
285+  0000
286+  0000
287+  0000                  ; macro OS_ ;
288+  0000                  ; ld c,#20
289+  0000                  ; rst #20
290+  0000                  ; endm
291+  0000
292+  0000
293+  0000              ;дисковые операции -------------------
294+  0000
295+  0000              ;открыть файл для чтения или записи
296+  0000                  macro OS_FILE_OPEN ;HL - File name (out: A - id file, bc, de - size)
297+  0000 ~                ld c,#21
298+  0000 ~                rst #20
299+  0000                  endm
300+  0000
301+  0000              ;создать файл
302+  0000                  macro OS_FILE_CREATE ;HL - File name  (out: A - id file)
303+  0000 ~                ld c,#22
304+  0000 ~                rst #20
305+  0000                  endm
306+  0000
307+  0000              ;прочитать из файла
308+  0000                  macro OS_FILE_READ ;HL - address, A - id file, DE - length (out: bc - size readed)
309+  0000 ~                ld c,#23
310+  0000 ~                rst #20
311+  0000                  endm
312+  0000
313+  0000              ;записать в файл
314+  0000                  macro OS_FILE_WRITE ;HL - address, A - id file, DE - length (out: bc - size writed)
315+  0000 ~                ld c,#24
316+  0000 ~                rst #20
317+  0000                  endm
318+  0000
319+  0000              ;закрыть файл
320+  0000                  macro OS_FILE_CLOSE ;A - id file
321+  0000 ~                ld c,#25
322+  0000 ~                rst #20
323+  0000                  endm
324+  0000
325+  0000              ;чтение секторов текущего каталога
326+  0000              ; вх:
327+  0000                   ; hl - буфер для чтения
328+  0000                   ; de - относительный номер первого сектора каталога для чтения [0..nn]
329+  0000                   ; b - максимальное количество секторов для чтения
330+  0000              ; вых: cy=1, если были ошибки, код ошибки возвращается в аккумуляторе
331+  0000                     ; a=errRWnum
332+  0000                     ; a=errInvalidPart
333+  0000                     ; a=errFileEmpty
334+  0000                   ; cy=0, a=errEoF - каталог закончился
335+  0000                     ; hl - следующий адрес в буфере
336+  0000                     ; de - номер первого непрочитанного сектора
337+  0000                     ; b - не прочитано секторов
338+  0000                   ; cy=0 - считано успешно
339+  0000                     ; hl - следующий адрес в буфере
340+  0000                     ; de - номер первого непрочитанного сектора
341+  0000                     ; b=#00
342+  0000                  macro OS_READ_DIR ;
343+  0000 ~                ld c,#26
344+  0000 ~                rst #20
345+  0000                  endm
346+  0000
347+  0000              ;вход в каталог/выход в родительский каталог
348+  0000              	; Если путь не указан производится только настройка переменных драйвера,
349+  0000              	; при этом если передан дескриптор файла, текущий каталог не изменится)
350+  0000              	; Если пусть указан, в конец пути добавится название каталога (если это
351+  0000              	; переход в родительский, последнее имя в пути удалится).
352+  0000              	; Если передан дескриптор файла, текущий каталог не изменится, к пути
353+  0000              	; добавится имя файла
354+  0000              ; вх:
355+  0000                   ; hl - адрес пути (=#0000 - путь отсутствует)
356+  0000                   ; de - адрес дескриптора директории/файла
357+  0000              ; вых: a - если путь был указан, новая длина пути
358+  0000                  macro OS_OPEN_DIR ;
359+  0000 ~                ld c,#27
360+  0000 ~                rst #20
361+  0000                  endm
362+  0000
363+  0000
364+  0000                  ; macro OS_ ;
365+  0000                  ; ld c,#28
366+  0000                  ; rst #20
367+  0000                  ; endm
368+  0000
369+  0000                  ; macro OS_ ;
370+  0000                  ; ld c,#29
371+  0000                  ; rst #20
372+  0000                  ; endm
373+  0000
374+  0000
# file closed: ../os_defs.asm
  4   0000              	org PROGSTART
  5   8000
  6   8000              start_terminal
  7   8000              	; ld a,13 ;новая строка
  8   8000              	; OS_PRINT_CHARF
  9   8000 21 62 80     	ld hl,msg_title_terminal ;имя приложения
 10   8003              	OS_PRINTZ ;печать
 10   8003 0E 09       >    ld c,#09
 10   8005 E7          >    rst #20
 11   8006
 12   8006
 13   8006 21 51 80     	ld hl,msg_open_port ;открываем порт
 14   8009              	OS_PRINTZ ;печать
 14   8009 0E 09       >    ld c,#09
 14   800B E7          >    rst #20
 15   800C              terminal_open
 16   800C              	OS_WAIT
 16   800C DF          >	rst #18
 17   800D 3E 03        	ld a,3 ;прямое соединение с портом
 18   800F              	OS_ESP_OPEN
 18   800F 0E 0D       >    ld c,#0d
 18   8011 E7          >    rst #20
 19   8012 38 F8        	jr c,terminal_open
 20   8014 21 5E 80     	ld hl,msg_ready ;
 21   8017              	OS_PRINTZ ;печать
 21   8017 0E 09       >    ld c,#09
 21   8019 E7          >    rst #20
 22   801A              	;основной цикл
 23   801A              terminal_wait
 24   801A              	OS_WAIT
 24   801A DF          >	rst #18
 25   801B              terminal_wait1
 26   801B              	OS_UART_READ ;прочитать байт из порта
 26   801B 0E 0A       >    ld c,#0a
 26   801D E7          >    rst #20
 27   801E 38 03        	jr c,terminal_wait_no_input
 28   8020              	OS_PRINT_CHARF ;напечатать если есть что
 28   8020 D7          >	rst #10
 29   8021 18 F8        	jr terminal_wait1 ;и проверить есть ли ещё
 30   8023              terminal_wait_no_input
 31   8023              	OS_GET_CHAR ;получить клавишу из консоли
 31   8023 0E 10       >    ld c,#10
 31   8025 E7          >    rst #20
 32   8026 FE FF        	cp 255
 33   8028 28 14        	jr z,terminal_wait_no_output
 34   802A FE 18        	cp 24 ;break
 35   802C CA 4D 80     	jp z,terminal_exit
 36   802F FE 0D        	cp 13 ;enter
 37   8031 CA 40 80     	jp z,terminal_enter
 38   8034 FE 20        	cp " " ;не печатное
 39   8036 38 06        	jr c,terminal_wait_no_output
 40   8038 F5           	push af
 41   8039              	OS_PRINT_CHARF ;напечатать если есть что
 41   8039 D7          >	rst #10
 42   803A F1           	pop af
 43   803B              	OS_UART_WRITE ;отправить в порт
 43   803B 0E 0B       >    ld c,#0b
 43   803D E7          >    rst #20
 44   803E              	;здесь может быть обработка ошибки
 45   803E              	;jr c.
 46   803E              terminal_wait_no_output
 47   803E 18 DA        	jr terminal_wait ;цикл
 48   8040
 49   8040
 50   8040              terminal_enter
 51   8040 F5           	push af
 52   8041              	OS_PRINT_CHARF
 52   8041 D7          >	rst #10
 53   8042 F1           	pop af
 54   8043              	OS_UART_WRITE
 54   8043 0E 0B       >    ld c,#0b
 54   8045 E7          >    rst #20
 55   8046 3E 0A        	ld a,10 ;для ESP надо добавить после 13
 56   8048              	OS_UART_WRITE
 56   8048 0E 0B       >    ld c,#0b
 56   804A E7          >    rst #20
 57   804B 18 CD        	jr terminal_wait ;цикл
 58   804D
 59   804D              terminal_exit ;выход в DOS
 60   804D AF           	xor a
 61   804E              	OS_PROC_CLOSE
 61   804E 0E 13       >    ld c,#13
 61   8050 E7          >    rst #20
 62   8051              ;
 63   8051
 64   8051
 65   8051              msg_open_port
 66   8051 4F 70 65 6E  	db "Open port...",0
 66   8055 20 70 6F 72
 66   8059 74 2E 2E 2E
 66   805D 00
 67   805E
 68   805E
 69   805E              msg_ready
 70   805E 4F 4B 0D 00  	db "OK",13,0
 71   8062
 72   8062              msg_title_terminal
 73   8062 54 65 72 6D  	db "Terminal ver 2025.02.12",13,0
 73   8066 69 6E 61 6C
 73   806A 20 76 65 72
 73   806E 20 32 30 32
 73   8072 35 2E 30 32
 73   8076 2E 31 32 0D
 73   807A 00
 74   807B
 75   807B
 76   807B              end_terminal
 77   807B              	savebin "terminal.apg",start_terminal,$-start_terminal
# file closed: terminal.asm
