# file opened: main.asm
   1  0000                  device	zxspectrum128
   2  0000              	include "../os_defs.asm"
# file opened: ../os_defs.asm
   1+ 0000              ;Список всех вызовов (функций) ОС GMX
   2+ 0000
   3+ 0000              ;Включить в свой код (в начале файла):
   4+ 0000              	; include os_defs.asm
   5+ 0000
   6+ 0000              ;Использовать только имена функций, коды могут поменяться
   7+ 0000
   8+ 0000              ;например:
   9+ 0000              	; org PROGSTART
  10+ 0000              	; ../include os_defs.asm
  11+ 0000              	; ld hl,text
  12+ 0000              	; OS_PRINTZ ;печать	до кода 0
  13+ 0000
  14+ 0000              ;сохранность регистров не гарантируется
  15+ 0000              ;на выходе обычно (но не всегда) CY=1 = ошибка
  16+ 0000
  17+ 0000              PROGSTART equ #8000 ;адрес старта приложений
  18+ 0000
  19+ 0000
  20+ 0000              ;короткие вызовы (именные RST) -------------------------
  21+ 0000
  22+ 0000              ;печать символа в консоль (ускоренная)
  23+ 0000              	MACRO OS_PRINT_CHARF ;a=char
  24+ 0000 ~            	rst #10
  25+ 0000              	ENDM
  26+ 0000
  27+ 0000
  28+ 0000              ;передача управления ОС до следующего прерывания (когда придёт очередь процесса в следующий раз);
  29+ 0000              ;все регистры сохраняются
  30+ 0000              ;рекомендуется использовать вместо обычного halt
  31+ 0000              	MACRO OS_WAIT
  32+ 0000 ~            	rst #18
  33+ 0000              	ENDM
  34+ 0000
  35+ 0000              	; MACRO OS_
  36+ 0000              	; rst #28
  37+ 0000              	; ENDM
  38+ 0000
  39+ 0000              	; MACRO OS_
  40+ 0000              	; rst #30
  41+ 0000              	; ENDM
  42+ 0000
  43+ 0000
  44+ 0000
  45+ 0000              ;вызовы через единую точку входа RST #20 ----------------
  46+ 0000
  47+ 0000              ;вывод в консоль --------------------
  48+ 0000
  49+ 0000              ;очистить консоль
  50+ 0000              	macro OS_CLS ;clear visible area of terminal
  51+ 0000 ~                ld c,#00
  52+ 0000 ~                rst #20
  53+ 0000                  endm
  54+ 0000
  55+ 0000              ;установить позицию курсора в консоли
  56+ 0000                  macro OS_SET_XY ;de=yx ;SET CURSOR POSITION
  57+ 0000 ~                ld c,#01
  58+ 0000 ~                rst #20
  59+ 0000                  endm
  60+ 0000
  61+ 0000              ;печать символа в консоль
  62+ 0000                  macro OS_PRINT_CHAR ;a=char
  63+ 0000 ~                ld c,#02
  64+ 0000 ~                rst #20
  65+ 0000                  endm
  66+ 0000
  67+ 0000              ;заполнение строки одним символом
  68+ 0000                  macro OS_FILL_LINE ;; H - line ; A - char
  69+ 0000 ~                ld c,#03
  70+ 0000 ~                rst #20
  71+ 0000                  endm
  72+ 0000
  73+ 0000              ;покрасить строку цветом
  74+ 0000                  macro OS_PAINT_LINE ;a - line, b - color
  75+ 0000 ~                ld c,#04
  76+ 0000 ~                rst #20
  77+ 0000                  endm
  78+ 0000
  79+ 0000
  80+ 0000                  ; macro OS_ ;
  81+ 0000                  ; ld c,#05
  82+ 0000                  ; rst #20
  83+ 0000                  ; endm
  84+ 0000
  85+ 0000              ;установить цвет текста в консоли;
  86+ 0000                  macro OS_SET_COLOR ;a = color, b = color 2 (highlight)
  87+ 0000 ~                ld c,#06
  88+ 0000 ~                rst #20
  89+ 0000                  endm
  90+ 0000
  91+ 0000                  ; macro OS_ ;
  92+ 0000                  ; ld c,#07
  93+ 0000                  ; rst #20
  94+ 0000                  ; endm
  95+ 0000
  96+ 0000                  ; macro OS_ ;
  97+ 0000                  ; ld c,#08
  98+ 0000                  ; rst #20
  99+ 0000                  ; endm
 100+ 0000
 101+ 0000
 102+ 0000
 103+ 0000              ;печать в консоль до кода 0
 104+ 0000                  macro OS_PRINTZ ;hl=text ;PRINT to 0
 105+ 0000 ~                ld c,#09
 106+ 0000 ~                rst #20
 107+ 0000                  endm
 108+ 0000
 109+ 0000
 110+ 0000              ;прочитать байт из порта uart
 111+ 0000              ;вх:
 112+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart или нет данных для приёма
 113+ 0000              ;вых: A - считанный байт
 114+ 0000                  macro OS_UART_READ
 115+ 0000 ~                ld c,#0a
 116+ 0000 ~                rst #20
 117+ 0000                  endm
 118+ 0000
 119+ 0000              ;записать байт в порт uart
 120+ 0000              ;вх: A -байт
 121+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 122+ 0000                  macro OS_UART_WRITE
 123+ 0000 ~                ld c,#0b
 124+ 0000 ~                rst #20
 125+ 0000                  endm
 126+ 0000
 127+ 0000              ;закрыть соединение ESP
 128+ 0000              ;вх:
 129+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 130+ 0000                  macro OS_ESP_CLOSE
 131+ 0000 ~                ld c,#0c
 132+ 0000 ~                rst #20
 133+ 0000                  endm
 134+ 0000
 135+ 0000              ;установить соединение ESP (CIPSTART);
 136+ 0000              ;вх: a - тип соединения 0-tcp, 1-udp, 2-ssl; 3-прямое соединение с портом; hl - строка адрес, de - строка порт
 137+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 138+ 0000              ;вых: ix - адрес в таблице соединений (ix+2 - флаг открытия =1 - открыто, 255 - ошибка);
 139+ 0000                  macro OS_ESP_OPEN
 140+ 0000 ~                ld c,#0d
 141+ 0000 ~                rst #20
 142+ 0000                  endm
 143+ 0000
 144+ 0000              ;послать запрос ESP (CIPSEND);
 145+ 0000              ;вх: hl - адрес данных, de - длина данных
 146+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 147+ 0000              ;вых: ix - адрес в таблице соединений (ix+4 - флаг =1 - отправлено, 255 - ошибка)
 148+ 0000                  macro OS_ESP_SEND
 149+ 0000 ~                ld c,#0e
 150+ 0000 ~                rst #20
 151+ 0000                  endm
 152+ 0000
 153+ 0000              ;получить пакет ESP (+IPD);
 154+ 0000              ;вх: hl - адрес для данных
 155+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 156+ 0000              ;вых: ix - адрес в таблице соединений (ix+6 - флаг =1 - принято, 255 - ошибка)
 157+ 0000                  macro OS_ESP_GET
 158+ 0000 ~                ld c,#0f
 159+ 0000 ~                rst #20
 160+ 0000                  endm
 161+ 0000
 162+ 0000              ;ввод с консоли ----------------------
 163+ 0000
 164+ 0000              ;получить код нажатой клавиши
 165+ 0000                  macro OS_GET_CHAR ;read char from stdin (out: A=char, 255-no char)
 166+ 0000 ~                ld c,#10
 167+ 0000 ~                rst #20
 168+ 0000                  endm
 169+ 0000
 170+ 0000
 171+ 0000              ;процессы ----------------------------
 172+ 0000
 173+ 0000              ;запустить процесс
 174+ 0000              ;вх: hl - имя файла (заканчивается на 0)
 175+ 0000                  macro OS_PROC_RUN ;
 176+ 0000 ~                ld c,#11
 177+ 0000 ~                rst #20
 178+ 0000                  endm
 179+ 0000
 180+ 0000              ;установить фокус
 181+ 0000              ;вх: a - id процесса
 182+ 0000                  macro OS_PROC_SET_FOCUS ;
 183+ 0000 ~                ld c,#12
 184+ 0000 ~                rst #20
 185+ 0000                  endm
 186+ 0000
 187+ 0000              ;закрыть процесс
 188+ 0000              ;вх: A - ID процесса. Если A=0, закрыть текущий (себя)
 189+ 0000              ;останавливается процесс и освобождаются все его страницы памяти, файлы, соединения
 190+ 0000                  macro OS_PROC_CLOSE ;
 191+ 0000 ~                ld c,#13
 192+ 0000 ~                rst #20
 193+ 0000                  endm
 194+ 0000
 195+ 0000
 196+ 0000              ;прерывания --------------------------
 197+ 0000
 198+ 0000              ;установка адреса обработчика прерываний процесса;
 199+ 0000                  ; macro OS_SET_INTER ;(HL - address, A = 1 - On, A = 0 - Off)
 200+ 0000                  ; ld c,#14
 201+ 0000                  ; rst #20
 202+ 0000                  ; endm
 203+ 0000
 204+ 0000
 205+ 0000              ;плеер AY ----------------------------
 206+ 0000
 207+ 0000              ;инициализация плеера AY;
 208+ 0000                  macro OS_VTPL_INIT ;(HL - address music)
 209+ 0000 ~                ld c,#15
 210+ 0000 ~                rst #20
 211+ 0000                  endm
 212+ 0000
 213+ 0000              ;запустить плеер AY (система будет сама вызывать его каждое прерывание);
 214+ 0000                  macro OS_VTPL_PLAY ;()
 215+ 0000 ~                ld c,#16
 216+ 0000 ~                rst #20
 217+ 0000                  endm
 218+ 0000
 219+ 0000              ;заглушить плеер AY;
 220+ 0000                  macro OS_VTPL_MUTE ;()
 221+ 0000 ~                ld c,#17
 222+ 0000 ~                rst #20
 223+ 0000                  endm
 224+ 0000
 225+ 0000              ;получить значение переменной плеера;
 226+ 0000                  macro OS_GET_VTPL_SETUP ;(out: HL - setup address)
 227+ 0000 ~                ld c,#18
 228+ 0000 ~                rst #20
 229+ 0000                  endm
 230+ 0000
 231+ 0000
 232+ 0000              ;прочие ------------------------------
 233+ 0000
 234+ 0000
 235+ 0000              ;скопировать данные из страницы в страницу
 236+ 0000              ;вх: hl - откуда (абсолютный адрес 0-ffff); de - куда; ix - длина; a - страница слот2; b - страница слот3;
 237+ 0000                  macro OS_RAM_COPY
 238+ 0000 ~                ld c,#19
 239+ 0000 ~                rst #20
 240+ 0000                  endm
 241+ 0000
 242+ 0000              ;получить дополнительную страницу памяти;
 243+ 0000                  macro OS_GET_PAGE ;(out A - number page)
 244+ 0000 ~                ld c,#1a
 245+ 0000 ~                rst #20
 246+ 0000                  endm
 247+ 0000
 248+ 0000              ;включить страницу в слот 2 (#8000); предварительно зарезервировать страницу OS_GET_PAGE
 249+ 0000                  macro OS_SET_PAGE_SLOT2 ;(A - page number)
 250+ 0000 ~                ld c,#1b
 251+ 0000 ~                rst #20
 252+ 0000                  endm
 253+ 0000
 254+ 0000              ;включить страницу в слот 3 (#C000); предварительно зарезервировать страницу OS_GET_PAGE
 255+ 0000                  macro OS_SET_PAGE_SLOT3 ;(A - page number)
 256+ 0000 ~                ld c,#1c
 257+ 0000 ~                rst #20
 258+ 0000                  endm
 259+ 0000
 260+ 0000              ;включить экран N;
 261+ 0000              ;вх: A - номер экрана (5, 7, #39, #3a; 0 = текстовый)
 262+ 0000              ;Если режим не текстовый, то приложение работает только когда в фокусе. Иначе временно останавливается.
 263+ 0000              ;при переключении процессов сохраняется только экран #39
 264+ 0000                  macro OS_SET_SCREEN ;
 265+ 0000 ~                ld c,#1d
 266+ 0000 ~                rst #20
 267+ 0000                  endm
 268+ 0000
 269+ 0000
 270+ 0000              ;получить номера страниц процесса;
 271+ 0000              ;вх:
 272+ 0000              ;вых: b, c - страницы в слотах 2, 3
 273+ 0000                  macro OS_GET_MAIN_PAGES ;
 274+ 0000 ~                ld c,#1e
 275+ 0000 ~                rst #20
 276+ 0000                  endm
 277+ 0000
 278+ 0000              ;получить значение системного таймера
 279+ 0000                  macro OS_GET_TIMER ;(out: HL, DE - timer)
 280+ 0000 ~                ld c,#1F
 281+ 0000 ~                rst #20
 282+ 0000                  endm
 283+ 0000
 284+ 0000
 285+ 0000
 286+ 0000                  ; macro OS_ ;
 287+ 0000                  ; ld c,#20
 288+ 0000                  ; rst #20
 289+ 0000                  ; endm
 290+ 0000
 291+ 0000
 292+ 0000              ;дисковые операции -------------------
 293+ 0000
 294+ 0000              ;открыть файл для чтения или записи
 295+ 0000                  macro OS_FILE_OPEN ;HL - File name (out: A - id file, bc, de - size)
 296+ 0000 ~                ld c,#21
 297+ 0000 ~                rst #20
 298+ 0000                  endm
 299+ 0000
 300+ 0000              ;создать файл
 301+ 0000                  macro OS_FILE_CREATE ;HL - File name  (out: A - id file)
 302+ 0000 ~                ld c,#22
 303+ 0000 ~                rst #20
 304+ 0000                  endm
 305+ 0000
 306+ 0000              ;прочитать из файла
 307+ 0000                  macro OS_FILE_READ ;HL - address, A - id file, DE - length (out: bc - size readed)
 308+ 0000 ~                ld c,#23
 309+ 0000 ~                rst #20
 310+ 0000                  endm
 311+ 0000
 312+ 0000              ;записать в файл
 313+ 0000                  macro OS_FILE_WRITE ;HL - address, A - id file, DE - length (out: bc - size writed)
 314+ 0000 ~                ld c,#24
 315+ 0000 ~                rst #20
 316+ 0000                  endm
 317+ 0000
 318+ 0000              ;закрыть файл
 319+ 0000                  macro OS_FILE_CLOSE ;A - id file
 320+ 0000 ~                ld c,#25
 321+ 0000 ~                rst #20
 322+ 0000                  endm
 323+ 0000
 324+ 0000              ;чтение секторов текущего каталога
 325+ 0000              ; вх:
 326+ 0000                   ; hl - буфер для чтения
 327+ 0000                   ; de - относительный номер первого сектора каталога для чтения [0..nn]
 328+ 0000                   ; b - максимальное количество секторов для чтения
 329+ 0000              ; вых: cy=1, если были ошибки, код ошибки возвращается в аккумуляторе
 330+ 0000                     ; a=errRWnum
 331+ 0000                     ; a=errInvalidPart
 332+ 0000                     ; a=errFileEmpty
 333+ 0000                   ; cy=0, a=errEoF - каталог закончился
 334+ 0000                     ; hl - следующий адрес в буфере
 335+ 0000                     ; de - номер первого непрочитанного сектора
 336+ 0000                     ; b - не прочитано секторов
 337+ 0000                   ; cy=0 - считано успешно
 338+ 0000                     ; hl - следующий адрес в буфере
 339+ 0000                     ; de - номер первого непрочитанного сектора
 340+ 0000                     ; b=#00
 341+ 0000                  macro OS_READ_DIR ;
 342+ 0000 ~                ld c,#26
 343+ 0000 ~                rst #20
 344+ 0000                  endm
 345+ 0000
 346+ 0000              ;вход в каталог/выход в родительский каталог
 347+ 0000              	; Если путь не указан производится только настройка переменных драйвера,
 348+ 0000              	; при этом если передан дескриптор файла, текущий каталог не изменится)
 349+ 0000              	; Если пусть указан, в конец пути добавится название каталога (если это
 350+ 0000              	; переход в родительский, последнее имя в пути удалится).
 351+ 0000              	; Если передан дескриптор файла, текущий каталог не изменится, к пути
 352+ 0000              	; добавится имя файла
 353+ 0000              ; вх:
 354+ 0000                   ; hl - адрес пути (=#0000 - путь отсутствует)
 355+ 0000                   ; de - адрес дескриптора директории/файла
 356+ 0000              ; вых: a - если путь был указан, новая длина пути
 357+ 0000                  macro OS_OPEN_DIR ;
 358+ 0000 ~                ld c,#27
 359+ 0000 ~                rst #20
 360+ 0000                  endm
 361+ 0000
 362+ 0000
 363+ 0000                  ; macro OS_ ;
 364+ 0000                  ; ld c,#28
 365+ 0000                  ; rst #20
 366+ 0000                  ; endm
 367+ 0000
 368+ 0000                  ; macro OS_ ;
 369+ 0000                  ; ld c,#29
 370+ 0000                  ; rst #20
 371+ 0000                  ; endm
 372+ 0000
 373+ 0000
# file closed: ../os_defs.asm
   3  0000                  org PROGSTART
   4  8000              asmOrg:
   5  8000 C3 5B A3         jp start
   6  8003
   7  8003              ; Generate version string
   8  8003                  LUA ALLPASS
   9  8003 ~                v = tostring(sj.get_define("V"))
  10  8003 ~                maj = string.sub(v, 1,1)
  11  8003 ~                min = string.sub(v, 2,2)
  12  8003 ~                sj.insert_define("VERSION_STRING", "\"" .. maj .. "." .. min .. "\"")
  13  8003                  ENDLUA
  14  8003
  15  8003                  include "vdp/index.asm"
# file opened: vdp/index.asm
   1+ 8003                  IFDEF TIMEX
   2+ 8003 ~                include "timex.asm"
   3+ 8003                  ENDIF
   4+ 8003
   5+ 8003                  IFDEF TIMEX80
   6+ 8003 ~                include "timex80.asm"
   7+ 8003                  ENDIF
   8+ 8003
   9+ 8003                  IFDEF ZXSCR
  10+ 8003 ~                include "zx.asm"
  11+ 8003                  ENDIF
  12+ 8003
  13+ 8003                  IFDEF ZSGMX
  14+ 8003                  include "zsgmx.asm"
# file opened: vdp/zsgmx.asm
   1++8003              COLOR=1
   2++8003              ;; ZS GMX screen driver (izzx)
   3++8003              	;define LINE_LIMIT 80
   4++8003                  module TextMode
   5++8003              init:
   6++8003                  ; ld hl, font_file, b, Dos.FMODE_READ
   7++8003                  ; call Dos.fopen
   8++8003                  ; push af
   9++8003                  ; ld bc, 2048, hl, font
  10++8003                  ; call Dos.fread
  11++8003                  ; pop af
  12++8003                  ; call Dos.fclose
  13++8003              	; xor a : out (#fe), a
  14++8003              	; call cls
  15++8003              	; ret
  16++8003              cls:
  17++8003              	OS_CLS
  17++8003 0E 00       >    ld c,#00
  17++8005 E7          >    rst #20
  18++8006 C9           	ret
  19++8007                  ; ld de, 0 : call gotoXY
  20++8007                  ; ;ld a, 7 : call Memory.setPage
  21++8007              	; ld a,#3b
  22++8007              	; call PageSlot3 ;включить страницу пикселей
  23++8007                  ; xor a : out (#fe), a
  24++8007                  ; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  25++8007              	; ld a,#7b
  26++8007              	; call PageSlot3 ;включить страницу атрибутов
  27++8007              	; ld a,(attr_screen) ;цвет
  28++8007              	; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  29++8007              	; call gmxscron ;включить расширенный экран
  30++8007              	; xor a
  31++8007              	; jp PageSlot3 ;вернуть страницу 0
  32++8007                  ;jp Memory.setPage
  33++8007
  34++8007
  35++8007              ; Set console coordinates
  36++8007              ; d = row(0..23), e = column (0..79)
  37++8007              gotoXY:
  38++8007              	OS_SET_XY
  38++8007 0E 01       >    ld c,#01
  38++8009 E7          >    rst #20
  39++800A              	;rr e
  40++800A              	; ld a, 0
  41++800A              	; ld (half_tile_screen), a
  42++800A                  ;ld (col_screen), de
  43++800A C9               ret
  44++800B
  45++800B              disable:
  46++800B                  ; Nothing to disable
  47++800B              	;call gmxscroff ;выключить расширенный экран
  48++800B C9               ret
  49++800C
  50++800C              ; H - line
  51++800C              ; A - char
  52++800C              fillLine: ;заполнение строки одним символом
  53++800C              	OS_FILL_LINE
  53++800C 0E 03       >    ld c,#03
  53++800E E7          >    rst #20
  54++800F C9           	ret
  55++8010                  ; push af
  56++8010                  ; ld d, h, e, 0 : call gotoXY
  57++8010                  ; pop af
  58++8010                  ; ld hl, fill_buff, de, fill_buff + 1, bc, 80-1, (hl), a : ldir
  59++8010                  ; ld hl, fill_buff : jp printZ
  60++8010
  61++8010              usualLine: ;на входе в A номер строки, которую надо покрасить обычным цветом
  62++8010 06 07        	ld b,#07 ;цвет
  63++8012              	OS_PAINT_LINE
  63++8012 0E 04       >    ld c,#04
  63++8014 E7          >    rst #20
  64++8015 C9           	ret
  65++8016                  ; ld b, a
  66++8016                  ; ld c, 0
  67++8016                  ; call bc_to_attr
  68++8016                  ; ;ld a, 7 : call Memory.setPage
  69++8016              	; push hl
  70++8016              	; ld a,#7b ;атрибуты
  71++8016              	; call PageSlot3
  72++8016              	; pop hl
  73++8016              	; ld a,(attr_screen) ;цвет
  74++8016                  ; ld (hl), a
  75++8016                  ; ld de, hl
  76++8016                  ; inc de
  77++8016                  ; ld bc, (80*8)-1
  78++8016                  ; ldir
  79++8016                  ; xor a : ;jp Memory.setPage
  80++8016              	; jp PageSlot3 ;вернуть страницу 0
  81++8016
  82++8016              highlightLine: ;на входе в A номер строки, которую надо покрасить другим цветом
  83++8016 06 0C        	ld b,#0c ;цвет
  84++8018              	OS_PAINT_LINE
  84++8018 0E 04       >    ld c,#04
  84++801A E7          >    rst #20
  85++801B C9           	ret
  86++801C                  ; ld b, a
  87++801C                  ; ld c, 0
  88++801C                  ; call bc_to_attr
  89++801C                  ; ;ld a, 7 : call Memory.setPage
  90++801C              	; push hl
  91++801C              	; ld a,#7b ;атрибуты
  92++801C              	; call PageSlot3
  93++801C              	; pop hl
  94++801C              	; ld a,(attr_screen2) ;цвет
  95++801C                  ; ld (hl), a
  96++801C                  ; ld de, hl
  97++801C                  ; inc de
  98++801C                  ; ld bc, (80*8)-1
  99++801C                  ; ldir
 100++801C                  ; xor a : ;jp Memory.setPage
 101++801C              	; jp PageSlot3 ;вернуть страницу 0
 102++801C
 103++801C              ; mvCR ;каретка вниз
 104++801C              	; ld de, (col_screen)
 105++801C              	; inc d
 106++801C              	; ld e, 0
 107++801C              	; ; ld a, 0
 108++801C              	; ; ld (half_tile_screen), a
 109++801C              	; jp gotoXY
 110++801C
 111++801C              ; Print just one symbol
 112++801C              ; A - symbol
 113++801C              putC
 114++801C              	OS_PRINT_CHARF
 114++801C D7          >	rst #10
 115++801D C9           	ret
 116++801E                  ; cp 13 : jp z, mvCR
 117++801E
 118++801E              	; ld hl, single_symbol
 119++801E              	; ld (hl), a
 120++801E              	; ;ld a, 7 : call Memory.setPage
 121++801E              	; ld a,#3b ;пиксели
 122++801E              	; call PageSlot3
 123++801E                  ; ld hl, single_symbol_print
 124++801E                  ; call printL
 125++801E                  ; xor a : ;jp Memory.setPage
 126++801E              	; jp PageSlot3 ;вернуть страницу 0
 127++801E
 128++801E              ; Put string
 129++801E              ; hl - string pointer that's begins from symbol count
 130++801E              printZ
 131++801E              	OS_PRINTZ
 131++801E 0E 09       >    ld c,#09
 131++8020 E7          >    rst #20
 132++8021 C9           	ret
 133++8022                  ; ld a, (hl) : and a : ret z
 134++8022                  ; push hl
 135++8022                  ; call putC
 136++8022                  ; pop hl
 137++8022                  ; inc hl
 138++8022                  ; jr printZ
 139++8022
 140++8022              ; printL
 141++8022                      ; ld	a, (hl)
 142++8022              		; and	a
 143++8022              		; ret	z
 144++8022
 145++8022              		; ; push	hl
 146++8022              		; ; call	calc_addr_scr
 147++8022              		; ; ld	a,(attr_screen)
 148++8022              		; ; ;ld	(hl),a ;покрасить символ
 149++8022              		; ; pop	hl
 150++8022
 151++8022              		; ;call	calc_addr_scr
 152++8022
 153++8022              		; ; ld	a,(half_tile_screen)
 154++8022              		; ; bit	0,a
 155++8022              		; ; ld	a,(hl)
 156++8022              		; ; jp	nz,print64_4
 157++8022              ; ;print80_3
 158++8022                      ; push    af
 159++8022              		; push	hl
 160++8022              		; ; ld a,#7b ;атрибуты
 161++8022              		; ; call PageSlot3
 162++8022              		; call	calc_addr_scr
 163++8022              		; ; ld	a,(attr_screen)
 164++8022              		; ; ld	(hl),a ;покрасить символ
 165++8022              		; ld d,h ;координаты экрана в DE
 166++8022              		; ld e,l
 167++8022              		; ; ld a,#3b ;пиксели
 168++8022              		; ; call PageSlot3
 169++8022              		; pop	hl
 170++8022
 171++8022                      ; inc     hl
 172++8022                      ; push    hl
 173++8022
 174++8022                      ; ld      a,(hl)
 175++8022              		; ld	l,a
 176++8022              		; ld	h,0
 177++8022              		; add	hl,hl
 178++8022              		; add	hl,hl
 179++8022              		; add	hl,hl
 180++8022                      ; ld      bc,font
 181++8022                      ; add     hl,bc
 182++8022
 183++8022                      ; ;push    de
 184++8022
 185++8022                      ; ld      b,8
 186++8022              		; ; xor	a
 187++8022              		; ; ld	(de),a
 188++8022              ; print80_1
 189++8022              	; ;inc     d
 190++8022
 191++8022              	; ld      a,(hl)
 192++8022              	; ;and	#f0
 193++8022              	; ld      (de),a
 194++8022              	; inc     hl
 195++8022
 196++8022              	; push hl ;на строку пикселей вниз
 197++8022              	; ld hl,80
 198++8022              	; add hl,de
 199++8022              	; ex de,hl
 200++8022              	; pop hl
 201++8022
 202++8022              	; djnz    print80_1
 203++8022
 204++8022              	; ;inc	d
 205++8022              	; ; push hl
 206++8022              	; ; ld hl,80
 207++8022              	; ; add hl,de
 208++8022              	; ; ex de,hl
 209++8022              	; ; pop hl
 210++8022
 211++8022              	; ; xor	a
 212++8022              	; ; ld	(de),a
 213++8022
 214++8022              	; ; ld	a,1
 215++8022              	; ; ld	(half_tile_screen),a
 216++8022
 217++8022              	; ;pop     de
 218++8022              	; pop     hl
 219++8022              	; pop     af
 220++8022
 221++8022              	; ;dec     a
 222++8022              	; ; ret     ;z
 223++8022
 224++8022              ; ; print64_4
 225++8022              	; ; push    af
 226++8022
 227++8022              	; ; inc     hl
 228++8022              	; ; push    hl
 229++8022
 230++8022              	; ; ld      a,(hl)
 231++8022              	; ; ld	l,a
 232++8022              	; ; ld	h,0
 233++8022              	; ; add	hl,hl
 234++8022              	; ; add	hl,hl
 235++8022              	; ; add	hl,hl
 236++8022              	; ; ld      bc,font
 237++8022              	; ; add     hl,bc
 238++8022
 239++8022              	; ; push    de
 240++8022
 241++8022              	; ; ld      b,6
 242++8022              	; ; xor	a
 243++8022              	; ; ld	(de),a
 244++8022              ; ; print64_2
 245++8022              	; ; ;inc     d
 246++8022              	; ; push hl
 247++8022              	; ; ld hl,80
 248++8022              	; ; add hl,de
 249++8022              	; ; ex de,hl
 250++8022              	; ; pop hl
 251++8022              	; ; ld      a,(hl)
 252++8022              	; ; ;and     #0f
 253++8022              	; ; ld      c,a
 254++8022              	; ; ld      a,(de)
 255++8022              	; ; or      c
 256++8022              	; ; ld      (de),a
 257++8022              	; ; inc     hl
 258++8022              	; ; djnz    print64_2
 259++8022
 260++8022              	; ; ;inc	d
 261++8022              	; ; push hl
 262++8022              	; ; ld hl,80
 263++8022              	; ; add hl,de
 264++8022              	; ; ex de,hl
 265++8022              	; ; pop hl
 266++8022              	; ; xor	a
 267++8022              	; ; ld	(de),a
 268++8022
 269++8022              	; ; ld	(half_tile_screen),a
 270++8022
 271++8022              	; ; pop     de
 272++8022
 273++8022              	; ; call	move_cr64
 274++8022
 275++8022              	; ; pop     hl
 276++8022              	; ; pop     af
 277++8022              	; ; dec     a
 278++8022
 279++8022              	; ; jp      nz,print64_3
 280++8022
 281++8022              	; ; ret
 282++8022
 283++8022              ; ; move cursor на одну позицию вперёд
 284++8022              ; move_cr80
 285++8022              	; ;inc	de
 286++8022
 287++8022              	; ld	hl,col_screen
 288++8022              	; inc	(hl) ;увеличить столбец
 289++8022              	; ld	a,(hl)
 290++8022
 291++8022              	; cp	80
 292++8022              	; ret	c
 293++8022
 294++8022              	; xor	a
 295++8022              	; ;ld	(half_tile_screen),a
 296++8022              	; ld	(hl),a
 297++8022              	; ld	c,a
 298++8022
 299++8022              	; inc	hl ;на переменную row
 300++8022              	; inc	(hl)
 301++8022              	; ld	a,(hl)
 302++8022              	; ld	b,a
 303++8022
 304++8022              	; cp	24
 305++8022              	; jp	c,move_cr80_01
 306++8022
 307++8022              	; ld	a,23
 308++8022              	; ld	(hl),a
 309++8022              	; ld	b,a
 310++8022
 311++8022              	; ; push	bc
 312++8022              	; ; call	scroll_up8
 313++8022              	; ; pop	bc
 314++8022
 315++8022              ; move_cr80_01
 316++8022              	; ; call	calc_addr_scr
 317++8022              	; ; ret
 318++8022
 319++8022              ; calc_addr_scr	;определение адреса экрана по координатам символа
 320++8022              	; ld	bc,(col_screen)
 321++8022              ; bc_to_attr:
 322++8022              	; ld h,0
 323++8022              	; ld l,b ;строка
 324++8022              	; add hl,hl ;*2
 325++8022              	; ld de,table_addr_scr
 326++8022              	; add hl,de
 327++8022              	; ld e,(hl)
 328++8022              	; inc hl
 329++8022              	; ld d,(hl) ;узнали координаты строки
 330++8022              	; ld h,0
 331++8022              	; ld l,c ;колонка
 332++8022              	; add hl,de ;узнали адрес символа
 333++8022              	; ; ld      a,b
 334++8022              	; ; ld      d,a
 335++8022              	; ; rrca
 336++8022              	; ; rrca
 337++8022              	; ; rrca
 338++8022              	; ; and     a,224
 339++8022              	; ; add     a,c
 340++8022              	; ; ld      e,a
 341++8022              	; ; ld      a,d
 342++8022              	; ; and     24
 343++8022              	; ; or      #c0
 344++8022              	; ; ld      d,a
 345++8022              	; ret
 346++8022
 347++8022              ; ; calc_addr_attr
 348++8022              	; ; ld	bc,(col_screen)
 349++8022              ; ; bc_to_attr:
 350++8022              	; ; ld	a,b
 351++8022              	; ; rrca
 352++8022              	; ; rrca
 353++8022              	; ; rrca
 354++8022              	; ; ld	l,a
 355++8022              	; ; and	31
 356++8022              	; ; or	#d8
 357++8022              	; ; ld	h,a
 358++8022              	; ; ld	a,l
 359++8022              	; ; and	252
 360++8022              	; ; or	c
 361++8022              	; ; ld	l,a
 362++8022              	; ; ret
 363++8022
 364++8022              ; ; scroll_up8	;
 365++8022              	; ; ld	hl,table_addr_scr
 366++8022              	; ; ld	b,184
 367++8022
 368++8022              ; ; scroll_up8_01
 369++8022              	; ; push	bc
 370++8022
 371++8022              	; ; ld	e,(hl)
 372++8022              	; ; inc	hl
 373++8022              	; ; ld	d,(hl)
 374++8022              	; ; inc	hl
 375++8022
 376++8022              	; ; push	hl
 377++8022
 378++8022              	; ; ld	bc,14
 379++8022              	; ; add	hl,bc
 380++8022              	; ; ld	c,(hl)
 381++8022              	; ; inc	hl
 382++8022              	; ; ld	b,(hl)
 383++8022
 384++8022              	; ; ld	h,b
 385++8022              	; ; ld	l,c
 386++8022
 387++8022              	; ; ld	bc,32
 388++8022              	; ; ldir
 389++8022
 390++8022              	; ; pop	hl
 391++8022              	; ; pop	bc
 392++8022              	; ; djnz	scroll_up8_01
 393++8022
 394++8022              	; ; ld	b,8
 395++8022
 396++8022              ; ; scroll_up8_02
 397++8022              	; ; push	bc
 398++8022
 399++8022              	; ; ld	e,(hl)
 400++8022              	; ; inc	hl
 401++8022              	; ; ld	d,(hl)
 402++8022              	; ; inc	hl
 403++8022
 404++8022              	; ; push	hl
 405++8022
 406++8022              	; ; ld	h,d
 407++8022              	; ; ld	l,e
 408++8022              	; ; inc	de
 409++8022              	; ; ld	(hl),0
 410++8022              	; ; ld	bc,31
 411++8022              	; ; ldir
 412++8022
 413++8022              	; ; pop	hl
 414++8022              	; ; pop	bc
 415++8022              	; ; djnz	scroll_up8_02
 416++8022              	; ; ld	de,#D800, hl,#D820, bc,736
 417++8022              	; ; ldir
 418++8022              	; ; ld	a,(de)
 419++8022              	; ; ld	hl,#dae0, de,#dae1, (hl),a, bc,31
 420++8022              	; ; ldir
 421++8022
 422++8022              	; ; ret
 423++8022
 424++8022
 425++8022              ; gmxscron
 426++8022                          ; ld      bc,#7efd
 427++8022                          ; ld      a,#c8
 428++8022                          ; out     (c),a
 429++8022                          ; ; ld      bc,#7ffd
 430++8022                          ; ; ld      a,#10    ;5 screen
 431++8022                          ; ; out     (c),a
 432++8022                          ; ret
 433++8022
 434++8022              ; ; gmxscron2
 435++8022                          ; ; ld      bc,#7efd
 436++8022                          ; ; ld      a,#c8
 437++8022                          ; ; out     (c),a
 438++8022                          ; ; ld      bc,#7ffd
 439++8022                          ; ; ld      a,#18    ;7 screen
 440++8022                          ; ; out     (c),a
 441++8022                          ; ; ret
 442++8022
 443++8022              ; gmxscroff
 444++8022                          ; ld      bc,#7efd
 445++8022                          ; ld      a,#c0
 446++8022                          ; out     (c),a
 447++8022                          ; ; ld      bc,#7ffd
 448++8022                          ; ; ld      a,#10    ;5 screen
 449++8022                          ; ; out     (c),a
 450++8022                          ; ret
 451++8022
 452++8022
 453++8022              ; PageSlot3
 454++8022              ; ; драйвер памяти для TR-DOS Navigator
 455++8022              ; ; и Scorpion GMX 2Mb
 456++8022                       ; ; org  #5b00
 457++8022                       ; ; jr   pag_on
 458++8022                       ; ; jr   clock
 459++8022                       ; ; db   #00
 460++8022                       ; ; db   #00
 461++8022
 462++8022                       ; ;push hl
 463++8022                       ; ld   hl,table
 464++8022                       ; add  a,l
 465++8022                       ; jr   nc,PageSlot3_1
 466++8022                       ; inc  h          ;коррекция
 467++8022              ; PageSlot3_1  ld   l,a
 468++8022                       ; ld   a,(hl)
 469++8022                       ; ;pop  hl
 470++8022                       ; ;cp   #ff
 471++8022                       ; ;scf
 472++8022                       ; ;ret  z
 473++8022                       ; ;push bc
 474++8022                       ; push af
 475++8022                       ; rlca
 476++8022                       ; and  #10
 477++8022                       ; ld   bc,#1ffd
 478++8022              ; PageSlot3DOS
 479++8022              		 ; ;or #00 ; #04 тут выбор ПЗУ TRDOS
 480++8022                       ; out  (c),a
 481++8022                       ; pop  af
 482++8022                       ; push af
 483++8022                       ; and  #07
 484++8022              ; PageSlot3Scr ;тут выбор экрана и ПЗУ
 485++8022                       ; or   #18 ;#0 ;#18
 486++8022                       ; ld   b,#7f
 487++8022                       ; out  (c),a
 488++8022                       ; pop  af
 489++8022                       ; rrca
 490++8022                       ; rrca
 491++8022                       ; rrca
 492++8022                       ; rrca
 493++8022                       ; and  #07
 494++8022                       ; ld   b,#df
 495++8022                       ; out  (c),a
 496++8022                       ; ;pop  hl
 497++8022                       ; ret
 498++8022              ; ; clock    ld   d,%00100000
 499++8022                       ; ; rst  8
 500++8022                       ; ; db   #89
 501++8022                       ; ; ret
 502++8022
 503++8022                       ; ; org  #5b5c ; здесь системная переменая
 504++8022                       ; ; db   #10
 505++8022              ; ;все страницы
 506++8022              ; table    db   #00,#01,#02,#03,#04,#05,#06,#07,#08,#09
 507++8022                       ; db   #0a,#0b,#0c,#0d,#0e
 508++8022                       ; db   #0f,#10,#11,#12,#13,#14
 509++8022                       ; db   #15,#16,#17,#18,#19,#1a
 510++8022                       ; db   #1b,#1c,#1d,#1e,#1f,#20
 511++8022                       ; db   #21,#22,#23,#24,#25,#26
 512++8022                       ; db   #27,#28,#29,#2a,#2b,#2c
 513++8022                       ; db   #2d,#2e,#2f,#30,#31,#32
 514++8022                       ; db   #33,#34,#35,#36,#37,#38,#39
 515++8022                       ; db   #3a,#3b,#3c,#3d,#3e,#3f,#40
 516++8022                       ; db   #41,#42,#43,#44,#45,#46
 517++8022                       ; db   #47,#48,#49,#4a,#4b,#4c
 518++8022
 519++8022                       ; db   #4d,#4e,#4f,#50,#51,#52
 520++8022                       ; db   #53,#54,#55,#56,#57,#58
 521++8022                       ; db   #59,#5a,#5b,#5c,#5d,#5e
 522++8022                       ; db   #5f,#60,#61,#62,#63,#64
 523++8022                       ; db   #65,#66,#67,#68,#69,#6a
 524++8022                       ; db   #6b,#6c,#6d,#6e,#6f,#70
 525++8022                       ; db   #71,#72,#73,#74,#75,#76
 526++8022                       ; db   #77,#78,#79,#7a,#7b,#7c,#7d,#7e
 527++8022                       ; db   #7f
 528++8022
 529++8022                       ; db   #ff ;конец таблицы
 530++8022
 531++8022
 532++8022
 533++8022              ; font equ #4000 ; Using ZX-Spectrum screen as font buffer
 534++8022              ; font_file db "data/font.bin", 0
 535++8022
 536++8022
 537++8022              ; table_addr_scr	;адреса строк текста
 538++8022              	; defw	#c000 ;0
 539++8022              	; defw	#c280
 540++8022              	; defw	#c500
 541++8022              	; defw	#c780
 542++8022              	; defw	#ca00
 543++8022              	; defw	#cc80
 544++8022              	; defw	#cf00
 545++8022              	; defw	#d180
 546++8022
 547++8022              	; defw	#d400 ;8
 548++8022              	; defw	#d680
 549++8022              	; defw	#d900
 550++8022              	; defw	#db80
 551++8022              	; defw	#de00
 552++8022              	; defw	#e080
 553++8022              	; defw	#e300
 554++8022              	; defw	#e580
 555++8022
 556++8022              	; defw	#e800 ;16
 557++8022              	; defw	#ea80
 558++8022              	; defw	#ed00
 559++8022              	; defw	#ef80
 560++8022              	; defw	#f200
 561++8022              	; defw	#f480
 562++8022              	; defw	#f700
 563++8022              	; defw	#f980
 564++8022
 565++8022              	; defw	#fc00 ;24
 566++8022              	; defw	#fe80 ;25 вне экрана
 567++8022
 568++8022
 569++8022              ; col_screen			db	0	;столбец
 570++8022              ; row_screen			db	0	;строка
 571++8022              ; ;half_tile_screen	db	0
 572++8022              ; attr_screen			db	07	;основной цвет
 573++8022              ; attr_screen2		db	#c	;другой цвет
 574++8022
 575++8022              ; ;col_screen_temp			dw	0
 576++8022              ; ;half_tile_screen_temp	db	0
 577++8022
 578++8022              ; single_symbol_print db 1
 579++8022              ; single_symbol 		db 0
 580++8022
 581++8022              ; fill_buff ds 80+1
 582++8022
 583++8022                  endmodule
# file closed: vdp/zsgmx.asm
  15+ 8022                  ENDIF
# file closed: vdp/index.asm
  16  8022                  include "utils/index.asm"
# file opened: utils/index.asm
   1+ 8022                  include "atoi.asm"
# file opened: utils/atoi.asm
   1++8022              ; DE - buffer
   2++8022              ; HL - output
   3++8022              atohl:
   4++8022 21 00 00         ld hl, 0
   5++8025              .loop
   6++8025 1A               ld a, (de)
   7++8026 13               inc de
   8++8027                  ; Sepparators
   9++8027 C5 E5            push bc, hl
  10++8029 01 05 00             ld bc, sepparators_len
  11++802C 21 44 80             ld hl, sepparators
  12++802F ED B1                cpir
  13++8031 E1 C1            pop hl, bc
  14++8033 C8               ret z
  15++8034
  16++8034 D6 30            sub '0'
  17++8036
  18++8036 C5               push bc
  19++8037 4D                   ld c, l
  20++8038 44                   ld b, h
  21++8039
  22++8039 29                   add hl, hl
  23++803A 29                   add hl, hl
  24++803B 09                   add hl, bc
  25++803C 29                   add hl, hl
  26++803D 4F                   ld c, a
  27++803E 06 00                ld b, 0
  28++8040 09                   add hl, bc
  29++8041 C1               pop bc
  30++8042 18 E1            jr .loop
  31++8044
# file closed: utils/atoi.asm
   2+ 8044                  include "constants.asm"
# file opened: utils/constants.asm
   1++8044              TAB = 9
   2++8044              CR = 13
   3++8044              LF = 10
   4++8044              NULL = 0
   5++8044              SPACE = ' '
   6++8044              ESC = 27
   7++8044
   8++8044                  IFNDEF TIMEX80
   9++8044              MIME_DOWNLOAD = 1
  10++8044              MIME_LINK     = 2
  11++8044              MIME_TEXT     = 3
  12++8044              MIME_IMAGE    = 6
  13++8044              MIME_MUSIC    = 5
  14++8044              MIME_INPUT    = 4
  15++8044              MIME_MOD      = 7
  16++8044
  17++8044              BORDER_TOP    = 9
  18++8044              BORDER_BOTTOM = 8
  19++8044                  ELSE
  20++8044 ~            MIME_DOWNLOAD = #19
  21++8044 ~            MIME_LINK = #1A
  22++8044 ~            MIME_TEXT = #10
  23++8044 ~            MIME_IMAGE = #01
  24++8044 ~            MIME_MUSIC = #0e
  25++8044 ~            MIME_INPUT = #b3
  26++8044 ~            MIME_MOD = #0d
  27++8044 ~
  28++8044 ~            BORDER_TOP = #b2
  29++8044 ~            BORDER_BOTTOM = #b1
  30++8044 ~
  31++8044                  ENDIF
  32++8044
  33++8044 0D 0A 09 00  sepparators db CR, LF, TAB, NULL, SPACE
  33++8048 20
  34++8049              sepparators_len = $ - sepparators
# file closed: utils/constants.asm
   3+ 8049                  include "strutils.asm"
# file opened: utils/strutils.asm
   1++8049              ; de - pointer
   2++8049              ; hl - count
   3++8049              strlen:
   4++8049 21 00 00         ld hl, 0
   5++804C              .loop
   6++804C 1A               ld a, (de)
   7++804D A7               and a
   7++804E 28 04          jr z, .exit
   8++8050 23               inc hl
   9++8051 13               inc de
  10++8052 18 F8            jr .loop
  11++8054              .exit
  12++8054 C9               ret
  13++8055
  14++8055                  module CompareBuff
  15++8055
  16++8055              ; Pushes A to buffer
  17++8055              push
  18++8055 F5               push af
  19++8056 06 20            ld b, 32
  19++8058 21 A1 80       ld hl, buffer + 1
  19++805B 11 A0 80       ld de, buffer
  20++805E              .loop
  21++805E 7E               ld a, (hl)
  21++805F 12             ld (de), a
  21++8060 23             inc hl
  21++8061 13             inc de
  21++8062 10 FA          djnz .loop
  22++8064 F1               pop af
  23++8065 21 BF 80         ld hl, buffer + 31
  23++8068 77             ld (hl), a
  24++8069 C9               ret
  25++806A
  26++806A              ; HL - Compare string(null terminated)
  27++806A              ; A - 0 NOT Found
  28++806A              ;     1 Found
  29++806A              search:
  30++806A 06 00            ld b, 0
  30++806C E5             push hl
  31++806D              .loop:
  32++806D 7E               ld a, (hl)
  32++806E 23             inc hl
  32++806F 04             inc b
  32++8070 A7             and a
  32++8071 C2 6D 80       jp nz, .loop
  33++8074 05               dec b
  33++8075 E1             pop hl
  33++8076 C5             push bc
  33++8077 E5             push hl
  34++8078 E1               pop hl
  35++8079 11 C0 80         ld de, buffer + 32
  36++807C              .sourceLoop
  37++807C 1B               dec de
  37++807D 10 FD          djnz .sourceLoop
  38++807F C1               pop bc
  39++8080              .compare
  40++8080 C5               push bc
  40++8081 F5             push af
  41++8082 1A               ld a, (de)
  41++8083 47             ld b, a
  42++8084 F1               pop af
  42++8085 7E             ld a, (hl)
  42++8086 B8             cp b
  42++8087 C1             pop bc
  42++8088 3E 00          ld a, 0
  42++808A C0             ret nz
  43++808B 13               inc de
  43++808C 23             inc hl
  44++808D 10 F1            djnz .compare
  45++808F 3E 01            ld a, 1
  46++8091 C9               ret
  47++8092
  48++8092              clear:
  49++8092 AF               xor a
  49++8093 21 A0 80       ld hl, buffer
  49++8096 11 A1 80       ld de, buffer + 1
  49++8099 01 20 00       ld bc, 32
  49++809C 77             ld (hl), a
  49++809D ED B0          ldir
  50++809F C9               ret
  51++80A0
  52++80A0 00 00 00...  buffer ds 32
  53++80C0
  54++80C0                  endmodule
# file closed: utils/strutils.asm
   4+ 80C0                  include "screen.asm"
# file opened: utils/screen.asm
   1++80C0                  IFNDEF LINE_LIMIT
   2++80C0              LINE_LIMIT = 60
   3++80C0                  ENDIF
   4++80C0              ; HL - string pointer
   5++80C0              print70Text:
   6++80C0 06 3C            ld b, LINE_LIMIT
   7++80C2              .loop
   8++80C2 7E               ld a, (hl)
   9++80C3 A7               and a
   9++80C4 C8             ret z
  10++80C5 FE 0D            cp 13
  10++80C7 C8             ret z
  11++80C8 FE 0A            cp 10
  11++80CA C8             ret z
  12++80CB C5               push bc
  13++80CC E5               push hl
  14++80CD CD 1C 80         call TextMode.putC
  15++80D0 E1               pop hl
  16++80D1 23               inc hl
  17++80D2 C1               pop bc
  18++80D3 05               dec b
  19++80D4 78               ld a, b
  19++80D5 A7             and a
  19++80D6 C8             ret z
  20++80D7 C3 C2 80         jp .loop
  21++80DA
  22++80DA              ; HL - string pointer
  23++80DA              print70Goph:
  24++80DA 06 3C            ld b, LINE_LIMIT
  25++80DC              .loop
  26++80DC 7E               ld a, (hl)
  26++80DD FE 09          cp 09
  26++80DF C8             ret z
  27++80E0 A7               and a
  27++80E1 C8             ret z
  28++80E2 C5               push bc
  29++80E3 E5               push hl
  30++80E4 CD 1C 80         call TextMode.putC
  31++80E7 E1               pop hl
  32++80E8 23               inc hl
  33++80E9 C1               pop bc
  34++80EA 05               dec b
  35++80EB 78               ld a, b
  35++80EC A7             and a
  35++80ED C8             ret z
  36++80EE C3 DC 80         jp .loop
# file closed: utils/screen.asm
# file closed: utils/index.asm
  17  80F1                  include "gopher/render/index.asm"
# file opened: gopher/render/index.asm
   1+ 80F1                  MODULE Render
   2+ 80F1              PER_PAGE = 19
   3+ 80F1              CURSOR_OFFSET = 3
   4+ 80F1                  include "row.asm"
# file opened: gopher/render/row.asm
   1++80F1              ; A - row number
   2++80F1              ; HL - pointer to row
   3++80F1              renderRow:
   4++80F1 C6 03            add CURSOR_OFFSET
   5++80F3 57 1E 00         ld d, a, e, 0
   5++80F6 CD 07 80       call TextMode.gotoXY
   6++80F9 7E               ld a, (hl)
   7++80FA E5               push hl
   8++80FB CD 06 81         call getIcon
   9++80FE CD 1C 80         call TextMode.putC
  10++8101 E1               pop hl
  11++8102 23               inc hl
  12++8103 C3 DA 80         jp print70Goph
  13++8106
  14++8106              ; A - gopher id char
  15++8106              getIcon:
  16++8106 FE 69            cp 'i'
  16++8108 CA 22 81       jp z, .info
  17++810B FE 39            cp '9'
  17++810D CA 25 81       jp z, .down
  18++8110 FE 31            cp '1'
  18++8112 CA A5 81       jp z, .page
  19++8115 FE 30            cp '0'
  19++8117 CA A8 81       jp z, .text
  20++811A FE 37            cp '7'
  20++811C CA AB 81       jp z, .input
  21++811F 3E 20            ld a, ' '
  22++8121 C9               ret
  23++8122              .info
  24++8122 3E 20            ld a, SPACE
  24++8124 C9             ret
  25++8125              .down
  26++8125 54 5D            ld de, hl
  27++8127 01 FF 00 3E      ld bc, #ff, a, TAB
  27++812B 09
  27++812C ED B1          cpir
  28++812E 78               ld a, b
  28++812F B1             or c
  28++8130 28 70          jr z, .downExit
  29++8132 D5               push de
  30++8133              .nameLoop
  31++8133 7E               ld a, (hl)
  31++8134 A7             and a
  31++8135 28 10          jr z, .check
  32++8137 FE 09            cp TAB
  32++8139 28 0C          jr z, .check
  33++813B FE 0D            cp CR
  33++813D 28 08          jr z, .check
  34++813F E5               push hl
  35++8140 CD 55 80         call CompareBuff.push
  36++8143 E1               pop hl
  37++8144 23               inc hl
  38++8145 18 EC            jr .nameLoop
  39++8147              .check
  40++8147 3A E7 81     	ld a,(saveMode+1);фикс обход открытия файлов, чтобы их скачать по кнопке Caps
  41++814A B7           	or a
  42++814B 20 54        	jr nz,.checkExit
  43++814D 21 BA 81         ld hl, scrExt1
  43++8150 CD 6A 80       call CompareBuff.search
  43++8153 A7             and a
  43++8154 20 58          jr nz, .image
  44++8156 21 BF 81         ld hl, scrExt2
  44++8159 CD 6A 80       call CompareBuff.search
  44++815C A7             and a
  44++815D 20 4F          jr nz, .image
  45++815F              	OS_GET_VTPL_SETUP
  45++815F 0E 18       >    ld c,#18
  45++8161 E7          >    rst #20
  46++8162 3E 03            ld a, 3
  46++8164
  47++8164 77           	ld (hl), a ; 0 bit - looping, 1 bit - pt2 file
  48++8165 21 CE 81         ld hl, pt2Ext1
  48++8168 CD 6A 80       call CompareBuff.search
  48++816B A7             and a
  48++816C 20 44          jr nz, .music
  49++816E 21 D3 81         ld hl, pt2Ext2
  49++8171 CD 6A 80       call CompareBuff.search
  49++8174 A7             and a
  49++8175 20 3B          jr nz, .music
  50++8177              	OS_GET_VTPL_SETUP
  50++8177 0E 18       >    ld c,#18
  50++8179 E7          >    rst #20
  51++817A 3E 01            ld a, 1
  51++817C
  52++817C 77           	ld (hl), a
  53++817D 21 C4 81         ld hl, pt3Ext1
  53++8180 CD 6A 80       call CompareBuff.search
  53++8183 A7             and a
  53++8184 20 2C          jr nz, .music
  54++8186 21 C9 81         ld hl, pt3Ext2
  54++8189 CD 6A 80       call CompareBuff.search
  54++818C A7             and a
  54++818D 20 23          jr nz, .music
  55++818F
  56++818F                  ; General Sound support
  57++818F                  ifdef GS
  58++818F 21 D8 81         ld hl, modExt1
  58++8192 CD 6A 80       call CompareBuff.search
  58++8195 A7             and a
  58++8196 20 1E          jr nz, .mod
  59++8198 21 DD 81         ld hl, modExt2
  59++819B CD 6A 80       call CompareBuff.search
  59++819E A7             and a
  59++819F 20 15          jr nz, .mod
  60++81A1                  endif
  61++81A1              .checkExit
  62++81A1 E1               pop hl
  63++81A2              .downExit
  64++81A2 3E 01            ld a, MIME_DOWNLOAD
  64++81A4 C9             ret
  65++81A5              .page
  66++81A5 3E 02            ld a, MIME_LINK
  66++81A7 C9             ret
  67++81A8              .text
  68++81A8 3E 03            ld a, MIME_TEXT
  68++81AA C9             ret
  69++81AB              .input
  70++81AB 3E 04            ld a, MIME_INPUT
  70++81AD C9             ret
  71++81AE              .image
  72++81AE E1               pop hl
  72++81AF 3E 06          ld a, MIME_IMAGE
  72++81B1 C9             ret
  73++81B2              .music
  74++81B2 E1               pop hl
  74++81B3 3E 05          ld a, MIME_MUSIC
  74++81B5 C9             ret
  75++81B6              .mod
  76++81B6 E1               pop hl
  76++81B7 3E 07          ld a, MIME_MOD
  76++81B9 C9             ret
  77++81BA
  78++81BA 2E 73 63 72  scrExt1 db ".scr", 0
  78++81BE 00
  79++81BF 2E 53 43 52  scrExt2 db ".SCR", 0
  79++81C3 00
  80++81C4
  81++81C4 2E 70 74 33  pt3Ext1 db ".pt3", 0
  81++81C8 00
  82++81C9 2E 50 54 33  pt3Ext2 db ".PT3", 0
  82++81CD 00
  83++81CE 2E 70 74 32  pt2Ext1 db ".pt2", 0
  83++81D2 00
  84++81D3 2E 50 54 32  pt2Ext2 db ".PT2", 0
  84++81D7 00
  85++81D8
  86++81D8 2E 6D 6F 64  modExt1 db ".mod", 0
  86++81DC 00
  87++81DD 2E 4D 4F 44  modExt2 db ".MOD", 0
  87++81E1 00
  88++81E2
  89++81E2              toggleSaveMode
  90++81E2 F5           			push af
  91++81E3 CD A0 86     			call Console.waitForKeyUp
  92++81E6 3E 00        saveMode	ld a,0 ; Флаг Open/Save files
  93++81E8 EE 01        			xor 1
  94++81EA 32 E7 81     			ld (saveMode+1),a
  95++81ED F1           			pop af
  96++81EE C9           			ret
# file closed: gopher/render/row.asm
   5+ 81EF                  include "buffer.asm"
# file opened: gopher/render/buffer.asm
   1++81EF              ; B - line count
   2++81EF              findLine:
   3++81EF 21 5B A3         ld hl, outputBuffer
   4++81F2              findLine2:
   5++81F2 AF               xor a
   5++81F3 B0             or b
   5++81F4 28 1D          jr z, .checkEmpty
   6++81F6              .loop
   7++81F6 7E               ld a, (hl)
   7++81F7 A7             and a
   7++81F8 28 1C          jr z, .nope
   8++81FA FE 0D            cp 13
   8++81FC 23             inc hl
   8++81FD 28 0C          jr z, .checkLF
   9++81FF FE 0A            cp 10
   9++8201 28 02          jr z, .nextCheck
  10++8203 18 F1            jr .loop
  11++8205              .nextCheck
  12++8205 A7               and a
  12++8206 28 0E          jr z, .nope
  13++8208 10 EC            djnz .loop
  14++820A C9               ret
  15++820B              .checkLF
  16++820B 7E               ld a, (hl)
  17++820C FE 0A            cp 10
  17++820E 20 F5          jr nz, .nextCheck
  18++8210 23               inc hl
  19++8211 18 F2            jr  .nextCheck
  20++8213              .checkEmpty
  21++8213 7E               ld a, (hl)
  21++8214 A7             and a
  21++8215 C0             ret nz
  22++8216              .nope
  23++8216 21 00 00         ld hl, 0
  23++8219 C9             ret
# file closed: gopher/render/buffer.asm
   6+ 821A                  include "ui.asm"
# file opened: gopher/render/ui.asm
   1++821A              prepareScreen:
   2++821A CD 03 80         call TextMode.cls
   3++821D 21 46 83         ld hl, header
   3++8220 CD 1E 80       call TextMode.printZ
   4++8223 21 4A 82         ld hl, toolbox
   4++8226 CD 1E 80       call TextMode.printZ
   5++8229 21 28 9D         ld hl, hostName
   5++822C CD 1E 80       call TextMode.printZ
   6++822F 11 00 17         ld de, #1700
   6++8232 CD 07 80       call TextMode.gotoXY
   6++8235 21 56 82       ld hl, footer
   6++8238 CD 1E 80       call TextMode.printZ
   7++823B
   8++823B AF               xor a
   8++823C CD 16 80       call TextMode.highlightLine
   9++823F 3E 01            ld a, 1
   9++8241 CD 16 80       call TextMode.highlightLine
  10++8244 3E 17            ld a, #17
  10++8246 CD 16 80       call TextMode.highlightLine
  11++8249 C9               ret
  12++824A
  13++824A
  14++824A 20 5B 44 5D  toolbox db " [D]omain: ", 0
  14++824E 6F 6D 61 69
  14++8252 6E 3A 20 00
  15++8256 20 20 43 75  footer db "  Cursor - movement  [B]ack to prev. page  [H]ome page", 0
  15++825A 72 73 6F 72
  15++825E 20 2D 20 6D
  15++8262 6F 76 65 6D
  15++8266 65 6E 74 20
  15++826A 20 5B 42 5D
  15++826E 61 63 6B 20
  15++8272 74 6F 20 70
  15++8276 72 65 76 2E
  15++827A 20 70 61 67
  15++827E 65 20 20 5B
  15++8282 48 5D 6F 6D
  15++8286 65 20 70 61
  15++828A 67 65 00
  16++828D
  17++828D              inputHost:
  18++828D CD A0 86         call Console.waitForKeyUp
  19++8290              .loop
  20++8290 11 0B 01         ld de, #010B
  20++8293 CD 07 80       call TextMode.gotoXY
  20++8296 21 28 9D       ld hl, hostName
  20++8299 CD 1E 80       call TextMode.printZ
  21++829C 3E 04            ld a, MIME_INPUT
  21++829E CD 1C 80       call TextMode.putC
  22++82A1 3E 20            ld a, ' '
  22++82A3 CD 1C 80       call TextMode.putC
  23++82A6              .wait
  24++82A6 CD A9 86         call Console.getC
  25++82A9 5F               ld e, a
  26++82AA FE 0C            cp Console.BACKSPACE
  26++82AC 28 17          jr z, .removeChar
  27++82AE FE 0D            cp CR
  27++82B0 CA D3 82       jp z, inputNavigate
  28++82B3 FE 20            cp 32
  28++82B5 38 EF          jr c, .wait
  29++82B7              .putC
  30++82B7 AF               xor a
  30++82B8 21 28 9D 01    ld hl, hostName, bc, 48
  30++82BC 30 00
  30++82BE ED B1          cpir
  31++82C0 77               ld (hl), a
  31++82C1 2B             dec hl
  31++82C2 73             ld (hl), e
  32++82C3 18 CB            jr .loop
  33++82C5              .removeChar
  34++82C5 AF               xor a
  35++82C6 21 28 9D 01      ld hl, hostName, bc, 48
  35++82CA 30 00
  35++82CC ED B1          cpir
  36++82CE 2B               dec hl
  36++82CF 2B             dec hl
  36++82D0 77             ld (hl), a
  37++82D1 18 BD            jr .loop
  38++82D3
  39++82D3              inputNavigate:
  40++82D3 21 28 9D 11      ld hl, hostName, de, domain
  40++82D7 06 83
  41++82D9 7E               ld a,(hl)
  42++82DA A7               and a
  43++82DB CA CD 86         jp z, History.load
  44++82DE              .loop
  45++82DE 7E               ld a, (hl)
  45++82DF A7             and a
  45++82E0 28 05          jr z, .complete
  46++82E2 12               ld (de), a
  46++82E3 23 13          inc hl, de
  47++82E5 18 F7            jr .loop
  48++82E7              .complete
  49++82E7 3E 09            ld a, TAB
  49++82E9 12             ld (de), a
  49++82EA 13             inc de
  50++82EB 3E 37            ld a, '7'
  50++82ED 12             ld (de), a
  50++82EE 13             inc de
  51++82EF 3E 30            ld a, '0'
  51++82F1 12             ld (de), a
  51++82F2 13             inc de
  52++82F3 3E 0D            ld a, CR
  52++82F5 12             ld (de), a
  52++82F6 13             inc de
  53++82F7 3E 0A            ld a, LF
  53++82F9 12             ld (de), a
  53++82FA 13             inc de
  54++82FB 21 01 83         ld hl, navRow
  54++82FE C3 22 87       jp History.navigate
  55++8301
  56++8301 31 20 09 2F  navRow db "1 ", TAB, "/", TAB
  56++8305 09
  57++8306 6E 69 68 69  domain db "nihirash.net"
  57++830A 72 61 73 68
  57++830E 2E 6E 65 74
  58++8312 00 00 00...      ds 64 - ($ - domain)
  59++8346
  60++8346                  IFDEF MB03
  61++8346 ~            header db "      Moon Rabbit "
  62++8346 ~                   db VERSION_STRING
  63++8346 ~                   db " for MB03+  (c) 2021 Alexander Nihirash",13, 0
  64++8346                  ENDIF
  65++8346
  66++8346                  IFDEF UNO
  67++8346 ~            header db "      Moon Rabbit "
  68++8346 ~                   db VERSION_STRING
  69++8346 ~                   db " for ZX-Uno (c) 2021 Alexander Nihirash",13, 0
  70++8346                  ENDIF
  71++8346
  72++8346                  IFDEF AY
  73++8346 ~            header db "      Moon Rabbit "
  74++8346 ~                   db VERSION_STRING
  75++8346 ~                   db " for AYWIFI (c) 2021 Alexander Nihirash",13, 0
  76++8346                  ENDIF
  77++8346
  78++8346                  IFDEF ZW
  79++8346 20 20 20 20  header db "      Moon Rabbit "
  79++834A 20 20 4D 6F
  79++834E 6F 6E 20 52
  79++8352 61 62 62 69
  79++8356 74 20
  80++8358 31 2E 36            db "1.6"
  81++835B 20 66 6F 72         db " for ZX WiFi (c) 2021 Alexander Nihirash",13, 0
  81++835F 20 5A 58 20
  81++8363 57 69 46 69
  81++8367 20 28 63 29
  81++836B 20 32 30 32
  81++836F 31 20 41 6C
  81++8373 65 78 61 6E
  81++8377 64 65 72 20
  81++837B 4E 69 68 69
  81++837F 72 61 73 68
  81++8383 0D 00
  82++8385                  ENDIF
# file closed: gopher/render/ui.asm
   7+ 8385                  include "gopher-page.asm"
# file opened: gopher/render/gopher-page.asm
   1++8385              renderGopherScreen:
   2++8385 CD 1A 82         call Render.prepareScreen
   3++8388
   4++8388              	;поиск и печать первой нужной строки
   5++8388 3A 36 8B         ld a, (page_offset)
   5++838B 47             ld b, a
   5++838C CD EF 81       call findLine ;поиск с начала буфера
   6++838F 7C               ld a, h
   6++8390 B5             or l
   6++8391 28 1F          jr z, .exit2
   7++8393 AF               xor a
   7++8394 E5             push hl
   7++8395 CD F1 80       call renderRow
   7++8398 E1             pop hl ;печать строки 0
   8++8399              	;теперь поиск продолжается
   9++8399
  10++8399 06 12            ld b, PER_PAGE-1 ;одну строку уже обработали
  11++839B              .loop
  12++839B C5               push bc
  13++839C 3E 13            ld a, PER_PAGE
  13++839E 90             sub b
  14++839F 5F               ld e, a
  14++83A0 06 01          ld b, 1
  14++83A2 CD F2 81       call findLine2 ;поиск одной следующей
  15++83A5 7C               ld a, h
  15++83A6 B5             or l
  15++83A7 28 06          jr z, .exit
  16++83A9 7B               ld a, e
  16++83AA E5             push hl
  16++83AB CD F1 80       call renderRow
  16++83AE E1             pop hl ;указатель hl надо сохранить
  17++83AF              .exit
  18++83AF C1               pop bc
  19++83B0 10 E9            djnz .loop
  20++83B2              .exit2
  21++83B2 CD 8C 84         call showCursor
  22++83B5 C9               ret
  23++83B6
  24++83B6              checkBorder:
  25++83B6 3A 37 8B         ld a, (cursor_position)
  25++83B9 FE FF          cp #ff
  25++83BB CA B0 84       jp z, pageUp
  26++83BE 3A 37 8B         ld a, (cursor_position)
  26++83C1 FE 13          cp PER_PAGE
  26++83C3 CA D3 84       jp z, pageDn
  27++83C6 CD 8C 84         call showCursor
  28++83C9 C3 CC 83         jp workLoop
  29++83CC
  30++83CC              workLoop:
  31++83CC 3A 81 85         ld a, (play_next)
  31++83CF A7             and a
  31++83D0 C2 45 84       jp nz, navigate
  32++83D3
  33++83D3                  ; dup 4
  34++83D3                  ; halt
  35++83D3                  ; edup
  36++83D3              .nothing
  37++83D3              	OS_WAIT
  37++83D3 DF          >	rst #18
  38++83D4 CD 4B A2     	call printRTC
  39++83D7 CD B2 86         call Console.peekC
  40++83DA FE FF            cp 255
  40++83DC 28 F5          jr z, .nothing
  41++83DE
  42++83DE FE 0A            cp Console.KEY_DN
  42++83E0 CA 9C 84       jp z, cursorDown
  43++83E3 FE 61            cp 'a'
  43++83E5 CA 9C 84       jp z, cursorDown
  44++83E8 FE 0B            cp Console.KEY_UP
  44++83EA CA A6 84       jp z, cursorUp
  45++83ED FE 71            cp 'q'
  45++83EF CA A6 84       jp z, cursorUp
  46++83F2 FE 08            cp Console.KEY_LT
  46++83F4 CA B0 84       jp z, pageUp
  47++83F7 FE 6F            cp 'o'
  47++83F9 CA B0 84       jp z, pageUp
  48++83FC FE 09            cp Console.KEY_RT
  48++83FE CA D3 84       jp z, pageDn
  49++8401 FE 70            cp 'p'
  49++8403 CA D3 84       jp z, pageDn
  50++8406
  51++8406 FE 68            cp 'h'
  51++8408 CA 1F 87       jp z, History.home
  52++840B FE 48            cp 'H'
  52++840D CA 1F 87       jp z, History.home
  53++8410
  54++8410 FE 62            cp 'b'
  54++8412 CA B6 86       jp z, History.back
  55++8415 FE 42            cp 'B'
  55++8417 CA B6 86       jp z, History.back
  56++841A FE 0C            cp Console.BACKSPACE
  56++841C CA B6 86       jp z, History.back
  57++841F
  58++841F FE 64            cp 'd'
  58++8421 CA 8D 82       jp z, inputHost
  59++8424 FE 44            cp 'D'
  59++8426 CA 8D 82       jp z, inputHost
  60++8429
  61++8429 FE 0D            cp CR
  61++842B CA 45 84       jp z, navigate
  62++842E
  63++842E                  ifdef GS
  64++842E FE 4D            cp 'M'
  64++8430 CC 4F A3       call z, GeneralSound.toggleModule
  65++8433 FE 6D            cp 'm'
  65++8435 CC 4F A3       call z, GeneralSound.toggleModule
  66++8438                  endif
  67++8438
  68++8438 FE 53        	cp 'S'
  68++843A CC E2 81       call z, toggleSaveMode
  69++843D FE 73        	cp 's'
  69++843F CC E2 81       call z, toggleSaveMode
  70++8442
  71++8442 C3 CC 83         jp workLoop
  72++8445
  73++8445              navigate:
  74++8445 CD A0 86         call Console.waitForKeyUp
  75++8448 AF               xor a
  75++8449 32 81 85       ld (play_next), a
  76++844C
  77++844C CD 94 84         call hideCursor
  78++844F 3A 36 8B 47      ld a, (page_offset), b, a, a, (cursor_position)
  78++8453 3A 37 8B
  78++8456 80             add b
  78++8457 47             ld b, a
  78++8458 CD EF 81       call Render.findLine
  79++845B 7E               ld a, (hl)
  80++845C FE 31            cp '1'
  80++845E CA 76 84       jp z, .load
  81++8461 FE 30            cp '0'
  81++8463 CA 76 84       jp z, .load
  82++8466 FE 39            cp '9'
  82++8468 CA 76 84       jp z, .load
  83++846B FE 37            cp '7'
  83++846D CA 7E 84       jp z, .input
  84++8470 CD 8C 84         call showCursor
  85++8473 C3 CC 83         jp workLoop
  86++8476              .load
  87++8476 E5               push hl
  88++8477 CD 06 81         call getIcon
  89++847A E1               pop hl
  90++847B C3 22 87         jp History.navigate
  91++847E              .input
  92++847E E5               push hl
  93++847F CD 82 85         call DialogBox.inputBox
  94++8482 E1               pop hl
  95++8483 3A D7 85         ld a, (DialogBox.inputBuffer)
  95++8486 A7             and a
  95++8487 CA CD 86       jp z, History.load
  96++848A 18 EA            jr .load
  97++848C
  98++848C              showCursor:
  99++848C 3A 37 8B         ld a, (cursor_position)
  99++848F C6 03          add CURSOR_OFFSET
 100++8491 C3 16 80         jp TextMode.highlightLine
 101++8494
 102++8494              hideCursor:
 103++8494 3A 37 8B         ld a, (cursor_position)
 103++8497 C6 03          add CURSOR_OFFSET
 104++8499 C3 10 80         jp TextMode.usualLine
 105++849C
 106++849C              cursorDown:
 107++849C CD 94 84         call hideCursor
 108++849F 21 37 8B         ld hl, cursor_position
 109++84A2 34               inc (hl)
 110++84A3 C3 B6 83         jp checkBorder
 111++84A6
 112++84A6              cursorUp:
 113++84A6 CD 94 84         call hideCursor
 114++84A9 21 37 8B         ld hl, cursor_position
 115++84AC 35               dec (hl)
 116++84AD C3 B6 83         jp checkBorder
 117++84B0
 118++84B0              pageUp:
 119++84B0 3A 36 8B         ld a, (page_offset)
 119++84B3 A7             and a
 119++84B4 28 13          jr z, .skip
 120++84B6 3E 12            ld a, PER_PAGE - 1
 120++84B8 32 37 8B       ld (cursor_position), a
 121++84BB 3A 36 8B         ld a, (page_offset)
 121++84BE D6 13          sub PER_PAGE
 121++84C0 32 36 8B       ld (page_offset), a
 122++84C3              .exit
 123++84C3 CD 85 83         call renderGopherScreen
 124++84C6 C3 CC 83         jp workLoop
 125++84C9              .skip
 126++84C9 AF               xor a
 126++84CA 32 37 8B       ld (cursor_position), a
 126++84CD CD 85 83       call renderGopherScreen
 126++84D0 C3 CC 83       jp workLoop
 127++84D3
 128++84D3              pageDn:
 129++84D3 AF               xor a
 129++84D4 32 37 8B       ld (cursor_position), a
 130++84D7 3A 36 8B         ld a, (page_offset)
 130++84DA C6 13          add PER_PAGE
 130++84DC 32 36 8B       ld (page_offset), a
 131++84DF 18 E2            jr pageUp.exit
# file closed: gopher/render/gopher-page.asm
   8+ 84E1                  include "plaintext.asm"
# file opened: gopher/render/plaintext.asm
   1++84E1              renderPlainTextScreen:
   2++84E1 CD 1A 82         call prepareScreen
   3++84E4
   4++84E4              	;поиск и печать первой нужной строки
   5++84E4 3A 36 8B         ld a, (page_offset)
   5++84E7 47             ld b, a
   5++84E8 CD EF 81       call findLine ;поиск с начала буфера
   6++84EB 7C               ld a, h
   6++84EC B5             or l
   6++84ED 28 2D          jr z, .exit2
   7++84EF AF               xor a
   8++84F0 C6 03            add CURSOR_OFFSET
   8++84F2 57 1E 01       ld d, a, e, 1
   8++84F5 CD 07 80       call TextMode.gotoXY
   9++84F8 CD C0 80         call print70Text
  10++84FB              	;теперь поиск продолжается
  11++84FB
  12++84FB 06 12            ld b, PER_PAGE-1
  13++84FD              .loop
  14++84FD C5               push bc
  15++84FE 3E 13            ld a, PER_PAGE
  15++8500 90             sub b
  16++8501 5F               ld e, a
  16++8502 06 01          ld b, 1
  16++8504 CD F2 81       call Render.findLine2
  17++8507 7C               ld a, h
  17++8508 B5             or l
  17++8509 28 10          jr z, .exit
  18++850B 7B               ld a, e
  19++850C C6 03            add CURSOR_OFFSET
  19++850E 57 1E 01       ld d, a, e, 1
  19++8511 CD 07 80       call TextMode.gotoXY
  20++8514 CD C0 80         call print70Text
  21++8517 C1               pop bc
  22++8518 10 E3            djnz .loop
  23++851A C9               ret
  24++851B              .exit
  25++851B C1               pop bc
  26++851C              .exit2
  27++851C C9               ret
  28++851D
  29++851D              plainTextLoop:
  30++851D CD A9 86         call Console.getC
  31++8520
  32++8520 FE 0A            cp Console.KEY_DN
  32++8522 CA 63 85       jp z, textDown
  33++8525 FE 61            cp 'a'
  33++8527 CA 63 85       jp z, textDown
  34++852A
  35++852A FE 0B            cp Console.KEY_UP
  35++852C CA 71 85       jp z, textUp
  36++852F FE 71            cp 'q'
  36++8531 CA 71 85       jp z, textUp
  37++8534
  38++8534 FE 68            cp 'h'
  38++8536 CA 1F 87       jp z, History.home
  39++8539 FE 48            cp 'H'
  39++853B CA 1F 87       jp z, History.home
  40++853E
  41++853E FE 62            cp 'b'
  41++8540 CA B6 86       jp z, History.back
  42++8543 FE 42            cp 'B'
  42++8545 CA B6 86       jp z, History.back
  43++8548
  44++8548 FE 0C            cp Console.BACKSPACE
  44++854A CA B6 86       jp z, History.back
  45++854D
  46++854D                  ifdef GS
  47++854D FE 4D            cp 'M'
  47++854F CC 4F A3       call z, GeneralSound.toggleModule
  48++8552 FE 6D            cp 'm'
  48++8554 CC 4F A3       call z, GeneralSound.toggleModule
  49++8557                  endif
  50++8557
  51++8557 FE 53            cp 'S'
  51++8559 CC E2 81       call z, toggleSaveMode
  52++855C FE 73        	cp 's'
  52++855E CC E2 81       call z, toggleSaveMode
  53++8561
  54++8561 18 BA            jr plainTextLoop
  55++8563
  56++8563
  57++8563              textDown:
  58++8563 3A 36 8B         ld a, (page_offset)
  58++8566 C6 13          add PER_PAGE
  58++8568 32 36 8B       ld (page_offset), a
  59++856B CD E1 84         call renderPlainTextScreen
  60++856E C3 1D 85         jp plainTextLoop
  61++8571
  62++8571              textUp:
  63++8571 21 36 8B         ld hl, page_offset
  64++8574 7E               ld a, (hl)
  64++8575 A7             and a
  64++8576 28 A5          jr z, plainTextLoop
  65++8578 D6 13            sub PER_PAGE
  65++857A 77             ld (hl), a
  66++857B CD E1 84         call renderPlainTextScreen
  67++857E C3 1D 85         jp plainTextLoop
# file closed: gopher/render/plaintext.asm
   9+ 8581
  10+ 8581 00           play_next       db  0
  11+ 8582              position        EQU historyBlock.position
  12+ 8582              cursor_position EQU position + 1
  13+ 8582              page_offset     EQU position
  14+ 8582                  ENDMODULE
  15+ 8582
  16+ 8582                  include "dialogbox.asm"
# file opened: gopher/render/dialogbox.asm
   1++8582                  module DialogBox
   2++8582
   3++8582              inputBox:
   4++8582 AF               xor a
   4++8583 32 D7 85       ld (inputBuffer), a
   5++8586              .noclear
   6++8586 CD 38 86         call drawBox
   7++8589              .loop
   8++8589 11 05 0B         ld de, #0B05
   8++858C CD 07 80       call TextMode.gotoXY
   9++858F 21 D7 85         ld hl, inputBuffer
   9++8592 CD 1E 80       call TextMode.printZ
  10++8595 3E 04            ld a, MIME_INPUT
  10++8597 CD 1C 80       call TextMode.putC
  10++859A 3E 20          ld a, ' '
  10++859C CD 1C 80       call TextMode.putC
  11++859F              .checkkey
  12++859F CD A9 86         call Console.getC
  13++85A2 FE 0C            cp Console.BACKSPACE
  13++85A4 28 16          jr z, .removeChar
  14++85A6 FE 0D            cp CR
  14++85A8 C8             ret z
  15++85A9 FE 20            cp SPACE
  15++85AB 38 F2          jr c, .checkkey
  16++85AD              .putC
  17++85AD 5F               ld e, a
  18++85AE AF               xor a
  18++85AF 21 D7 85 01    ld hl, inputBuffer, bc, #ff
  18++85B3 FF 00
  18++85B5 ED B1          cpir
  19++85B7 77               ld (hl), a
  19++85B8 2B             dec hl
  19++85B9 73             ld (hl), e
  20++85BA 18 CD            jr .loop
  21++85BC              .removeChar
  22++85BC AF               xor a
  23++85BD 21 D7 85 01      ld hl, inputBuffer, bc, #ff
  23++85C1 FF 00
  23++85C3 ED B1          cpir
  24++85C5 E5               push hl
  25++85C6 11 D8 85             ld de, inputBuffer + 1
  26++85C9 B7                   or a
  26++85CA ED 52          sbc hl, de
  27++85CC 7C                   ld a, h
  27++85CD B5             or l
  28++85CE E1               pop hl
  29++85CF 28 B8            jr z, .loop
  30++85D1 AF               xor a
  31++85D2 2B               dec hl
  31++85D3 2B             dec hl
  31++85D4 77             ld (hl), a
  32++85D5 18 B2            jr .loop
  33++85D7
  34++85D7 00 00 00...  inputBuffer ds 80
  35++8627
  36++8627              msgBox:
  37++8627 CD 30 86         call msgNoWait
  38++862A 06 96            ld b, 150
  39++862C              .loop
  40++862C                  OS_WAIT
  40++862C DF          >	rst #18
  41++862D 10 FD            djnz .loop
  42++862F C9               ret
  43++8630
  44++8630              msgNoWait:
  45++8630 E5               push hl
  46++8631 CD 38 86         call drawBox
  47++8634 E1               pop hl
  48++8635 C3 1E 80         jp TextMode.printZ
  49++8638
  50++8638              drawBox:
  51++8638 26 0A 3E 09      ld h, #0A, a, BORDER_TOP
  51++863C CD 0C 80       call TextMode.fillLine
  52++863F 26 0B 3E 20      ld h, #0B, a, ' '
  52++8643 CD 0C 80       call TextMode.fillLine
  53++8646 26 0C 3E 08      ld h, #0C, a, BORDER_BOTTOM
  53++864A CD 0C 80       call TextMode.fillLine
  54++864D
  55++864D                  IFNDEF TIMEX80
  56++864D 3E 0A            ld a, #0a
  56++864F CD 16 80       call TextMode.highlightLine
  57++8652 3E 0C            ld a, #0c
  57++8654 CD 16 80       call TextMode.highlightLine
  58++8657                  ENDIF
  59++8657
  60++8657 11 05 0B         ld de, #0B05
  60++865A CD 07 80       call TextMode.gotoXY
  61++865D C9               ret
  62++865E                  endmodule
  63++865E
# file closed: gopher/render/dialogbox.asm
# file closed: gopher/render/index.asm
  18  865E                  include "dos/index.asm"
# file opened: dos/index.asm
   1+ 865E                  IFDEF ESX
   2+ 865E ~                include "esxdos.asm"
   3+ 865E              	ENDIF
   4+ 865E                  IFDEF TRD
   5+ 865E ~                include "trdos.asm"
   6+ 865E              	ENDIF
   7+ 865E                  IFDEF ZSFAT
   8+ 865E                  include "zsfat.asm"
# file opened: dos/zsfat.asm
   1++865E              ;trdos driver (izzx)
   2++865E                  MODULE Dos
   3++865E              ; API methods
   4++865E              ESX_GETSETDRV = #89
   5++865E              ESX_FOPEN = #9A
   6++865E              ESX_FCLOSE = #9B
   7++865E              ESX_FSYNC = #9C
   8++865E              ESX_FREAD = #9D
   9++865E              ESX_FWRITE = #9E
  10++865E
  11++865E              ; File modes
  12++865E              FMODE_READ = #01
  13++865E              FMODE_WRITE = #06
  14++865E              FMODE_CREATE = #0E
  15++865E
  16++865E                  ; MACRO esxCall func
  17++865E                  ; rst #8 : db func
  18++865E                  ; ENDM
  19++865E
  20++865E              ;макросы модуля
  21++865E              ;
  22++865E              ;R8DOS			вызов функции R8DOS
  23++865E              ;R8FAT			вызов функции R8FAT
  24++865E              ;R8DOSc			вызов функции R8DOS
  25++865E              ;
  26++865E              ;------------------------------------------------------------------------------
  27++865E              ;вызов функции R8DOS
  28++865E              ;вх: =0 номер функции
  29++865E              ;
  30++865E              	; MACRO	R8DOS nFunc
  31++865E              	; ld	c,nFunc
  32++865E              	; rst	#08
  33++865E              	; db	#81
  34++865E              	; ENDM
  35++865E
  36++865E              ; ;------------------------------------------------------------------------------
  37++865E              ; ;вызов функции R8FAT
  38++865E              ; ;вх: =0 номер функции
  39++865E              ; ;
  40++865E              	; MACRO	R8FAT nFunc
  41++865E              	; ld	c,nFunc
  42++865E              	; rst	#08
  43++865E              	; db	#91
  44++865E              	; ENDM
  45++865E
  46++865E              ; ;------------------------------------------------------------------------------
  47++865E              ; ;вызов функции R8DOS
  48++865E              ; ;вх: c - номер функции
  49++865E              ; ;
  50++865E              	; MACRO	R8DOSc
  51++865E              	; rst	#08
  52++865E              	; db	#81
  53++865E              	; ENDM
  54++865E
  55++865E              ; ;------------------------------------------------------------------------------
  56++865E              ; ;вызов функции #02 (FileMan) R8CONF
  57++865E              ; ;вх: =#00 - номер функции файл менеджера
  58++865E              ; ;
  59++865E              	; MACRO	R8C02FM nFunct
  60++865E              	; ld	bc,#100*nFunct+#02
  61++865E              	; rst	#08
  62++865E              	; db	#8E
  63++865E              	; ENDM
  64++865E
  65++865E              ;==============================================================================
  66++865E              ; r8f00_DeinitFAT		equ #00
  67++865E              ; r8f01_InitFAT		equ #01
  68++865E              ; r8f04_FindPath		equ #04
  69++865E              ; r8f07_FileOpen		equ #07 ;открыть файл для последующих операций с ним
  70++865E              ; r8f09_FileWrite		equ #09	;запись данных из памяти в файл
  71++865E              ; r8f0E_CreateFileLFN	equ #0E ;создание файла с длинным именем в текущем каталоге
  72++865E              ; r8f0F_CreateFileSFN	equ #0F
  73++865E
  74++865E              ; r8d2D_FindPart		equ #2D
  75++865E              ; r8d2E_CngHDD		equ #2E
  76++865E
  77++865E
  78++865E              ;id = 0 файл не открыт
  79++865E              ;id = 1 файл для чтения trdos
  80++865E              ;id = 2 файл для записи trdos
  81++865E              ;id = 3 файл для записи тип TRD trdos
  82++865E              ;id = 4 файл для записи тип SCL trdos
  83++865E              ;id = 5 файл для чтения fat32 (пока не сделано)
  84++865E              ;id = 6 файл для записи fat32
  85++865E
  86++865E              ; HL - filename in ASCIIZ
  87++865E              loadBuffer:
  88++865E 06 01            ld b, Dos.FMODE_READ
  88++8660 CD 7A 86       call Dos.fopen
  89++8663 F5               push af
  90++8664 21 5B A3 01          ld hl, outputBuffer, bc, #ffff - outputBuffer
  90++8668 A4 5C
  90++866A CD 93 86       call Dos.fread
  91++866D 21 5B A3             ld hl, outputBuffer
  91++8670 09             add hl, bc
  91++8671 AF             xor a
  91++8672 77             ld (hl), a
  91++8673 23             inc hl
  91++8674 77             ld (hl), a
  92++8675 F1               pop af
  93++8676 CD 8F 86         call Dos.fclose
  94++8679 C9               ret
  95++867A
  96++867A
  97++867A              ; Returns:
  98++867A              ;  A - current drive
  99++867A              ; getDefaultDrive: ;нигде не используется
 100++867A                  ; ld a, 0 : esxCall ESX_GETSETDRV
 101++867A                  ; ret
 102++867A
 103++867A
 104++867A
 105++867A              ; Opens file on default drive
 106++867A              ; B - File mode
 107++867A              ; HL - File name
 108++867A              ; Returns:
 109++867A              ;  A - file stream id
 110++867A              fopen:
 111++867A                  ; push bc : push hl
 112++867A                  ; call getDefaultDrive
 113++867A                  ; pop ix : pop bc
 114++867A                  ; esxCall ESX_FOPEN
 115++867A                  ; ret
 116++867A 78           	ld a,b
 117++867B FE 01        	cp FMODE_READ ;если режим открытие файла
 118++867D 28 06        	jr z,fopen_r
 119++867F FE 0E        	cp FMODE_CREATE
 120++8681 28 08        	jr z,fopen_c ;если режим создание файла
 121++8683 18 04        	jr fopen_err ;иначе выход
 122++8685
 123++8685              fopen_r	;открытие существующего файла на чтение (id=1)
 124++8685
 125++8685              	;call format_name ;
 126++8685
 127++8685              	OS_FILE_OPEN
 127++8685 0E 21       >    ld c,#21
 127++8687 E7          >    rst #20
 128++8688 C9           	ret
 129++8689              	; ld a,(#5D19) ;номер дисковода по умолчанию
 130++8689              	; ld 	(prev_drive),a ;запомним
 131++8689              			;call format_name ;
 132++8689              			; ld      c,#13 ;move file info to syst var
 133++8689                          ; call    call3d13
 134++8689                          ; ld      c,#0a ;find file
 135++8689                          ; call    call3d13
 136++8689                          ; ld      a,c
 137++8689              			; cp 		#ff
 138++8689              			; jr 		z,fopen_err ;если не нашли файла
 139++8689                          ; ld      c,#08 ;read file title
 140++8689                          ; call    call3d13
 141++8689                          ; ;ld      hl,loadadr ;куда
 142++8689                          ; ld      de,(#5ceb) ;начало файла сектор дорожка
 143++8689                          ; ld      (f_r_cur_trk),de
 144++8689
 145++8689                          ; ld      a,(#5cea)
 146++8689                          ; ld      (f_r_len_sec),a ;длина в секторах
 147++8689                          ; ;or      a
 148++8689                          ; ;ret     z    ;выход если пустой
 149++8689
 150++8689              			; ld de,(#5CE8) ; длина файла или программной части для BASIC
 151++8689              			; ld      (f_r_len),de
 152++8689
 153++8689                          ; ; ld      de,(fcurtrk) ;текущие сектор дорожка
 154++8689                          ; ; ld      (#5cf4),de ;восстановим
 155++8689              			; xor a
 156++8689              			; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 157++8689              			; ld 		a,1
 158++8689              			; ld (f_r_flag),a ;флаг что файл для чтения открыт
 159++8689              			; ;id канала будет 1
 160++8689              	;ret
 161++8689
 162++8689              fopen_err
 163++8689              	; ld a,1
 164++8689              	; ld (com_file_err_flag),a
 165++8689              	; xor a ;если никакой файл не открыли, то id = 0
 166++8689 37           	scf ;флаг ошибки
 167++868A C9           	ret
 168++868B
 169++868B
 170++868B              fopen_c	;создание нового файла (id=2-4,6)
 171++868B              	; ld a,(#5D19) ;номер дисковода по умолчанию
 172++868B              	; ld 	(prev_drive),a ;запомним
 173++868B
 174++868B              	;call format_name ;
 175++868B
 176++868B              	OS_FILE_CREATE
 176++868B 0E 22       >    ld c,#22
 176++868D E7          >    rst #20
 177++868E C9           	ret
 178++868F
 179++868F              	; call select_drive
 180++868F              	; cp "y"
 181++868F              	; jr nz,fopen_err
 182++868F
 183++868F              	; ld a,(curr_drive)
 184++868F              	; cp 4
 185++868F              	; jp nc,fopen_c_fat ;если выбран FAT
 186++868F
 187++868F              	; ;выясним, не образ ли это для разворачивания
 188++868F                  ; ld hl, trdExt1 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 189++868F                  ; ld hl, trdExt2 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 190++868F              	; ld hl, sclExt1 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 191++868F                  ; ld hl, sclExt2 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 192++868F
 193++868F
 194++868F              	; ;создание произвольного файла (id=2)
 195++868F              	; call cat_buf_cls
 196++868F
 197++868F              	; ld hl,cat_buf ;считаем каталог диска
 198++868F              	; ld de,0
 199++868F                  ; ld      bc,#0905 ;
 200++868F                  ; call    call3d13
 201++868F
 202++868F              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 203++868F              	; cp 128
 204++868F              	; jp c,fopen_c2 ;если уже максимум
 205++868F                  ; ld hl, file_err
 206++868F                  ; call DialogBox.msgBox ;предуреждение
 207++868F              	; jr fopen_err
 208++868F
 209++868F              ; fopen_c2
 210++868F              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 211++868F              	; ld a,h
 212++868F              	; or l
 213++868F              	; jr nz,fopen_c3 ;если ещё есть место
 214++868F                  ; ld hl, file_err
 215++868F                  ; call DialogBox.msgBox ;предуреждение
 216++868F              	; jr fopen_err
 217++868F
 218++868F              ; fopen_c3
 219++868F              	; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 220++868F                  ; ld   (#5cf4),de ;отсюда будем писать файл
 221++868F
 222++868F              	; xor a
 223++868F              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 224++868F              	; ld (sec_shift),a ;переменная
 225++868F              	; ld hl,0
 226++868F              	; ld (f_w_len+0),hl
 227++868F              	; ld (f_w_len+2),hl
 228++868F              	; ld a,2 ;id канала
 229++868F              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 230++868F              	; ret
 231++868F
 232++868F
 233++868F              ; cat_buf_cls ;очистка буфера каталога
 234++868F              	; ld hl,cat_buf ;очистить место для каталога дискеты
 235++868F              	; ld de,cat_buf+1
 236++868F              	; ld (hl),0
 237++868F              	; ld bc,9*256-1
 238++868F              	; ldir
 239++868F              	; ret
 240++868F
 241++868F
 242++868F
 243++868F              ; fopen_c_trd	;открытие файла для разворачивания образа trd (id=3)
 244++868F              	; call select_drive
 245++868F              	; cp "y"
 246++868F              	; jp nz,fopen_err
 247++868F
 248++868F              	; ld      de,0 ;начало сектор дорожка
 249++868F                  ; ld      (#5cf4),de
 250++868F
 251++868F              	; xor a
 252++868F              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 253++868F              	; ld (sec_shift),a ;переменная
 254++868F              	; ld hl,0
 255++868F              	; ld (f_w_len+0),hl
 256++868F              	; ld (f_w_len+2),hl
 257++868F              	; ld a,3 ;id канала
 258++868F              	; ld (f_w_flag),a ;флаг что trd для записи открыт
 259++868F              	; ret
 260++868F
 261++868F
 262++868F
 263++868F              ; fopen_c_scl	;открытие файла для разворачивания образа scl (id=4)
 264++868F              	; call select_drive
 265++868F              	; cp "y"
 266++868F              	; jp nz,fopen_err
 267++868F
 268++868F              	; ld      de,0 ;начало сектор дорожка
 269++868F                  ; ld      (#5cf4),de
 270++868F
 271++868F              	; call cat_buf_cls ;почистить место
 272++868F
 273++868F              	; call scl_parse ;запуск цикла сборки образа
 274++868F
 275++868F              	; xor a
 276++868F              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 277++868F              	; ld (sec_shift),a ;переменная
 278++868F              	; ;ld (scl_que),a
 279++868F              	; ld hl,0
 280++868F              	; ld (f_w_len+0),hl
 281++868F              	; ld (f_w_len+2),hl
 282++868F              	; ld a,4 ;id канала
 283++868F              	; ld (f_w_flag),a ;флаг что scl для записи открыт
 284++868F              	; ret
 285++868F
 286++868F
 287++868F
 288++868F
 289++868F              ; fopen_c_fat	;создание файла FAT (id=6)
 290++868F
 291++868F              ; ;переинициализация FAT раздела
 292++868F              	; R8FAT	r8f00_DeinitFAT
 293++868F              	; jp 		c,fopen_err
 294++868F
 295++868F              	; ld a,(curr_drive)
 296++868F              	; ld bc,typeDrive-4
 297++868F              	; ld l,a
 298++868F              	; ld h,0
 299++868F              	; add hl,bc
 300++868F              	; ld a,(hl) ;получили код раздела из списка
 301++868F              	; rlca
 302++868F              	; rlca
 303++868F              	; rlca
 304++868F              	; rlca
 305++868F              	; and %11110000
 306++868F                  ; ;         ld      a,%0000????
 307++868F                                     ; ; ││└┴─── номер раздела
 308++868F                                     ; ; │└───── master/slave для Hdd
 309++868F                                     ; ; └────── SD/Hdd
 310++868F              	; R8FAT	r8f01_InitFAT
 311++868F                  ; jp      c,fopen_err
 312++868F
 313++868F              ; ;поиск пути в разделе
 314++868F              	; ld	hl,ActPathFAT		;путь к каталогу Download
 315++868F              	; ld	de,fcb
 316++868F              	; xor	a
 317++868F              	; dec	a
 318++868F              	; R8FAT	r8f04_FindPath
 319++868F                  ; ;jp      c,fopen_err ;если не нашли, файл будет в корне
 320++868F
 321++868F              	; ld	hl,(temp_hl)		;строка с именем
 322++868F              	; ld	de,fcb
 323++868F              	; R8FAT r8f07_FileOpen
 324++868F              	; jp 	nc,fopen_c_fat2 ;если файл есть, откроем
 325++868F
 326++868F              ; ;создание файла, если нет
 327++868F              	; ld	hl,(temp_hl)		;строка с именем
 328++868F              	; xor	a
 329++868F              	; ld	(fcb+#14+0),a
 330++868F              	; ld	(fcb+#14+1),a
 331++868F              	; ld	(fcb+#14+2),a	;установим размер
 332++868F              	; ld	(fcb+#14+3),a
 333++868F              	; ld	de,fcb
 334++868F              	; R8FAT	r8f0E_CreateFileLFN	;создание файла
 335++868F              	; jp 	c,fopen_err
 336++868F
 337++868F              ; fopen_c_fat2
 338++868F
 339++868F              	; ld hl,0
 340++868F              	; ld (f_w_len+0),hl
 341++868F              	; ld (f_w_len+2),hl
 342++868F              	; xor a
 343++868F              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 344++868F              	; ld a,6 ;id канала
 345++868F              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 346++868F              	; ret
 347++868F
 348++868F
 349++868F
 350++868F
 351++868F
 352++868F              ; select_drive	;запрос номера дисковода
 353++868F              	; ld a,(hdd_init_flag) ;если в первый раз
 354++868F              	; or a
 355++868F              	; jr nz,select_drive2
 356++868F              	; ld a,(#5D19) ;номер дисковода по умолчанию
 357++868F              	; ld (curr_drive),a
 358++868F              	; call GetNumPart ;узнаем какая буква последняя, сколько разделов ФАТ
 359++868F              	; add "D"
 360++868F              	; ld (write_ima_e),a	;выбор до этой буквы
 361++868F              	; sub "D"
 362++868F              	; inc a
 363++868F              	; add "d"
 364++868F              	; ld (next_lett),a ;эта буква первая свободная
 365++868F              	; ld a,1
 366++868F              	; ld (hdd_init_flag),a
 367++868F              ; select_drive2
 368++868F              	; ld a,(curr_drive) ;номер дисковода по умолчанию
 369++868F              	; add a,"A"
 370++868F              	; ld (write_ima_d),a ;подставим букву в запросе
 371++868F                  ; ld hl, write_ima
 372++868F                  ; call DialogBox.msgNoWait ;текст запроса
 373++868F              ; select_drive_wait
 374++868F              	; ;halt
 375++868F              	; call Console.getC
 376++868F              	; cp 255
 377++868F              	; JR Z,select_drive_wait	;ждём любую клавишу
 378++868F              	; cp "y"
 379++868F              	; jr z,select_drive_ex
 380++868F              	; cp "n"
 381++868F              	; ret z
 382++868F              	; cp "a" ;от буквы A
 383++868F              	; jr c,select_drive_wait
 384++868F              	; ld hl,next_lett
 385++868F              	; cp (hl) ;до первой свободной буквы
 386++868F              	; jr nc,select_drive_wait
 387++868F              	; sub "a"
 388++868F              	; ld (curr_drive),a ;новый номер диска
 389++868F              	; jr select_drive2 ;обновить строку
 390++868F              ; select_drive_ex ;выход
 391++868F              	; ld a,(curr_drive)
 392++868F              	; cp 4 ;начиная с буквы E идёт HDD
 393++868F              	; jr nc,select_drive3
 394++868F                  ; ld      (#5d19) ,a ;если дискета, настроим trdos
 395++868F                  ; ld      c,1
 396++868F                  ; call    call3d13
 397++868F                  ; ld      c,#18
 398++868F                  ; call    call3d13
 399++868F              ; select_drive3
 400++868F              	; ld a,"y"
 401++868F              	; ret
 402++868F
 403++868F
 404++868F              ; ; restore_drive ;восстановить дисковод по умолчанию
 405++868F              	; ; ld 	a,(prev_drive)
 406++868F                  ; ; ld      (#5d19) ,a
 407++868F                  ; ; ld      c,1
 408++868F                  ; ; call    call3d13
 409++868F                  ; ; ld      c,#18
 410++868F                  ; ; call    call3d13
 411++868F              	; ; ret
 412++868F
 413++868F
 414++868F              ; call3d13 ;фикс для GMX
 415++868F              	; ifndef ZSGMX
 416++868F                  ; jp    #3d13
 417++868F              	; endif
 418++868F
 419++868F              	; ; ifdef ZSGMX
 420++868F                  ; ; call    #3d13
 421++868F              	; ; exx
 422++868F              	; ; call TextMode.gmxscron
 423++868F              	; ; exx
 424++868F              	; ; endif
 425++868F              	; ret
 426++868F
 427++868F
 428++868F
 429++868F              ; A - file stream id
 430++868F              fclose:
 431++868F              	OS_FILE_CLOSE
 431++868F 0E 25       >    ld c,#25
 431++8691 E7          >    rst #20
 432++8692 C9           	ret
 433++8693
 434++8693                  ; ;esxCall ESX_FCLOSE
 435++8693              	; ; push af
 436++8693              	; ; pop af
 437++8693              	; cp 2 ;если обычный файл
 438++8693              	; jp nz,fclose_scl
 439++8693
 440++8693              	; ;дописать остаток файла
 441++8693              	; ld a,(write_end_flag) ;нужно записывать остаток?
 442++8693              	; or a
 443++8693              	; jr nz,fclose_f ;не нужно
 444++8693
 445++8693              	; ld hl,sec_buf
 446++8693              	; ld bc,#0106
 447++8693              	; ld de,(#5cf4)
 448++8693              	; call call3d13
 449++8693
 450++8693              	; ld a,"0" ;номер части файла
 451++8693              	; ld (file_num),a
 452++8693
 453++8693              ; fclose_f ;поправить каталог
 454++8693              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 455++8693              	; ld hl,(f_w_len+0)
 456++8693              	; or h
 457++8693              	; or l
 458++8693              	; jp z,fclose_ex ;выход если длина 0
 459++8693
 460++8693              	; ;проверки на заполнение
 461++8693              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 462++8693              	; cp 128
 463++8693              	; jp nc,fclose_ex ;если уже максимум
 464++8693              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 465++8693              	; ld a,h
 466++8693              	; or l
 467++8693              	; jp z,fclose_ex ;если места нет
 468++8693
 469++8693              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 470++8693              	; or a
 471++8693              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 472++8693              	; ld a,(f_w_len+1)
 473++8693              	; cp 255
 474++8693              	; jr nz,fclose_f1
 475++8693              	; ld a,(f_w_len+0)
 476++8693              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 477++8693              ; fclose_f1
 478++8693              	; ;файл не превышает максимальный размер для trdos
 479++8693              	; ld de,(f_w_len+0)
 480++8693              	; ld hl,f_name+11 ;длина файла
 481++8693              	; ld (hl),e
 482++8693              	; inc hl
 483++8693              	; ld (hl),d
 484++8693              	; inc hl
 485++8693              	; ld a,(f_w_len+1) ;длина секторов
 486++8693              	; ld (hl),a
 487++8693              	; ld a,(f_w_len+0) ;длина младший
 488++8693              	; or a
 489++8693              	; jr z,fclose_f2
 490++8693              	; inc (hl) ;коррекция секторов
 491++8693              ; fclose_f2
 492++8693              	; call fclose_f_one ;записать информацию
 493++8693              	; jp fclose_ex ;готово
 494++8693
 495++8693              ; fclose_f_multi ;файл большой, будет несколько записей в каталоге
 496++8693              	; ld a,(file_num)
 497++8693              	; ld (f_name+7),a ;в конце имени номер
 498++8693
 499++8693              	; ld hl,f_name+11 ;длина файла
 500++8693              	; ld (hl),0
 501++8693              	; inc hl
 502++8693              	; ld (hl),#ff ;65280
 503++8693              	; inc hl
 504++8693              	; ;длина секторов
 505++8693              	; ld (hl),#ff
 506++8693              	; call fclose_f_one ;записать информацию
 507++8693
 508++8693              	; ;вычесть длину записанного
 509++8693              	; ld hl,(f_w_len+1) ;старший и средний байт
 510++8693              	; ld bc,255
 511++8693              	; and a
 512++8693              	; sbc hl,bc ;вычесть 255 секторов
 513++8693              	; ld (f_w_len+1),hl
 514++8693
 515++8693              	; ld a,(file_num)
 516++8693              	; inc a
 517++8693              	; ld (file_num),a
 518++8693              	; ld (f_name+7),a ;в конце имени номер
 519++8693
 520++8693              	; jr fclose_f ;сначала
 521++8693
 522++8693
 523++8693              ; fclose_f_one ;запись об одном файле
 524++8693              			; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 525++8693              			; ld l,a ;узнать в каком секторе будет запись о файле
 526++8693              			; ld h,0
 527++8693              			; add hl,hl ;*2
 528++8693              			; add hl,hl ;*4
 529++8693              			; add hl,hl ;*8
 530++8693              			; add hl,hl ;*16
 531++8693              			; ld a,h ;запомнить номер сетора в каталоге
 532++8693              			; ld (sec_cat),a
 533++8693              			; ld bc,cat_buf
 534++8693              			; add hl,bc ;здесь будет запись о новом файле
 535++8693              			; ex de,hl
 536++8693
 537++8693              			; ld hl,f_name ;запись о файле
 538++8693              			; ld bc,16
 539++8693              			; ldir ;скопировать
 540++8693              			; ex de,hl
 541++8693              			; dec hl
 542++8693              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка назначения
 543++8693              			; ld (hl),d ;дорожка
 544++8693              			; dec hl
 545++8693              			; ld (hl),e ;сектор
 546++8693
 547++8693              			; ld l,0 ;записать сектор целиком по ровному адресу
 548++8693              			; ld d,0
 549++8693              			; ld a,(sec_cat)
 550++8693              			; ld e,a ;номер сектора
 551++8693              			; ld bc,#0106 ;1 сектор записать
 552++8693              			; call call3d13
 553++8693
 554++8693              			; ;служебный сектор
 555++8693              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 556++8693              			; ld a,(f_name+13) ;размер файла в секторах
 557++8693              			; ld b,a
 558++8693              			; call calc_next_pos2
 559++8693              			; ld (cat_buf+8*256+#e1),de
 560++8693
 561++8693              			; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 562++8693              			; ld a,(f_name+13) ;размер файла в секторах
 563++8693              			; ld c,a
 564++8693              			; ld b,0
 565++8693              			; and a
 566++8693              			; sbc hl,bc
 567++8693              			; jr nc,fclose_f_one2
 568++8693              			; ld hl,0 ;если было отрицательное
 569++8693              ; fclose_f_one2
 570++8693              			; ld (cat_buf+8*256+#e5),hl
 571++8693
 572++8693              			; ld hl,cat_buf+8*256+#e4 ; общее количество файлов
 573++8693              			; inc (hl)
 574++8693
 575++8693              			; ld hl,cat_buf+8*256
 576++8693              			; ld de,#0008
 577++8693              			; ld bc,#0106 ;1 сектор записать
 578++8693              			; call call3d13
 579++8693              			; ret
 580++8693
 581++8693
 582++8693              ; fclose_scl
 583++8693              	; cp 4 ;если scl
 584++8693              	; jr nz,fclose_ex
 585++8693              	; ld hl,sec_buf ;
 586++8693              	; ld b,1
 587++8693              	; call scl_write_buf ;допишем остаток scl, если есть
 588++8693
 589++8693              ; fclose_ex
 590++8693              	; xor a ;закрываем все файлы
 591++8693              	; ld (f_r_flag),a
 592++8693              	; ld (f_w_flag),a
 593++8693
 594++8693              	; ld a,(com_file_err_flag) ;была ли ошибка
 595++8693              	; or a
 596++8693              	; ret z
 597++8693              	; ld a,2 ;если была
 598++8693              	; out (254),a ;бордюр красный
 599++8693                  ; ld hl, com_file_err ;общая ошибка
 600++8693                  ; call DialogBox.msgBox ;предуреждение
 601++8693              	; xor a ;
 602++8693              	; out (254),a
 603++8693              	; ;call restore_drive ;вернуть диск, какой был
 604++8693                  ; ret
 605++8693
 606++8693
 607++8693
 608++8693
 609++8693              ; A - file stream id
 610++8693              ; BC - length
 611++8693              ; HL - buffer
 612++8693              ; Returns
 613++8693              ;  BC - length(how much was actually read)
 614++8693              fread: ;(id=1)
 615++8693 59           	ld e,c ;сохранить длину
 616++8694 50           	ld d,b
 617++8695              	OS_FILE_READ
 617++8695 0E 23       >    ld c,#23
 617++8697 E7          >    rst #20
 618++8698 C9           	ret
 619++8699
 620++8699                  ; push hl : pop ix
 621++8699                  ; esxCall ESX_FREAD
 622++8699              	; push af
 623++8699              	; ld a,4
 624++8699              	; out (254),a
 625++8699              	; xor a
 626++8699              	; out (254),a
 627++8699              	; pop af
 628++8699
 629++8699              	; cp 1 ;id = 1?
 630++8699              	; jr nz,fread_no_chek ;выход если номер потока не = 1
 631++8699              	; ld a,(f_r_flag)
 632++8699              	; or a
 633++8699              	; jr nz,fread_chek ;файл уже открыт?
 634++8699              ; fread_no_chek ;выход с ошибкой
 635++8699              	; xor a
 636++8699              	; scf ;флаг ошибки
 637++8699              	; ld bc,0 ;ничего мы не считали
 638++8699              	; ret
 639++8699
 640++8699              ; fread_chek
 641++8699              	; ld bc,(f_r_len_sec-1) ;загружаем файл целиком, не смотря на то, сколько байт было запрошено
 642++8699                  ; ld      c,5 ;read читаем целыми секторами
 643++8699              	; ld de,(f_r_cur_trk)
 644++8699                  ; call    call3d13
 645++8699              	; ld bc,(f_r_len) ;возвратим сколько считали байт (длину файла)
 646++8699              	; xor a ;флаги сбросим
 647++8699                  ; ret
 648++8699
 649++8699              ; A - file stream id
 650++8699              ; BC - length
 651++8699              ; HL - buffer
 652++8699              ; Returns:
 653++8699              ;   BC - actually written bytes
 654++8699              fwrite: ;
 655++8699 59           	ld e,c ;сохранить длину
 656++869A 50           	ld d,b
 657++869B              	OS_FILE_WRITE
 657++869B 0E 24       >    ld c,#24
 657++869D E7          >    rst #20
 658++869E C9           	ret
 659++869F
 660++869F                  ; push hl : pop ix
 661++869F                  ; esxCall ESX_FWRITE
 662++869F
 663++869F              	; push af
 664++869F              	; ld a,2
 665++869F              	; out (254),a
 666++869F
 667++869F              	; xor a
 668++869F              	; out (254),a
 669++869F              	; pop af
 670++869F
 671++869F              	; cp 2 ;id = 2?
 672++869F              	; jr z,fwrite_chek ;проверка id потока
 673++869F              	; cp 3 ;id = 3?
 674++869F              	; jr z,fwrite_chek_trd ;проверка id потока
 675++869F              	; cp 4 ;id = 4?
 676++869F              	; jp z,fwrite_chek_scl ;проверка id потока
 677++869F              	; cp 6 ;id = 6?
 678++869F              	; jp z,fwrite_chek_fat ;проверка id потока
 679++869F
 680++869F
 681++869F              ; fwrite_no_chek ;выход с ошибкой
 682++869F              	; ld a,1
 683++869F              	; ld (com_file_err_flag),a
 684++869F              	; xor a
 685++869F              	; scf ;флаг ошибки
 686++869F              	; ld bc,0 ;ничего мы не записали
 687++869F              	; ret
 688++869F
 689++869F              ; fwrite_chek ;запись произвольного типа файла (id=2)
 690++869F
 691++869F              	; ;не отличается от записи trd, пишется входящий поток на диск, отличия при открытии и закрытии файла
 692++869F
 693++869F
 694++869F
 695++869F
 696++869F
 697++869F              ; fwrite_chek_trd ;запись trd файла (разворачивание образа, id=3)
 698++869F              	; ; ld a,2
 699++869F              	; ; out (254),a
 700++869F
 701++869F              	; ; xor a
 702++869F              	; ; out (254),a
 703++869F              	; ld a,(f_w_flag)
 704++869F              	; or a
 705++869F              	; jr z,fwrite_no_chek ;файл уже открыт?
 706++869F              	; ld (temp_bc),bc ;длина
 707++869F              	; ld (temp_hl),hl ;адрес данных
 708++869F              	; ld a,b
 709++869F              	; or c
 710++869F              	; jr z,fwrite_no_chek ; если длина 0, то выход
 711++869F
 712++869F              	; ;защита от переполнения диска
 713++869F              	; ld de,(#5cf4)
 714++869F              	; ld a,d
 715++869F              	; cp #a0 ;последняя дорожка 160
 716++869F              	; jr nc,fwrite_no_chek
 717++869F
 718++869F              	; xor a
 719++869F              	; ld (sec_part),a ;обнулить переменные
 720++869F              	; ld (sec_shift2),a
 721++869F              	; ld (sec_shift2+1),a
 722++869F              	; ld (sec_shift_flag),a
 723++869F              	; ld (write_end_flag),a ;
 724++869F
 725++869F
 726++869F              	; ld a,(sec_shift)
 727++869F              	; or a
 728++869F              	; jr z,fwrite_trd3 ;если смещения нет, то первую часть пропустим
 729++869F
 730++869F
 731++869F              	; ld c,a
 732++869F              	; ld b,0
 733++869F              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 734++869F              	; add hl,bc
 735++869F
 736++869F              	; ld a,1
 737++869F              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 738++869F
 739++869F              	; ld a,h
 740++869F              	; or a
 741++869F              	; jr nz,fwrite_trd4
 742++869F              	; ld a,1
 743++869F              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 744++869F
 745++869F              ; fwrite_trd4
 746++869F              	; ld hl,sec_buf ;буфер последнего сектора
 747++869F              	; add hl,bc ;на этой точке остановились
 748++869F              	; ex de,hl
 749++869F              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 750++869F              	; ; ld a,c
 751++869F              	; ; or a
 752++869F              	; ; jr nz,fwrite_trd2
 753++869F              	; ; inc b ;коррекция
 754++869F              ; ; fwrite_trd2
 755++869F              	; ; ld c,a
 756++869F              	; xor a
 757++869F              	; sub c
 758++869F              	; ld c,a ;сколько осталось перенести до заполнения сектора
 759++869F              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 760++869F              	; ldir
 761++869F
 762++869F              	; ld a,(sec_shift_flag)
 763++869F              	; or a
 764++869F              	; jr nz,fwrite_trd3 ;если сектор ещё не заполнен писать не будем
 765++869F
 766++869F              	; ld hl,sec_buf
 767++869F              	; ld de,(#5cf4)
 768++869F              	; ;ld (f_w_cur_trk),de	;запомним позицию
 769++869F                  ; ld      bc,#0106 ;пишем 1 сектор из буфера
 770++869F                  ; call    call3d13
 771++869F              	; ld a,c
 772++869F              	; cp 255
 773++869F              	; jp z,fwrite_no_chek ;выход если ошибка
 774++869F
 775++869F              	; xor a
 776++869F              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 777++869F              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 778++869F              	; ; ld (#5cf4),de
 779++869F              	; ; ld b,1 ;на сектор вперёд
 780++869F              	; ; ld de,(f_w_cur_trk)
 781++869F              	; ; call calc_next_pos
 782++869F              	; ; ld (f_w_cur_trk),de
 783++869F
 784++869F              ; fwrite_trd3
 785++869F              	; ld hl,(temp_hl) ;запишем остаток данных
 786++869F              	; ;ld a,(sec_shift)
 787++869F              	; ;ld c,a
 788++869F              	; ;ld b,0
 789++869F              	; ld bc,(sec_shift2)
 790++869F              	; add hl,bc ;с этой точки пишем
 791++869F              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 792++869F
 793++869F              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 794++869F              	; and a
 795++869F              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 796++869F              	; ld c,l
 797++869F              	; ld b,h
 798++869F              	; jr nc,fwrite_trd5
 799++869F              	; ld b,0 ;коррекция если вышел минус
 800++869F              ; fwrite_trd5
 801++869F              	; ld hl,(temp_hl)
 802++869F              	; add hl,bc
 803++869F
 804++869F              	; ld de,outputBuffer
 805++869F              	; and a
 806++869F              	; sbc hl,de
 807++869F
 808++869F              	; ld a,l
 809++869F              	; ld (sec_shift),a ;смещение на следующий раз
 810++869F              	; ;ld hl,(temp_hl)
 811++869F
 812++869F
 813++869F              	; ; or a
 814++869F              	; ; jr z,fwrite_trd1
 815++869F              	; ; inc b  ;коррекция количества секторов
 816++869F
 817++869F              	; ld a,b ;нужна проверка на количество секторов!!!
 818++869F              	; ld (sec_part),a ;запомним сколько секторов во второй части
 819++869F
 820++869F              	; ;ld a,b
 821++869F              	; or a
 822++869F              	; jr z,fwrite_trd1 ;если размер данных меньше сектора, то пропустим запись
 823++869F
 824++869F              	; ld hl,(temp_hl2)
 825++869F              	; ;push bc
 826++869F              	; ld de,(#5cf4)
 827++869F                  ; ld      c,6 ;пишем целыми секторами
 828++869F                  ; call    call3d13
 829++869F              	; ld a,c
 830++869F              	; ;pop bc
 831++869F              	; cp 255
 832++869F              	; jp z,fwrite_no_chek ;выход если ошибка
 833++869F              	; ; ld de,(f_w_cur_trk)
 834++869F              	; ; call calc_next_pos
 835++869F              	; ; ld (f_w_cur_trk),de
 836++869F
 837++869F              	; xor a
 838++869F              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 839++869F
 840++869F              ; fwrite_trd1
 841++869F              	; ld a,(write_end_flag) ;нужно записывать остаток?
 842++869F              	; or a
 843++869F              	; jr nz,fwrite_trd_ex ;не нужно
 844++869F
 845++869F              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
 846++869F              	; ld a,(sec_part)
 847++869F              	; ld b,a
 848++869F              	; ld c,0
 849++869F              	; add hl,bc
 850++869F              	; ld de,sec_buf
 851++869F              	; ld bc,256
 852++869F              	; ldir
 853++869F              ; ;fwrite_trd2
 854++869F
 855++869F
 856++869F              ; fwrite_trd_ex
 857++869F              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 858++869F              	; ;посчитаем общую длину записанного
 859++869F              	; ld hl,(f_w_len)
 860++869F              	; add hl,bc
 861++869F              	; ld (f_w_len),hl
 862++869F              	; jr nc,fwrite_trd_ex1
 863++869F              	; ld hl,(f_w_len+2)
 864++869F              	; inc hl
 865++869F              	; ld (f_w_len+2),hl
 866++869F
 867++869F              ; fwrite_trd_ex1
 868++869F              	; xor a ;флаги сбросим
 869++869F                  ; ret
 870++869F
 871++869F
 872++869F
 873++869F
 874++869F
 875++869F              ; ;------------------scl----------------------
 876++869F              ; fwrite_chek_scl ;запись scl файла (разворачивание образа, id=4)
 877++869F              	; ; ld a,2
 878++869F              	; ; out (254),a
 879++869F
 880++869F              	; ; xor a
 881++869F              	; ; out (254),a
 882++869F              	; ld a,(f_w_flag)
 883++869F              	; or a
 884++869F              	; jp z,fwrite_no_chek ;файл уже открыт?
 885++869F              	; ld (temp_bc),bc ;длина
 886++869F              	; ld (temp_hl),hl ;адрес данных
 887++869F              	; ld a,b
 888++869F              	; or c
 889++869F              	; jp z,fwrite_no_chek ; если длина 0, то выход
 890++869F
 891++869F              	; ; ld a,b
 892++869F              	; ; or a
 893++869F              	; ; jr nz,testt1
 894++869F              	; ; nop
 895++869F
 896++869F              ; ; testt1
 897++869F
 898++869F              	; xor a
 899++869F              	; ld (sec_part),a ;обнулить переменные
 900++869F              	; ld (sec_shift2),a
 901++869F              	; ld (sec_shift2+1),a
 902++869F              	; ld (sec_shift_flag),a
 903++869F              	; ld (write_end_flag),a ;
 904++869F
 905++869F
 906++869F              	; ld a,(sec_shift)
 907++869F              	; or a
 908++869F              	; jr z,fwrite_scl3 ;если смещения нет, то первую часть пропустим
 909++869F
 910++869F
 911++869F              	; ld c,a
 912++869F              	; ld b,0
 913++869F              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 914++869F              	; add hl,bc
 915++869F
 916++869F              	; ld a,1
 917++869F              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 918++869F
 919++869F              	; ld a,h
 920++869F              	; or a
 921++869F              	; jr nz,fwrite_scl4
 922++869F              	; ld a,1
 923++869F              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 924++869F
 925++869F              ; fwrite_scl4
 926++869F              	; ld hl,sec_buf ;буфер последнего сектора
 927++869F              	; add hl,bc ;на этой точке остановились
 928++869F              	; ex de,hl
 929++869F              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 930++869F              	; ; ld a,c
 931++869F              	; ; or a
 932++869F              	; ; jr nz,fwrite_scl2
 933++869F              	; ; inc b ;коррекция
 934++869F              ; ; fwrite_scl2
 935++869F              	; ; ld c,a
 936++869F              	; xor a
 937++869F              	; sub c
 938++869F              	; ld c,a ;сколько осталось перенести до заполнения сектора
 939++869F              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 940++869F              	; ldir
 941++869F
 942++869F              	; ld a,(sec_shift_flag)
 943++869F              	; or a
 944++869F              	; jr nz,fwrite_scl3 ;если сектор ещё не заполнен писать не будем
 945++869F
 946++869F              	; ld hl,sec_buf
 947++869F              	; ;ld de,(#5cf4)
 948++869F              	; ;ld (f_w_cur_trk),de	;запомним позицию
 949++869F                  ; ld      b,#01 ;пишем 1 сектор из буфера
 950++869F                  ; call    scl_write_buf
 951++869F              	; ; ld a,c
 952++869F              	; ; cp 255
 953++869F              	; ; jp z,fwrite_no_chek ;выход если ошибка
 954++869F
 955++869F              	; xor a
 956++869F              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 957++869F              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 958++869F              	; ; ld (#5cf4),de
 959++869F              	; ; ld b,1 ;на сектор вперёд
 960++869F              	; ; ld de,(f_w_cur_trk)
 961++869F              	; ; call calc_next_pos
 962++869F              	; ; ld (f_w_cur_trk),de
 963++869F
 964++869F              ; fwrite_scl3
 965++869F              	; ld hl,(temp_hl) ;запишем остаток данных
 966++869F              	; ;ld a,(sec_shift)
 967++869F              	; ;ld c,a
 968++869F              	; ;ld b,0
 969++869F              	; ld bc,(sec_shift2)
 970++869F              	; add hl,bc ;с этой точки пишем
 971++869F              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 972++869F
 973++869F              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 974++869F              	; and a
 975++869F              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 976++869F              	; ld c,l
 977++869F              	; ld b,h
 978++869F              	; jr nc,fwrite_scl5
 979++869F              	; ld b,0 ;коррекция если вышел минус
 980++869F              ; fwrite_scl5
 981++869F              	; ld hl,(temp_hl)
 982++869F              	; add hl,bc
 983++869F
 984++869F              	; ld de,outputBuffer
 985++869F              	; and a
 986++869F              	; sbc hl,de
 987++869F
 988++869F              	; ld a,l
 989++869F              	; ld (sec_shift),a ;смещение на следующий раз
 990++869F              	; ;ld hl,(temp_hl)
 991++869F
 992++869F
 993++869F              	; ; or a
 994++869F              	; ; jr z,fwrite_scl1
 995++869F              	; ; inc b  ;коррекция количества секторов
 996++869F
 997++869F              	; ld a,b ;нужна проверка на количество секторов!!!
 998++869F              	; ld (sec_part),a ;запомним сколько секторов во второй части
 999++869F
1000++869F              	; ;ld a,b
1001++869F              	; or a
1002++869F              	; jr z,fwrite_scl1 ;если размер данных меньше сектора, то пропустим запись
1003++869F
1004++869F              	; ld hl,(temp_hl2)
1005++869F              	; ;push bc
1006++869F              	; ;ld de,(#5cf4)
1007++869F                  ; ;ld      c,6 ;пишем целыми секторами
1008++869F                  ; call    scl_write_buf
1009++869F              	; ;ld a,c
1010++869F              	; ;pop bc
1011++869F              	; ; cp 255
1012++869F              	; ; jp z,fwrite_no_chek ;выход если ошибка
1013++869F              	; ; ld de,(f_w_cur_trk)
1014++869F              	; ; call calc_next_pos
1015++869F              	; ; ld (f_w_cur_trk),de
1016++869F
1017++869F              	; xor a
1018++869F              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
1019++869F
1020++869F              ; fwrite_scl1
1021++869F              	; ld a,(write_end_flag) ;нужно записывать остаток?
1022++869F              	; or a
1023++869F              	; jr nz,fwrite_scl_ex ;не нужно
1024++869F
1025++869F              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
1026++869F              	; ld a,(sec_part)
1027++869F              	; ld b,a
1028++869F              	; ld c,0
1029++869F              	; add hl,bc
1030++869F              	; ld de,sec_buf
1031++869F              	; ld bc,256
1032++869F              	; ldir
1033++869F              ; ;fwrite_scl2
1034++869F
1035++869F
1036++869F              ; fwrite_scl_ex
1037++869F              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1038++869F              	; ;посчитаем общую длину записанного
1039++869F              	; ld hl,(f_w_len)
1040++869F              	; add hl,bc
1041++869F              	; ld (f_w_len),hl
1042++869F              	; jr nc,fwrite_scl_ex1
1043++869F              	; ld hl,(f_w_len+2)
1044++869F              	; inc hl
1045++869F              	; ld (f_w_len+2),hl
1046++869F
1047++869F              ; fwrite_scl_ex1
1048++869F              	; xor a ;флаги сбросим
1049++869F                  ; ret
1050++869F
1051++869F
1052++869F
1053++869F
1054++869F
1055++869F
1056++869F              ; scl_write_buf ;заполнение промежуточного буфера
1057++869F              	; push bc ;сколько пакетов указано в b
1058++869F              	; ld de,scl_buf ;перенесём сектор во временный буфер
1059++869F              	; ld bc,256
1060++869F              	; ldir
1061++869F              	; ld (scl_temp_hl2),hl ;сохраним адрес данных
1062++869F              	; ld a,(scl_que) ;проверим флаг что нужны данные
1063++869F              	; or a
1064++869F              	; jr z,scl_write_buf_ret ;не будем вызывать парсер если не нужны
1065++869F              	; ld hl,scl_write_buf_ret ;адрес возврата
1066++869F              	; push hl
1067++869F              	; ld hl,(scl_parse_ret_adr) ;адрес для продолжения основного цикла сборки
1068++869F              	; jp (hl) ;отдадим пакет 256 байт парсеру
1069++869F              ; scl_write_buf_ret
1070++869F              	; ld hl,(scl_temp_hl2)
1071++869F              	; pop bc
1072++869F              	; djnz scl_write_buf
1073++869F
1074++869F              	; ret
1075++869F
1076++869F
1077++869F
1078++869F              ; scl_parse ;разбор образа scl в trd, основной цикл
1079++869F              	; ;получить первый сектор
1080++869F              ; ;запрос порции данных по 256 байт
1081++869F              	; ld (scl_temp_hl),hl
1082++869F              	; ld (scl_temp_de),de
1083++869F              	; ld (scl_temp_bc),bc
1084++869F              	; ld a,1
1085++869F              	; ld (scl_que),a ;включим флаг что нужны данные
1086++869F              	; ld hl,scl_parse_ret ;сохраним адрес возврата
1087++869F              	; ld (scl_parse_ret_adr),hl
1088++869F              	; ret ;вернёмся для ожидания данных
1089++869F              ; scl_parse_ret
1090++869F              	; xor a
1091++869F              	; ld (scl_que),a
1092++869F              	; ld hl,(scl_temp_hl)
1093++869F              	; ld de,(scl_temp_de)
1094++869F              	; ld bc,(scl_temp_bc)
1095++869F
1096++869F              	; ld de,scl_buf ;проверка метки образа
1097++869F              	; ld hl,scl_sign
1098++869F              	; ld b,8
1099++869F              ; scl_parse_chk
1100++869F              	; ld a,(de)
1101++869F              	; cp (hl)
1102++869F              	; jr nz,scl_parse_chk_no
1103++869F              	; inc hl
1104++869F              	; inc de
1105++869F              	; djnz scl_parse_chk
1106++869F              	; jr scl_parse_chk_ok
1107++869F              ; scl_parse_chk_no ;если не совпало, значит плохой образ
1108++869F                  ; ld hl, scl_err
1109++869F                  ; call DialogBox.msgBox ;предуреждение
1110++869F              	; xor a
1111++869F              	; ld (scl_que),a ;выключим флаг что нужны данные
1112++869F              	; ld a,4 ;закроем файл
1113++869F              	; call fclose
1114++869F              	; ret
1115++869F              ; scl_parse_chk_ok ;сигнатура правильная
1116++869F
1117++869F              ; ;формирование каталога
1118++869F              	; ld a,(scl_buf+8)
1119++869F              	; ld (scl_files),a ;всего файлов
1120++869F              	; ld (scl_cat_cycl),a ;цикл
1121++869F              	; ld hl,scl_buf+9 ;адрес первого заголовка
1122++869F              	; ld de,cat_buf ;адрес формируемого каталога trd
1123++869F              ; scl_parse_cat2
1124++869F              	; ld b,14 ;14 байт одна запись
1125++869F              ; scl_parse_cat
1126++869F              	; ld a,(hl)
1127++869F              	; ld (de),a
1128++869F              	; inc de
1129++869F              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1130++869F              	; jr nz,scl_parse_cat1
1131++869F              	; ;тут пора запросить следующий сектор
1132++869F              ; ;запрос порции данных по 256 байт
1133++869F              	; ld (scl_temp_hl),hl
1134++869F              	; ld (scl_temp_de),de
1135++869F              	; ld (scl_temp_bc),bc
1136++869F              	; ld a,1
1137++869F              	; ld (scl_que),a ;включим флаг что нужны данные
1138++869F              	; ld hl,scl_parse_ret1 ;сохраним адрес возврата
1139++869F              	; ld (scl_parse_ret_adr),hl
1140++869F              	; ret ;вернёмся для ожидания данных
1141++869F              ; scl_parse_ret1
1142++869F              	; xor a
1143++869F              	; ld (scl_que),a
1144++869F              	; ld hl,(scl_temp_hl)
1145++869F              	; ld de,(scl_temp_de)
1146++869F              	; ld bc,(scl_temp_bc)
1147++869F
1148++869F              ; scl_parse_cat1
1149++869F              	; djnz scl_parse_cat
1150++869F              	; inc de
1151++869F              	; inc de
1152++869F              	; ld a,(scl_cat_cycl)
1153++869F              	; dec a
1154++869F              	; ld (scl_cat_cycl),a
1155++869F              	; jr nz,scl_parse_cat2
1156++869F
1157++869F              	; ld (scl_temp_hl),hl ;запомнить где остановились
1158++869F
1159++869F              ; ;подсчёт секторов и дорожек
1160++869F              	; push ix
1161++869F              	; ld a,(scl_files)
1162++869F              	; ld de,#0100 ;данные с первой дорожки
1163++869F              	; ld ix,cat_buf
1164++869F              	; ld (ix+14),e
1165++869F              	; ld (ix+15),d
1166++869F              	; ld hl,0 ;общее количество секторов
1167++869F              ; scl_cacl
1168++869F              	; ld (scl_cat_cycl),a ;цикл
1169++869F              	; ld a,(ix+13) ;длина файла в секторах
1170++869F              	; ld c,a
1171++869F              	; ld b,0
1172++869F              	; add hl,bc ;секторов
1173++869F
1174++869F              	; ld bc,16
1175++869F              	; add ix,bc
1176++869F              	; ld b,a
1177++869F              	; call calc_next_pos
1178++869F              	; ld a,(scl_cat_cycl)
1179++869F              	; cp 1
1180++869F              	; jr z,scl_cacl2 ;в последний раз пропусим
1181++869F              	; ld (ix+14),e
1182++869F              	; ld (ix+15),d
1183++869F              ; scl_cacl2
1184++869F              	; dec a
1185++869F              	; jr nz,scl_cacl
1186++869F              	; ;теперь узнаем первый свободный сектор
1187++869F              	; ld a,(ix+13) ;длина файла в секторах
1188++869F              	; ld c,a
1189++869F              	; ld b,0
1190++869F              	; add hl,bc
1191++869F              	; ; ld b,a
1192++869F              	; ; call calc_next_pos
1193++869F              	; ld (cat_buf+8*256+#e1),de ;Первый свободный сектор и дорожка на дискете
1194++869F              	; ld de,16*159
1195++869F              	; ex de,hl
1196++869F              	; and a
1197++869F              	; sbc hl,de
1198++869F              	; ld (cat_buf+8*256+#e5),hl ;Число свободных секторов на диске
1199++869F              	; pop ix
1200++869F
1201++869F
1202++869F
1203++869F              ; ;запись содержимого файлов
1204++869F              	; ld a,(scl_files) ;всего файлов
1205++869F              	; ld (scl_cat_cycl),a ;цикл
1206++869F              	; ld hl,cat_buf+13 ;адрес размер секторов файла
1207++869F              	; ld (cat_cur_adr),hl
1208++869F
1209++869F              	; ld hl,#0100 ;начиная с первой дорожки
1210++869F              	; ld (#5cf4),hl
1211++869F              ; scl_parse_file2
1212++869F              	; ld hl,(scl_temp_hl) ;адрес данных
1213++869F              	; ld de,(cat_cur_adr) ;адрес сектор дорожка файла
1214++869F              	; ;dec de
1215++869F              	; ld a,(de) ;количество секторов, цикл
1216++869F              	; ld c,a
1217++869F              ; scl_parse_file3
1218++869F              	; ld de,scl_buf2 ;адрес ещё одного буфера
1219++869F              	; ld b,0 ;256 байт один сектор, цикл
1220++869F              ; scl_parse_file
1221++869F              	; ld a,(hl)
1222++869F              	; ld (de),a
1223++869F              	; inc de
1224++869F              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1225++869F              	; jr nz,scl_parse_file1
1226++869F              	; ;тут пора запросить следующий сектор
1227++869F              ; ;запрос порции данных по 256 байт
1228++869F              	; ld (scl_temp_hl),hl
1229++869F              	; ld (scl_temp_de),de
1230++869F              	; ld (scl_temp_bc),bc
1231++869F              	; ld a,1
1232++869F              	; ld (scl_que),a ;включим флаг что нужны данные
1233++869F              	; ld hl,scl_parse_ret2 ;сохраним адрес возврата
1234++869F              	; ld (scl_parse_ret_adr),hl
1235++869F              	; ret ;вернёмся для ожидания данных
1236++869F              ; scl_parse_ret2
1237++869F              	; xor a
1238++869F              	; ld (scl_que),a
1239++869F              	; ld hl,(scl_temp_hl)
1240++869F              	; ld de,(scl_temp_de)
1241++869F              	; ld bc,(scl_temp_bc)
1242++869F
1243++869F              ; scl_parse_file1
1244++869F              	; djnz scl_parse_file
1245++869F              	; ld (scl_temp_hl),hl
1246++869F              	; ld (scl_temp_bc),bc
1247++869F
1248++869F              	; ld hl,scl_buf2 ;;запишем один сектор
1249++869F              	; ld  de,(#5cf4)
1250++869F                  ; ld      bc,#0106 ;
1251++869F                  ; call    call3d13
1252++869F              	; ; ld a,c
1253++869F              	; ; cp 255
1254++869F              	; ; jp z,fwrite_no_chek ;выход если ошибка
1255++869F              	; ld hl,(scl_temp_hl)
1256++869F              	; ld bc,(scl_temp_bc)
1257++869F
1258++869F              	; dec c
1259++869F              	; jr nz,scl_parse_file3
1260++869F
1261++869F              	; ld hl,(cat_cur_adr) ;адрес сектор дорожка файла
1262++869F              	; ; ld e,(hl)
1263++869F              	; ; inc hl
1264++869F              	; ; ld d,(hl)
1265++869F              	; ld bc,16
1266++869F              	; add hl,bc ;на следующий файл
1267++869F              	; ld (cat_cur_adr),hl
1268++869F
1269++869F
1270++869F              	; ld a,(scl_cat_cycl)
1271++869F              	; dec a
1272++869F              	; ld (scl_cat_cycl),a
1273++869F              	; jr nz,scl_parse_file2	;на следующий файл
1274++869F
1275++869F
1276++869F
1277++869F              ; ;формирование системного сектора №9 (8)
1278++869F              	; ;
1279++869F              	; ;ld (cat_buf+8*256+#e1),a ;// #E1 Первый свободный сектор на дискете
1280++869F              	; ;
1281++869F              	; ;ld (cat_buf+8*256+#e2),a ;// #E2 Первый свободный трек
1282++869F              	; ld a,#16
1283++869F              	; ld (cat_buf+8*256+#e3),a ;// #E3 16 80 дорожек, 2 стороны
1284++869F              	; ld a,(scl_files)
1285++869F              	; ld (cat_buf+8*256+#e4),a ;// #E4 Общее количество файлов записанных на диск
1286++869F              	; ;
1287++869F              	; ;ld (cat_buf+8*256+#e5),a ;// #Е5,Е6 Число свободных секторов на диске
1288++869F              	; ;ld (cat_buf+8*256+#e6),a
1289++869F              	; ld a,#10
1290++869F              	; ld (cat_buf+8*256+#e7),a ;// #E7 Код  #10,определяющий принадлежность к TR-DOS
1291++869F
1292++869F              	; ld hl,f_name ;запишем имя диска, взяв для этого имя файла
1293++869F              	; ld de,cat_buf+8*256+#f5 ;// #F5-#FC Имя диска в ASCII формате
1294++869F              	; ld bc,8
1295++869F              	; ldir
1296++869F
1297++869F              	; ld hl,cat_buf ;запишем каталог на диск
1298++869F              	; ld de,0
1299++869F                  ; ld      bc,#0906 ;
1300++869F                  ; call    call3d13
1301++869F              	; ; ld a,c
1302++869F              	; ; cp 255
1303++869F              	; ; jp z,fwrite_no_chek ;выход если ошибка
1304++869F              	; ret
1305++869F
1306++869F
1307++869F              ; ;-----------scl end --------------------
1308++869F
1309++869F
1310++869F
1311++869F              ; ;---------------------------------------
1312++869F              ; fwrite_chek_fat ;запись файла fat
1313++869F              	; ld (temp_bc),bc ;длина
1314++869F              	; ld a,c ;младший байт длины
1315++869F              	; ld	de,fcb
1316++869F              	; R8FAT r8f09_FileWrite	;записать в файл
1317++869F              	; jp 	c,fwrite_no_chek
1318++869F
1319++869F              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1320++869F              	; ;посчитаем общую длину записанного
1321++869F              	; ld hl,(f_w_len)
1322++869F              	; add hl,bc
1323++869F              	; ld (f_w_len),hl
1324++869F              	; jr nc,fwrite_fat_ex1
1325++869F              	; ld hl,(f_w_len+2)
1326++869F              	; inc hl
1327++869F              	; ld (f_w_len+2),hl
1328++869F              ; fwrite_fat_ex1
1329++869F              	; xor a ;флаги сбросим
1330++869F              	; ret
1331++869F              ;---------------------------------------
1332++869F
1333++869F
1334++869F
1335++869F              ; A - file stream id
1336++869F              ; fsync:
1337++869F              ;     esxCall ESX_FSYNC
1338++869F                  ; ret
1339++869F
1340++869F
1341++869F              ; ; HL - name (name.ext)
1342++869F              ; ; Returns:
1343++869F              ; ; HL - name (name    e)
1344++869F              ; format_name ;подгоняет имя файла под стандарт trdos (8+1)
1345++869F
1346++869F              	; ;сначала попробуем убрать из пути подпапку, если она есть
1347++869F              	; ld (temp_hl),hl ;сохраним адрес исходного имени
1348++869F              	; ld b,#00 ;не больше 255 символов
1349++869F              ; format_name5
1350++869F              	; ld a,(hl)
1351++869F              	; cp "/" ;если есть подпапка
1352++869F              	; jr z,format_name_path_yep
1353++869F              	; ld a,(hl)
1354++869F              	; cp "." ;если ещё не дошли до расширения
1355++869F              	; jr nz,format_name6
1356++869F              	; ld hl,(temp_hl) ;если дошли до расширения, то путей нет, вернёмся на начало имени
1357++869F              	; jr format_name_7 ;на выход
1358++869F              ; format_name6
1359++869F              	; inc hl
1360++869F              	; djnz format_name5
1361++869F
1362++869F              ; format_name_path_yep ;нашли
1363++869F              	; inc hl ;пропустим знак "/"
1364++869F
1365++869F              ; format_name_7
1366++869F
1367++869F              	; push hl ;очистим место для нового имени
1368++869F              	; ld hl,f_name
1369++869F              	; ld de,f_name+1
1370++869F              	; ld (hl)," "
1371++869F              	; ld bc,8+1
1372++869F              	; ldir
1373++869F              	; ld (hl),0
1374++869F              	; ld bc,16-8-1-1
1375++869F              	; ldir
1376++869F              	; pop hl
1377++869F
1378++869F              	; ld bc,#09ff ;длина имени 9 символов
1379++869F              	; ld de,f_name ;куда
1380++869F              ; format_name2
1381++869F              	; ld a,(hl)
1382++869F              	; cp "."
1383++869F              	; jr nz,format_name1
1384++869F              	; ld de,f_name+8
1385++869F              	; inc hl
1386++869F              	; ldi ; и в конце расширение 3 буквы
1387++869F              	; ldi
1388++869F              	; ldi
1389++869F              	; ;ex de,hl ;сохраним адрес исходного расширения
1390++869F              	; jr format_name_e
1391++869F              ; format_name1
1392++869F              	; ldi
1393++869F              	; djnz format_name2
1394++869F
1395++869F              	; ;если имя длинное, пропустим лишнее до расширения
1396++869F              	; ld b,#00 ;не больше 255 символов
1397++869F              ; format_name3
1398++869F              	; ld a,(hl)
1399++869F              	; cp "."
1400++869F              	; jr nz,format_name4
1401++869F              	; ld de,f_name+8
1402++869F              	; inc hl
1403++869F              	; ldi ; и в конце расширение 3 буквы
1404++869F              	; ldi
1405++869F              	; ldi
1406++869F              	; ;ex de,hl ;сохраним адрес исходного расширения
1407++869F              	; jr format_name_e
1408++869F              ; format_name4
1409++869F              	; inc hl
1410++869F              	; djnz format_name3
1411++869F
1412++869F              ; format_name_e ;выход
1413++869F              	; ld hl,f_name ;вернём результат
1414++869F              	; ret
1415++869F
1416++869F              ; ; DE - trk/sec
1417++869F              ; ; B - sectors step
1418++869F              ; ; Returns:
1419++869F              ; ; DE - trk/sec
1420++869F              ; calc_next_pos		;вперёд на N секторов
1421++869F              			; ;ld b,4
1422++869F              			; ;ld  de,(#5ceb)
1423++869F              ; calc_next_pos2
1424++869F              			; inc e
1425++869F              			; ld a,e
1426++869F              			; cp 16
1427++869F              			; jr c,calc_next_pos1
1428++869F              			; inc d
1429++869F              			; ld e,0
1430++869F              ; calc_next_pos1
1431++869F              			; ;ld (#5ceb),de
1432++869F              			; djnz calc_next_pos2
1433++869F              			; ret
1434++869F
1435++869F
1436++869F              ; ;testt db "123.trd"
1437++869F              ; write_ima db "Select disk "
1438++869F              ; write_ima_d db "A: (A-" ;текущая буква
1439++869F              ; write_ima_e	db "D). " ;последняя буква
1440++869F              		; db "All data may be lost! Press Y or N.",0
1441++869F              ; ;prev_drive db 0 ;предыдущий номер дисковода
1442++869F              ; curr_drive db 0 ;текущий диск
1443++869F
1444++869F              ; trdExt1 db ".trd", 0
1445++869F              ; trdExt2 db ".TRD", 0
1446++869F
1447++869F              ; sclExt1 db ".scl", 0
1448++869F              ; sclExt2 db ".SCL", 0
1449++869F
1450++869F              ;f_name ds 16 ;имя файла
1451++869F              ; f_r_cur_trk dw 	 0 ;текущие сектор-дорожка файла на чтение
1452++869F              ; f_r_len_sec db 0 ;длина файла на чтение в секторах
1453++869F              ; f_r_len dw 0;длина файла в байтах
1454++869F              ; f_r_flag db 0 ;флаг что открыт файл на чтение
1455++869F
1456++869F              ; f_w_cur_trk dw 	 0 ;текущие сектор-дорожка файла на запись
1457++869F              ; f_w_len_sec db 0 ;длина файла на запись в секторах
1458++869F              ; f_w_flag db 0 ;флаг что открыт файл на запись
1459++869F              ; f_w_len ds 4 ;длина записанных данных
1460++869F              ; write_end_flag db 0 ;флаг что нужно записать остаток
1461++869F
1462++869F              ; temp_bc dw 0 ;хранение регистра
1463++869F              ;temp_hl dw 0 ;хранение регистра
1464++869F              ; temp_hl2 dw 0 ;хранение регистра
1465++869F
1466++869F              ; sec_shift db 0 ;указатель на каком байте остановлена запись
1467++869F              ; sec_shift2 db 0 ;указатель на каком байте остановлена запись (остаток)
1468++869F              ; sec_part db 0 ;сколько секторов во второй порции для записи
1469++869F              ; sec_shift_flag db 0 ;флаг что буфер сектора не заполнен
1470++869F
1471++869F              ; ;секция scl
1472++869F              ; scl_sign db "SINCLAIR" ;метка
1473++869F              ; scl_que db 0 ;флаг запроса порции данных
1474++869F              ; scl_err db "SCL image error!",0
1475++869F              ; scl_parse_ret_adr dw 0; адрес возврата в цикл
1476++869F              ; scl_cat_cycl db 0 ;переменная цикла
1477++869F              ; scl_files db 0 ;всего файлов
1478++869F              ; scl_temp_hl dw 0;;хранение регистра
1479++869F              ; scl_temp_hl2 dw 0;
1480++869F              ; scl_temp_de dw 0;
1481++869F              ; scl_temp_bc dw 0;
1482++869F              ; cat_cur_adr dw 0;
1483++869F              ; ;scl end
1484++869F
1485++869F              ; ;секция сохранения любого файла
1486++869F              ; file_err db "Not enough space!",0
1487++869F              ; sec_cat db 0 ;сектор каталога
1488++869F              ; file_num db "0" ;номер части для больших файлов
1489++869F
1490++869F              	; ;по адресу #4000 шрифт
1491++869F              ; cat_buf equ #4800 ;буфер для кататога диска 9*256
1492++869F              ; sec_buf equ cat_buf + 9*256 ;буфер сектора для записи 256
1493++869F              ; scl_buf equ sec_buf + 512 ;промежуточный буфер 256
1494++869F              ; scl_buf2 equ scl_buf + 512 ;промежуточный буфер 256
1495++869F              ; ;общая ошибка с файлами
1496++869F              ; com_file_err db "File error!",0
1497++869F              ; com_file_err_flag db 0 ;общая ошибка
1498++869F
1499++869F
1500++869F
1501++869F
1502++869F              ; ;Раздел SMUC и SD ------------------------------------
1503++869F
1504++869F
1505++869F              ; ;список доступных разделов на винчестерах
1506++869F              ; ;7,=0/1 тип раздела MFS/FAT
1507++869F              ; ;6,=1 раздел есть
1508++869F              ; ;3,=0/1 Hdd/SD card
1509++869F              ; ;2,=0/1 для HDD master/slave
1510++869F              ; ;0..1,=?? номер раздела
1511++869F              ; ;
1512++869F              ; typeDrive	ds 3*4+1
1513++869F              ; ;typeDriveFAT	ds 3*4+1 ;список всех разделов FAT
1514++869F              ; numDrives db 0 ;количество устройств
1515++869F              ; ;numDrivesFAT db 0 ;количество устройств FAT
1516++869F              ; next_lett db 0 ;следующая свободная буква диска
1517++869F
1518++869F              ; ;подсчет количества доступных разделов на всех устройствах
1519++869F              ; ;вых: hl,a - количество устройств
1520++869F              ; ;     typeDrives - сформированная таблица
1521++869F              ; ;     cy=1 не обнаружено ни одного устройства
1522++869F              ; ;
1523++869F              ; GetNumPart
1524++869F              ; ;
1525++869F              	; push	de
1526++869F              	; push	bc
1527++869F              	; ld	hl,typeDrive
1528++869F              	; push	hl
1529++869F              	; xor	a
1530++869F              	; call	proc_01			;HDD master
1531++869F              	; ld	a,#01
1532++869F              	; call	proc_01			;HDD slave
1533++869F              	; ld	a,#02
1534++869F              	; call	proc_01			;SD card
1535++869F              	; pop	de
1536++869F              	; or	a
1537++869F              	; sbc	hl,de			;количество разделов на HDD
1538++869F              	; IFDEF	useTRD
1539++869F              	 ; ld	a,l
1540++869F              	 ; add	a,#04
1541++869F              	 ; ld	l,a
1542++869F              	; ELSE
1543++869F              	 ; ld	a,l
1544++869F              	; ENDIF
1545++869F              	; pop	bc
1546++869F              	; pop	de
1547++869F              	; ld	(numDrives),a
1548++869F              	; cp	1
1549++869F              	; ret
1550++869F
1551++869F              ; ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1552++869F              ; ;формирование таблицы с доступными разделами на винчестере
1553++869F              ; ;вх:  a =#00 выбрать master
1554++869F              ; ;       =#01 выбрать slave
1555++869F              ; ;       =#02 выбрать SD card
1556++869F              ; ;     hl - адрес в таблице разделов typeDrives
1557++869F              ; ;вых: hl - новый адрес в таблице разделов typeDrives
1558++869F              ; ;
1559++869F              ; proc_01	ld	c,a
1560++869F              	; push	hl
1561++869F              	; push	bc
1562++869F              	; R8DOS	r8d2E_CngHDD
1563++869F              	; jr	c,goto001		;на текущем канале нет винчестера
1564++869F              	; R8DOS	r8d2D_FindPart
1565++869F              ; goto001	pop	bc
1566++869F              	; pop	hl
1567++869F              	; ret	c			;на текущем винчестере нет разделов
1568++869F              	; ld	b,a
1569++869F              	; ld	a,c
1570++869F              	; add	a,a
1571++869F              	; add	a,a
1572++869F              	; ld	c,a			;номер винчестера и первого раздела
1573++869F              	; ld	a,b
1574++869F              	; ld	b,#04
1575++869F              ; loop001	ld	(hl),#00
1576++869F              	; rra
1577++869F              	; jr	nc,goto002		;нет раздела
1578++869F              	; IFDEF	useMFS
1579++869F              	 ; ld	(hl),c
1580++869F              	 ; set	6,(hl)			;=%01???hpp MFS
1581++869F              	 ; rra
1582++869F              	 ; jr	nc,goto003		;это MFS
1583++869F              	 ; set	7,(hl)			;=%11???hpp это FAT
1584++869F              	; ELSE
1585++869F              	 ; rra
1586++869F              	 ; jr	nc,goto004		;это MFS
1587++869F              	 ; ld	(hl),c
1588++869F              	 ; set	6,(hl)			;раздел есть
1589++869F              	 ; set	7,(hl)			;=%11???hpp это FAT
1590++869F              	; ENDIF
1591++869F              ; goto003	inc	hl
1592++869F              	; rla
1593++869F              ; goto002	rra
1594++869F              ; goto004	inc	c
1595++869F              	; djnz	loop001
1596++869F              	; ret
1597++869F
1598++869F
1599++869F
1600++869F              ; hdd_init_flag: db 0 ;флаг инициализации
1601++869F              ; ;fcb_tmp ds 32 ;буфер fcb временно
1602++869F              ; ActPathFAT db "\\Download",0 ;папка для сохранений
1603++869F              ; fcb ds 32	;буфер fcb
1604++869F              	; nop
1605++869F              ; ;конец секции SMUC и SD ----------------------------
1606++869F
1607++869F
1608++869F
1609++869F                  ENDMODULE
# file closed: dos/zsfat.asm
   9+ 869F              	ENDIF
  10+ 869F                  include "console.asm"
# file opened: dos/console.asm
   1++869F                  module Console
   2++869F              KEY_UP = 11
   3++869F              KEY_DN = 10
   4++869F              KEY_LT = 8
   5++869F              KEY_RT = 9
   6++869F              BACKSPACE = 12
   7++869F 00           keyCode db 0
   8++86A0
   9++86A0              ;BASIC_KEY = #5C08
  10++86A0
  11++86A0              waitForKeyUp:
  12++86A0              	OS_WAIT
  12++86A0 DF          >	rst #18
  13++86A1              	OS_GET_CHAR
  13++86A1 0E 10       >    ld c,#10
  13++86A3 E7          >    rst #20
  14++86A4 FE FF           cp 255
  15++86A6 20 F8           jr nz, waitForKeyUp
  16++86A8
  17++86A8                 ; ld (BASIC_KEY), a
  18++86A8 C9              ret
  19++86A9
  20++86A9              getC:
  21++86A9              	OS_WAIT
  21++86A9 DF          >	rst #18
  22++86AA              	OS_GET_CHAR
  22++86AA 0E 10       >    ld c,#10
  22++86AC E7          >    rst #20
  23++86AD                 ;ld a,(BASIC_KEY)
  24++86AD                 ;and a : jr z, getC
  25++86AD FE FF           cp 255
  26++86AF 28 F8           jr z, getC
  27++86B1                 ;ld b,a
  28++86B1                 ;xor a : ld (BASIC_KEY), a
  29++86B1                 ;ld a, b
  30++86B1 C9              ret
  31++86B2
  32++86B2              peekC:
  33++86B2              	OS_GET_CHAR
  33++86B2 0E 10       >    ld c,#10
  33++86B4 E7          >    rst #20
  34++86B5                  ;xor a: ld (BASIC_KEY),a
  35++86B5                  ;call inkey
  36++86B5 C9               ret
  37++86B6
  38++86B6              ; inkey:
  39++86B6                 ; ld de,0
  40++86B6                 ; ld bc,$fefe
  41++86B6                 ; in a,(c)
  42++86B6                 ; or $e1
  43++86B6                 ; cp $ff
  44++86B6                 ; jr nz, .keyhitA
  45++86B6
  46++86B6                 ; ld e,5
  47++86B6                 ; ld b,$fd
  48++86B6                 ; in a,(c)
  49++86B6                 ; or $e0
  50++86B6                 ; cp $ff
  51++86B6                 ; jr nz, .keyhitA
  52++86B6
  53++86B6                 ; ld e,10
  54++86B6                 ; ld b,$fb
  55++86B6                 ; in a,(c)
  56++86B6                 ; or $e0
  57++86B6                 ; cp $ff
  58++86B6                 ; jr nz, .keyhitA
  59++86B6
  60++86B6                 ; ld e,15
  61++86B6                 ; ld b,$f7
  62++86B6                 ; in a,(c)
  63++86B6                 ; or $e0
  64++86B6                 ; cp $ff
  65++86B6                 ; jr nz, .keyhitA
  66++86B6
  67++86B6                 ; ld e,20
  68++86B6                 ; ld b,$ef
  69++86B6                 ; in a,(c)
  70++86B6                 ; or $e0
  71++86B6                 ; cp $ff
  72++86B6                 ; jr nz, .keyhitA
  73++86B6
  74++86B6                 ; ld e,25
  75++86B6                 ; ld b,$df
  76++86B6                 ; in a,(c)
  77++86B6                 ; or $e0
  78++86B6                 ; cp $ff
  79++86B6                 ; jr nz, .keyhitA
  80++86B6
  81++86B6                 ; ld e,30
  82++86B6                 ; ld b,$bf
  83++86B6                 ; in a,(c)
  84++86B6                 ; or $e0
  85++86B6                 ; cp $ff
  86++86B6                 ; jr nz, .keyhitA
  87++86B6
  88++86B6                 ; ld e,35
  89++86B6                 ; ld b,$7f
  90++86B6                 ; in a,(c)
  91++86B6                 ; or $e2
  92++86B6                 ; cp $ff
  93++86B6                 ; ld c,a
  94++86B6                 ; jr nz, .keyhitB
  95++86B6
  96++86B6              ; .nokey
  97++86B6                 ; xor a
  98++86B6                 ; ret
  99++86B6
 100++86B6              ; .keyhitA
 101++86B6
 102++86B6                 ; ld c,a
 103++86B6
 104++86B6                 ; ld a,b
 105++86B6                 ; cpl
 106++86B6                 ; or $81
 107++86B6                 ; in a,($fe)
 108++86B6                 ; or $e0
 109++86B6                 ; cp $ff
 110++86B6                 ; jr nz, .nokey
 111++86B6
 112++86B6                 ; ld a,$7f
 113++86B6                 ; in a,($fe)
 114++86B6                 ; or $e2
 115++86B6                 ; cp $ff
 116++86B6                 ; jr nz, .nokey
 117++86B6
 118++86B6              ; .keyhitB
 119++86B6
 120++86B6                 ; ld b,0
 121++86B6                 ; ld hl,.rowtbl-$e0
 122++86B6                 ; add hl,bc
 123++86B6                 ; ld a,(hl)
 124++86B6                 ; cp 5
 125++86B6                 ; jr nc, .nokey
 126++86B6                 ; add a,e
 127++86B6                 ; ld e,a
 128++86B6
 129++86B6                 ; ld hl,.table
 130++86B6                 ; add hl,de
 131++86B6
 132++86B6                 ; ld a,$fe
 133++86B6                 ; in a,($fe)
 134++86B6                 ; and $01
 135++86B6                 ; jr nz, .nocaps
 136++86B6                 ; ld e,40
 137++86B6                 ; add hl,de
 138++86B6
 139++86B6              ; .nocaps
 140++86B6
 141++86B6                 ; ld a,$7f
 142++86B6                 ; in a,($fe)
 143++86B6                 ; and $02
 144++86B6                 ; jr nz, .nosym
 145++86B6                 ; ld e,80
 146++86B6                 ; add hl,de
 147++86B6
 148++86B6              ; .nosym
 149++86B6
 150++86B6                 ; ld a,(hl)
 151++86B6                 ; ret
 152++86B6
 153++86B6              ; .rowtbl
 154++86B6                 ; defb 255,255,255,255,255,255,255
 155++86B6                 ; defb 255,255,255,255,255,255,255,255
 156++86B6                 ; defb 4,255,255,255,255,255,255
 157++86B6                 ; defb 255,3,255,255,255,2,255,1
 158++86B6                 ; defb 0,255
 159++86B6
 160++86B6              ; .table
 161++86B6                 ; db 0,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
 162++86B6                 ; db 'a','s','d','f','g'      ; A, S, D, F, G
 163++86B6                 ; db 'q','w','e','r','t'      ; Q, W, E, R, T
 164++86B6                 ; db '1','2','3','4','5'      ; 1, 2, 3, 4, 5
 165++86B6                 ; db '0','9','8','7','6'      ; 0, 9, 8, 7, 6
 166++86B6                 ; db 'p','o','i','u','y'      ; P, O, I, U, Y
 167++86B6                 ; db 13,'l','k','j','h'       ; ENTER, L, K, J, H
 168++86B6                 ; db ' ',0,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B
 169++86B6
 170++86B6                 ; ; the following are CAPS SHIFTed
 171++86B6
 172++86B6                 ; db 0,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
 173++86B6                 ; db 'A','S','D','F','G'      ; A, S, D, F, G
 174++86B6                 ; db 'Q','W','E','R','T'      ; Q, W, E, R, T
 175++86B6                 ; db 7,6,128,129,8            ; 1, 2, 3, 4, 5
 176++86B6                 ; db 12,0,9,11,10             ; 0, 9, 8, 7, 6
 177++86B6                 ; db 'P','O','I','U','Y'      ; P, O, I, U, Y
 178++86B6                 ; db 13,'L','K','J','H'       ; ENTER, L, K, J, H
 179++86B6                 ; db ' ',0,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B
 180++86B6
 181++86B6                 ; ; the following are SYM SHIFTed
 182++86B6
 183++86B6                 ; db 0,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
 184++86B6                 ; db '~','|',92,'{','}'       ; A, S, D, F, G
 185++86B6                 ; db 131,132,133,'<','>'      ; Q, W, E, R, T
 186++86B6                 ; db '!','@','#','$','%'      ; 1, 2, 3, 4, 5
 187++86B6                 ; db '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
 188++86B6                 ; db 34,';',130,']','['       ; P, O, I, U, Y
 189++86B6                 ; db 13,'=','+','-','^'       ; ENTER, L, K, J, H
 190++86B6                 ; db ' ',0,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B
 191++86B6
 192++86B6                 ; ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)
 193++86B6
 194++86B6                 ; db 0,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
 195++86B6                 ; db 1,19,4,6,7               ; A, S, D, F, G
 196++86B6                 ; db 17,23,5,18,20            ; Q, W, E, R, T
 197++86B6                 ; db 27,28,29,30,31           ; 1, 2, 3, 4, 5
 198++86B6                 ; db 127,0,134,'`',135      ; 0, 9, 8, 7, 6
 199++86B6                 ; db 16,15,9,21,25            ; P, O, I, U, Y
 200++86B6                 ; db 13,12,11,10,8            ; ENTER, L, K, J, H
 201++86B6                 ; db ' ',0,13,14,2          ; SPACE, SYM SHIFT, M, N, B
 202++86B6
 203++86B6                  endmodule
# file closed: dos/console.asm
# file closed: dos/index.asm
  19  86B6                  include "gopher/engine/history/index.asm"
# file opened: gopher/engine/history/index.asm
   1+ 86B6                  include "controler.asm"
# file opened: gopher/engine/history/controler.asm
   1++86B6                  module History
   2++86B6              back:
   3++86B6 3A EF 87         ld a, (depth)
   3++86B9 FE 01          cp 1
   3++86BB CA CD 86       jp z, load
   4++86BE 21 38 8B 11      ld hl, historyBlock + HistoryRecord, de, historyBlock, bc, (total - 1) * HistoryRecord
   4++86C2 F0 87 01 20
   4++86C6 0D
   4++86C7 ED B0          ldir ; Move history up
   5++86C9 21 EF 87         ld hl, depth
   5++86CC 35             dec (hl)
   6++86CD              ; Loads current resource
   7++86CD              load:
   8++86CD 21 EA 86         ld hl, .msg
   8++86D0 CD 30 86       call DialogBox.msgNoWait
   9++86D3 AF               xor a
   9++86D4 21 5B A3 11    ld hl, outputBuffer, de, outputBuffer + 1
   9++86D8 5C A3
  10++86DA 01 A3 5C         ld bc, #ffff - outputBuffer - 1
  11++86DD 77               ld (hl), a
  12++86DE ED B0            ldir
  13++86E0
  14++86E0 3A F0 87         ld a, (historyBlock.isFile)
  14++86E3 A7             and a
  14++86E4 C2 B8 9D       jp nz, Fetcher.fetchFromFS
  15++86E7 C3 68 9D         jp Fetcher.fetchFromNet
  16++86EA
  17++86EA 4C 6F 61 64  .msg db "Loading resource! Please wait! It will be here soon!", 0
  17++86EE 69 6E 67 20
  17++86F2 72 65 73 6F
  17++86F6 75 72 63 65
  17++86FA 21 20 50 6C
  17++86FE 65 61 73 65
  17++8702 20 77 61 69
  17++8706 74 21 20 49
  17++870A 74 20 77 69
  17++870E 6C 6C 20 62
  17++8712 65 20 68 65
  17++8716 72 65 20 73
  17++871A 6F 6F 6E 21
  17++871E 00
  18++871F
  19++871F              home:
  20++871F 21 D0 87         ld hl, homePage
  21++8722              ; HL - gopher row
  22++8722              navigate:
  23++8722 54 5D            ld de, hl
  24++8724 CD E1 9B         call UrlEncoder.isValidGopherRow
  25++8727 30 A4            jr nc, load ; Not valid - reload last
  26++8729 62 6B            ld hl, de
  27++872B E5               push hl
  28++872C
  29++872C E5               push hl
  30++872D 21 57 98 11      ld hl, HistoryEnd - HistoryRecord, de, HistoryEnd, bc,  HistoryRecord * total
  30++8731 9F 9B 01 68
  30++8735 10
  30++8736 ED B8          lddr
  31++8738
  32++8738 ED 5B 36 8B      ld de, (Render.position), (historyBlock.position + HistoryRecord), de
  32++873C ED 53 7E 8E
  33++8740                  ; Clean up struct
  34++8740 AF               xor a
  34++8741 21 F0 87 11    ld hl, historyBlock, de, historyBlock + 1, bc, historyBlockSize - 1, (hl), a
  34++8745 F1 87 01 47
  34++8749 03 77
  34++874B ED B0          ldir
  35++874D E1               pop hl
  36++874E
  37++874E                  ; Fill record
  38++874E 54 5D            ld de, hl
  39++8750 CD A0 9B         call UrlEncoder.isFile
  40++8753 EB               ex hl, de
  41++8754 11 F0 87         ld de, historyBlock
  42++8757 12               ld (de), a
  42++8758 13             inc de
  43++8759 7E               ld a, (hl)
  43++875A E5 D5          push hl, de
  43++875C CD 06 81       call Render.getIcon
  43++875F D1 E1          pop de, hl
  44++8761 12               ld (de), a
  44++8762 13             inc de
  45++8763 3E 09 01 FF      ld a, 9, bc, #fff
  45++8767 0F
  45++8768 ED B1          cpir
  46++876A              .locatorCopy
  47++876A 7E               ld a, (hl)
  47++876B FE 09          cp 9
  47++876D 28 05          jr z, 1f
  48++876F 12               ld (de), a
  48++8770 23 13          inc hl, de
  49++8772 18 F6            jr .locatorCopy
  50++8774              1
  51++8774 23               inc hl
  51++8775 AF             xor a
  51++8776 12             ld (de), a
  52++8777 11 F1 89         ld de, historyBlock.host
  53++877A              .hostCopy
  54++877A 7E               ld a, (hl)
  54++877B FE 09          cp 9
  54++877D 28 05          jr z, 1f
  55++877F 12               ld (de), a
  55++8780 23 13          inc hl, de
  56++8782 18 F6            jr .hostCopy
  57++8784              1
  58++8784 23               inc hl
  58++8785 AF             xor a
  58++8786 12             ld (de), a
  59++8787 11 31 8A         ld de, historyBlock.port
  60++878A              .portCopy
  61++878A 7E               ld a, (hl)
  62++878B FE 09            cp 9
  62++878D 28 11          jr z, 1f
  63++878F FE 0D            cp 13
  63++8791 28 0D          jr z, 1f
  64++8793 FE 0A            cp 10
  64++8795 28 09          jr z, 1f
  65++8797 FE 00            cp 0
  65++8799 28 05          jr z, 1f
  66++879B 12               ld (de), a
  66++879C 23 13          inc hl, de
  67++879E 18 EA            jr .portCopy
  68++87A0 AF           1   xor a
  68++87A1 12             ld (de), a
  69++87A2 21 D7 85 11      ld hl, DialogBox.inputBuffer, de, historyBlock.search, bc, #ff
  69++87A6 37 8A 01 FF
  69++87AA 00
  69++87AB ED B0          ldir
  70++87AD 11 00 00 ED      ld de, 0, (historyBlock.position), de
  70++87B1 53 36 8B
  71++87B4 E1               pop hl
  72++87B5 3A EF 87         ld a, (depth)
  72++87B8 FE 05          cp total
  72++87BA 30 04          jr nc, 1f
  73++87BC 3C               inc a
  73++87BD 32 EF 87       ld (depth), a
  74++87C0              1
  75++87C0 3A F1 87         ld a,(historyBlock.mediaType)
  75++87C3 FE 01          cp MIME_DOWNLOAD
  75++87C5 CA B5 9E       jp z, Gopher.download
  76++87C8
  77++87C8                  ifdef GS
  78++87C8 FE 07            cp MIME_MOD
  78++87CA CA 57 9E       jp z, Gopher.loadMod
  79++87CD                  endif
  80++87CD
  81++87CD C3 CD 86         jp load
  82++87D0
  83++87D0              homePage:
  84++87D0 31 48 6F 6D      db "1Home", TAB, "data/index.gph"
  84++87D4 65 09 64 61
  84++87D8 74 61 2F 69
  84++87DC 6E 64 65 78
  84++87E0 2E 67 70 68
  85++87E4 09 66 69 6C      db TAB, "file", TAB, "70", CR, LF, 0
  85++87E8 65 09 37 30
  85++87EC 0D 0A 00
  86++87EF                  endmodule
# file closed: gopher/engine/history/controler.asm
   2+ 87EF                  include "model.asm"
# file opened: gopher/engine/history/model.asm
   1++87EF              total   equ 5
   2++87EF 00           depth   db 0
   3++87F0
   4++87F0              historyBlock:
   5++87F0 00           .isFile    db  0
   6++87F1 00           .mediaType db  0
   7++87F2 00 00 00...  .locator   ds  #1ff
   8++89F1 00 00 00...  .host      ds  64
   9++8A31 00 00 00...  .port      ds  6
  10++8A37 00 00 00...  .search    ds  #ff
  11++8B36 00 00        .position  dw  #00
  12++8B38
  13++8B38              historyBlockSize = $ - historyBlock
  14++8B38
  15++8B38              HistoryRecord EQU $ - historyBlock
  16++8B38                  dup total
  17++8B38 00 00 00... >    ds HistoryRecord
  17++8E80 00 00 00... >    ds HistoryRecord
  17++91C8 00 00 00... >    ds HistoryRecord
  17++9510 00 00 00... >    ds HistoryRecord
  17++9858 00 00 00... >    ds HistoryRecord
  18++985C                  edup
  19++9BA0              HistoryEnd equ $ - 1
# file closed: gopher/engine/history/model.asm
# file closed: gopher/engine/history/index.asm
  20  9BA0                  include "gopher/engine/urlencoder.asm"
# file opened: gopher/engine/urlencoder.asm
   1+ 9BA0                  MODULE UrlEncoder
   2+ 9BA0              ; HL - pointer to line in gopher page
   3+ 9BA0              ; C - flag set when it's file
   4+ 9BA0              isFile:
   5+ 9BA0              .findServerLoop
   6+ 9BA0 7E               ld a, (hl)
   6+ 9BA1 A7             and a
   6+ 9BA2 28 3B          jr z, .notFile
   6+ 9BA4 23             inc hl
   7+ 9BA5 FE 0D            cp 13
   7+ 9BA7 28 36          jr z, .notFile
   8+ 9BA9 FE 09            cp 9
   8+ 9BAB 28 02          jr z, .skipPath
   9+ 9BAD 18 F1            jr .findServerLoop
  10+ 9BAF              .skipPath
  11+ 9BAF 7E               ld a, (hl)
  11+ 9BB0 A7             and a
  11+ 9BB1 28 2C          jr z, .notFile
  11+ 9BB3 23             inc hl
  12+ 9BB4 FE 0D            cp 13
  12+ 9BB6 28 27          jr z, .notFile
  13+ 9BB8 FE 09            cp 9
  13+ 9BBA 28 02          jr z, .compareServer
  14+ 9BBC 18 F1            jr .skipPath
  15+ 9BBE              .compareServer
  16+ 9BBE 7E               ld a, (hl)
  16+ 9BBF FE 66          cp "f"
  16+ 9BC1 20 1C          jr nz, .notFile
  16+ 9BC3 23             inc hl
  17+ 9BC4 7E               ld a, (hl)
  17+ 9BC5 FE 69          cp "i"
  17+ 9BC7 20 16          jr nz, .notFile
  17+ 9BC9 23             inc hl
  18+ 9BCA 7E               ld a, (hl)
  18+ 9BCB FE 6C          cp "l"
  18+ 9BCD 20 10          jr nz, .notFile
  18+ 9BCF 23             inc hl
  19+ 9BD0 7E               ld a, (hl)
  19+ 9BD1 FE 65          cp "e"
  19+ 9BD3 20 0A          jr nz, .notFile
  19+ 9BD5 23             inc hl
  20+ 9BD6 7E               ld a, (hl)
  20+ 9BD7 FE 09          cp 9
  20+ 9BD9 20 04          jr nz, .notFile
  20+ 9BDB 23             inc hl
  21+ 9BDC 3E 01            ld a, 1
  22+ 9BDE C9               ret
  23+ 9BDF              .notFile
  24+ 9BDF AF               xor a
  25+ 9BE0 C9               ret
  26+ 9BE1
  27+ 9BE1              ; Is enough fields to encode
  28+ 9BE1              ; HL - pointer to line in gopher page
  29+ 9BE1              ; C - flag set when there is enough fields
  30+ 9BE1              isValidGopherRow:
  31+ 9BE1 7E               ld a, (hl)
  31+ 9BE2 A7             and a
  31+ 9BE3 28 FA          jr z, isFile.notFile
  31+ 9BE5 23             inc hl
  32+ 9BE6 FE 0D            cp 13
  32+ 9BE8 28 F5          jr z, isFile.notFile
  33+ 9BEA FE 09            cp 9
  33+ 9BEC 28 02          jr z, .skipPath
  34+ 9BEE 18 F1            jr isValidGopherRow
  35+ 9BF0              .skipPath
  36+ 9BF0 7E               ld a, (hl)
  36+ 9BF1 A7             and a
  36+ 9BF2 28 EB          jr z, isFile.notFile
  36+ 9BF4 23             inc hl
  37+ 9BF5 FE 0D            cp 13
  37+ 9BF7 28 E6          jr z, isFile.notFile
  38+ 9BF9 FE 09            cp 9
  38+ 9BFB 28 02          jr z, .skipHost
  39+ 9BFD 18 F1            jr .skipPath
  40+ 9BFF              .skipHost
  41+ 9BFF 7E               ld a, (hl)
  41+ 9C00 A7             and a
  41+ 9C01 28 DC          jr z, isFile.notFile
  41+ 9C03 23             inc hl
  42+ 9C04 FE 0D            cp 13
  42+ 9C06 28 D7          jr z, isFile.notFile
  43+ 9C08 FE 09            cp 9
  43+ 9C0A 28 02           jr z, .isValid
  44+ 9C0C 18 F1            jr .skipHost
  45+ 9C0E              .isValid:
  46+ 9C0E 37               scf
  47+ 9C0F C9               ret
  48+ 9C10
  49+ 9C10              extractPath:
  50+ 9C10 21 F2 87 11      ld hl, historyBlock.locator, de, nameBuffer, bc, #ff
  50+ 9C14 28 9C 01 FF
  50+ 9C18 00
  50+ 9C19 ED B0          ldir
  51+ 9C1B C9               ret
  52+ 9C1C
  53+ 9C1C              extractHostName:
  54+ 9C1C 21 F1 89 11      ld hl, historyBlock.host, de, hostName, bc, 64
  54+ 9C20 28 9D 01 40
  54+ 9C24 00
  54+ 9C25 ED B0          ldir
  55+ 9C27 C9               ret
  56+ 9C28
  57+ 9C28                  ENDMODULE
  58+ 9C28
  59+ 9C28 00 00 00...  nameBuffer ds #ff, 0
  60+ 9D27
  61+ 9D27 00                    db 0
  62+ 9D28 00 00 00...  hostName ds 64
# file closed: gopher/engine/urlencoder.asm
  21  9D68                  include "gopher/engine/fetcher.asm"
# file opened: gopher/engine/fetcher.asm
   1+ 9D68                  MODULE Fetcher
   2+ 9D68
   3+ 9D68              fetchFromNet:
   4+ 9D68 CD 2F 9E         call Gopher.makeRequest
   4+ 9D6B 38 06          jr c, .error
   5+ 9D6D CD 47 9E         call Gopher.loadBuffer
   6+ 9D70 C3 C4 9D         jp MediaProcessor.processResource
   7+ 9D73              .error
   8+ 9D73              	OS_ESP_CLOSE ;закрыть соединение, если было
   8+ 9D73 0E 0C       >    ld c,#0c
   8+ 9D75 E7          >    rst #20
   9+ 9D76 21 7F 9D         ld hl, .err
   9+ 9D79 CD 27 86       call DialogBox.msgBox
  10+ 9D7C C3 B6 86         jp History.back
  11+ 9D7F
  12+ 9D7F 44 6F 63 75  .err db "Document fetch error! Check your connection or hostname!", 0
  12+ 9D83 6D 65 6E 74
  12+ 9D87 20 66 65 74
  12+ 9D8B 63 68 20 65
  12+ 9D8F 72 72 6F 72
  12+ 9D93 21 20 43 68
  12+ 9D97 65 63 6B 20
  12+ 9D9B 79 6F 75 72
  12+ 9D9F 20 63 6F 6E
  12+ 9DA3 6E 65 63 74
  12+ 9DA7 69 6F 6E 20
  12+ 9DAB 6F 72 20 68
  12+ 9DAF 6F 73 74 6E
  12+ 9DB3 61 6D 65 21
  12+ 9DB7 00
  13+ 9DB8
  14+ 9DB8
  15+ 9DB8              fetchFromFS:
  16+ 9DB8 CD 10 9C         call UrlEncoder.extractPath
  17+ 9DBB              loadFile
  18+ 9DBB 21 28 9C         ld hl, nameBuffer
  19+ 9DBE CD 5E 86         call Dos.loadBuffer
  20+ 9DC1 C3 C4 9D         jp MediaProcessor.processResource
  21+ 9DC4                  ENDMODULE
# file closed: gopher/engine/fetcher.asm
  22  9DC4                  include "gopher/engine/media-processor.asm"
# file opened: gopher/engine/media-processor.asm
   1+ 9DC4                  MODULE MediaProcessor
   2+ 9DC4              processResource:
   3+ 9DC4 CD 1C 9C         call UrlEncoder.extractHostName
   4+ 9DC7 3A F1 87         ld a, (historyBlock.mediaType)
   5+ 9DCA FE 05            cp MIME_MUSIC
   5+ 9DCC 28 17          jr z, processPT
   6+ 9DCE FE 02            cp MIME_LINK
   6+ 9DD0 28 1F          jr z, processPage
   7+ 9DD2 FE 04            cp MIME_INPUT
   7+ 9DD4 28 1B          jr z, processPage
   8+ 9DD6 FE 06            cp MIME_IMAGE
   8+ 9DD8 CA 1B A2       jp z, ScreenViewer.display
   9+ 9DDB              	ifdef GS
  10+ 9DDB FE 07            cp MIME_MOD
  10+ 9DDD 28 0C          jr z, processMOD
  11+ 9DDF              	endif
  12+ 9DDF              ; Fallback to plain text
  13+ 9DDF              processText:
  14+ 9DDF CD E1 84         call Render.renderPlainTextScreen
  15+ 9DE2 C3 1D 85         jp   Render.plainTextLoop
  16+ 9DE5
  17+ 9DE5              processPT:
  18+ 9DE5 CD 86 A1         call VortexProcessor.play
  19+ 9DE8 C3 B6 86         jp History.back
  20+ 9DEB
  21+ 9DEB                  ifdef GS
  22+ 9DEB              processMOD:
  23+ 9DEB CD DA A1         call ModProcessor.play
  24+ 9DEE C3 B6 86         jp History.back
  25+ 9DF1              	endif
  26+ 9DF1
  27+ 9DF1              processPage:
  28+ 9DF1 3A 81 85         ld a, (Render.play_next)
  28+ 9DF4 A7             and a
  28+ 9DF5 20 06          jr nz, .playNext
  29+ 9DF7 CD 85 83         call Render.renderGopherScreen
  30+ 9DFA C3 CC 83         jp   Render.workLoop
  31+ 9DFD              .playNext
  32+ 9DFD 21 37 8B         ld hl, Render.cursor_position
  33+ 9E00 34               inc (hl)
  34+ 9E01 C3 B6 83         jp Render.checkBorder
  35+ 9E04
  36+ 9E04
  37+ 9E04                  ENDMODULE
# file closed: gopher/engine/media-processor.asm
  23  9E04                  include "gopher/gopher.asm"
# file opened: gopher/gopher.asm
   1+ 9E04                  module Gopher
   2+ 9E04              extractRequest:
   3+ 9E04 21 F2 87         ld hl, historyBlock.locator
   4+ 9E07 11 87 9F         ld de, requestbuffer
   5+ 9E0A              .loop
   6+ 9E0A 7E               ld a, (hl)
   7+ 9E0B 12               ld (de), a
   8+ 9E0C 23               inc hl
   9+ 9E0D 13               inc de
  10+ 9E0E FE 00            cp 0
  11+ 9E10 28 02            jr z, .search
  12+ 9E12 18 F6            jr .loop
  13+ 9E14              .search
  14+ 9E14 1B               dec de
  15+ 9E15 3A F1 87         ld a, (historyBlock.mediaType)
  16+ 9E18 FE 04            cp MIME_INPUT
  17+ 9E1A 20 10            jr nz, .exit
  18+ 9E1C 21 37 8A         ld hl, historyBlock.search
  19+ 9E1F 3E 09            ld a, TAB
  20+ 9E21 12               ld (de), a
  21+ 9E22 13               inc de
  22+ 9E23              .searchCopy
  23+ 9E23 7E               ld a, (hl)
  24+ 9E24 A7               and a
  24+ 9E25 28 05          jr z, .exit
  25+ 9E27 12               ld (de), a
  26+ 9E28 23               inc hl
  26+ 9E29 13             inc de
  27+ 9E2A 18 F7            jr .searchCopy
  28+ 9E2C              .exit
  29+ 9E2C AF               xor a
  30+ 9E2D 12               ld (de), a
  31+ 9E2E C9               ret
  32+ 9E2F
  33+ 9E2F
  34+ 9E2F              makeRequest:
  35+ 9E2F CD 04 9E         call extractRequest
  36+ 9E32
  37+ 9E32 21 F1 89         ld hl, historyBlock.host
  38+ 9E35 11 31 8A         ld de, historyBlock.port
  39+ 9E38 CD 5B A2         call Wifi.openTCP
  40+ 9E3B D8               ret c
  41+ 9E3C
  42+ 9E3C 21 87 9F         ld hl, requestbuffer
  43+ 9E3F CD 85 A2         call Wifi.tcpSendZ
  44+ 9E42 AF               xor a
  44+ 9E43 32 5A A2       ld (Wifi.closed), a
  45+ 9E46 C9               ret
  46+ 9E47
  47+ 9E47
  48+ 9E47              loadBuffer:
  49+ 9E47 21 5B A3         ld hl, outputBuffer
  50+ 9E4A 22 58 A2         ld (Wifi.buffer_pointer), hl
  51+ 9E4D              .loop
  52+ 9E4D CD A3 A2         call Wifi.getPacket
  53+ 9E50 3A 5A A2         ld a, (Wifi.closed)
  53+ 9E53 A7             and a
  53+ 9E54 C0             ret nz
  54+ 9E55                  ;call Wifi.continue
  55+ 9E55 18 F6            jr .loop
  56+ 9E57
  57+ 9E57                  ifdef GS
  58+ 9E57              loadMod:
  59+ 9E57 AF               xor a
  59+ 9E58 CD F8 A2       call GeneralSound.init
  60+ 9E5B 21 95 9E         ld hl, .progress
  60+ 9E5E CD 30 86       call DialogBox.msgNoWait
  61+ 9E61 CD 2F 9E         call makeRequest
  61+ 9E64 DA 73 9D       jp c, Fetcher.fetchFromNet.error
  62+ 9E67 CD 05 A3         call GeneralSound.loadModule
  63+ 9E6A              .loop
  64+ 9E6A 21 5B A3 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
  64+ 9E6E 58 A2
  65+ 9E70 CD A3 A2         call Wifi.getPacket
  66+ 9E73 3A 5A A2         ld a, (Wifi.closed)
  66+ 9E76 A7             and a
  66+ 9E77 20 16          jr nz, .exit
  67+ 9E79 21 5B A3 ED      ld hl, outputBuffer, bc, (Wifi.bytes_avail)
  67+ 9E7D 4B 56 A2
  68+ 9E80              .loadLoop
  69+ 9E80 78               ld a, b
  69+ 9E81 B1             or c
  69+ 9E82 A7             and a
  69+ 9E83 28 08          jr z, .nextFrame
  70+ 9E85 7E               ld a, (hl)
  70+ 9E86 CD 18 A3       call GeneralSound.sendByte
  71+ 9E89 0B               dec bc
  72+ 9E8A 23               inc hl
  73+ 9E8B 18 F3            jr .loadLoop
  74+ 9E8D              .nextFrame
  75+ 9E8D                  ;call Wifi.continue
  76+ 9E8D 18 DB            jr .loop
  77+ 9E8F              .exit
  78+ 9E8F CD 20 A3         call GeneralSound.finishLoadingModule
  79+ 9E92                  ;jp History.back
  80+ 9E92 C3 C4 9D     	jp MediaProcessor.processResource
  81+ 9E95 4D 4F 44 20  .progress db "MOD downloading directly to GS!", 0
  81+ 9E99 64 6F 77 6E
  81+ 9E9D 6C 6F 61 64
  81+ 9EA1 69 6E 67 20
  81+ 9EA5 64 69 72 65
  81+ 9EA9 63 74 6C 79
  81+ 9EAD 20 74 6F 20
  81+ 9EB1 47 53 21 00
  82+ 9EB5                  endif
  83+ 9EB5
  84+ 9EB5
  85+ 9EB5              download:
  86+ 9EB5
  87+ 9EB5 11 F2 87         ld de, historyBlock.locator
  88+ 9EB8 62 6B            ld hl, de
  89+ 9EBA              .findFileName
  90+ 9EBA 1A               ld a, (de)
  90+ 9EBB 13             inc de
  91+ 9EBC FE 2F            cp '/'
  91+ 9EBE 20 02          jr nz, .skip
  92+ 9EC0 62 6B            ld hl, de
  93+ 9EC2              .skip
  94+ 9EC2 A7               and a
  94+ 9EC3 20 F5          jr nz, .findFileName
  95+ 9EC5              .copy
  96+ 9EC5                  ;; HL - filename pointer
  97+ 9EC5 11 D7 85         ld de, DialogBox.inputBuffer
  98+ 9EC8              .copyFileName
  99+ 9EC8 7E               ld a, (hl)
  99+ 9EC9 A7             and a
  99+ 9ECA 28 05          jr z, .finishCopy
 100+ 9ECC
 101+ 9ECC 12               ld (de), a
 101+ 9ECD 23 13          inc hl, de
 102+ 9ECF 18 F7            jr .copyFileName
 103+ 9ED1              .finishCopy
 104+ 9ED1 12               ld (de), a
 105+ 9ED2 CD 86 85         call DialogBox.inputBox.noclear
 106+ 9ED5 3A D7 85         ld a, (DialogBox.inputBuffer)
 106+ 9ED8 A7             and a
 106+ 9ED9 CA B6 86       jp z, History.back
 107+ 9EDC
 108+ 9EDC CD 2F 9E         call makeRequest
 108+ 9EDF DA 73 9D       jp c, Fetcher.fetchFromNet.error
 109+ 9EE2
 110+ 9EE2 06 0E 21 D7      ld b, Dos.FMODE_CREATE, hl, DialogBox.inputBuffer
 110+ 9EE6 85
 111+ 9EE7 CD 7A 86         call Dos.fopen
 112+ 9EEA 32 85 9F         ld (.fp), a
 113+ 9EED
 114+ 9EED 21 60 9F         ld hl, .progress
 114+ 9EF0 CD 30 86       call DialogBox.msgNoWait
 115+ 9EF3              .loop
 116+ 9EF3 21 5B A3 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
 116+ 9EF7 58 A2
 117+ 9EF9 CD A3 A2         call Wifi.getPacket
 118+ 9EFC 3A 5A A2         ld a, (Wifi.closed)
 118+ 9EFF A7             and a
 118+ 9F00 20 0F          jr nz, .exit
 119+ 9F02
 120+ 9F02 3A 85 9F 21      ld a, (.fp), hl, outputBuffer, bc, (Wifi.bytes_avail)
 120+ 9F06 5B A3 ED 4B
 120+ 9F0A 56 A2
 121+ 9F0C CD 99 86         call Dos.fwrite
 122+ 9F0F
 123+ 9F0F                  ;call Wifi.continue
 124+ 9F0F 18 E2            jr .loop
 125+ 9F11              .exit
 126+ 9F11 3A 85 9F         ld a, (.fp)
 127+ 9F14 CD 8F 86         call Dos.fclose
 128+ 9F17 C3 B6 86         jp History.back
 129+ 9F1A              ;.error
 130+ 9F1A 3A 85 9F         ld a, (.fp)
 131+ 9F1D CD 8F 86         call Dos.fclose
 132+ 9F20
 133+ 9F20 21 29 9F         ld hl, .err
 134+ 9F23 CD 27 86         call DialogBox.msgBox
 135+ 9F26 C3 B6 86         jp History.back
 136+ 9F29 4F 70 65 72  .err db "Operation failed! Sorry! Check filename or disk space!",0
 136+ 9F2D 61 74 69 6F
 136+ 9F31 6E 20 66 61
 136+ 9F35 69 6C 65 64
 136+ 9F39 21 20 53 6F
 136+ 9F3D 72 72 79 21
 136+ 9F41 20 43 68 65
 136+ 9F45 63 6B 20 66
 136+ 9F49 69 6C 65 6E
 136+ 9F4D 61 6D 65 20
 136+ 9F51 6F 72 20 64
 136+ 9F55 69 73 6B 20
 136+ 9F59 73 70 61 63
 136+ 9F5D 65 21 00
 137+ 9F60 44 6F 77 6E  .progress db "Downloading in progress! Wait a bit!", 0
 137+ 9F64 6C 6F 61 64
 137+ 9F68 69 6E 67 20
 137+ 9F6C 69 6E 20 70
 137+ 9F70 72 6F 67 72
 137+ 9F74 65 73 73 21
 137+ 9F78 20 57 61 69
 137+ 9F7C 74 20 61 20
 137+ 9F80 62 69 74 21
 137+ 9F84 00
 138+ 9F85 00           .fp db 0
 139+ 9F86
 140+ 9F86 00           socket db 0
 141+ 9F87
 142+ 9F87 00 00 00...  requestbuffer ds #1ff
 143+ A186                  endmodule
 144+ A186
# file closed: gopher/gopher.asm
  24  A186                  include "player/vortex-processor.asm"
# file opened: player/vortex-processor.asm
   1+ A186                  MODULE VortexProcessor
   2+ A186              play:
   3+ A186 CD A0 86         call Console.waitForKeyUp
   4+ A189
   5+ A189 21 C5 A1         ld hl, message
   5+ A18C CD 30 86       call DialogBox.msgNoWait
   6+ A18F
   7+ A18F 21 5B A3         ld hl, outputBuffer
   7+ A192                OS_VTPL_INIT
   7+ A192 0E 15       >    ld c,#15
   7+ A194 E7          >    rst #20
   8+ A195
   9+ A195
  10+ A195 3E 01 32 81      ld a, 1, (Render.play_next), a
  10+ A199 85
  11+ A19A                  ifdef GS
  12+ A19A CD 3C A3         call GeneralSound.stopModule
  13+ A19D                  endif
  14+ A19D              	OS_VTPL_PLAY
  14+ A19D 0E 16       >    ld c,#16
  14+ A19F E7          >    rst #20
  15+ A1A0              .loop
  16+ A1A0                  OS_WAIT
  16+ A1A0 DF          >	rst #18
  16+ A1A1               ; di : call VTPL.PLAY : ei
  17+ A1A1              	OS_GET_CHAR
  17+ A1A1 0E 10       >    ld c,#10
  17+ A1A3 E7          >    rst #20
  18+ A1A4 FE 20        	cp " " ;останов по пробелу
  19+ A1A6 CA BF A1     	jp z, .stopKey
  20+ A1A9 CD 4B A2     	call printRTC
  21+ A1AC              	OS_GET_VTPL_SETUP
  21+ A1AC 0E 18       >    ld c,#18
  21+ A1AE E7          >    rst #20
  22+ A1AF 7E               ld a, (hl)
  22+ A1B0
  23+ A1B0 17           	rla
  23+ A1B1 30 ED          jr nc, .loop
  24+ A1B3 3E 01 32 81      ld a, 1, (Render.play_next), a
  24+ A1B7 85
  25+ A1B8              .stop
  26+ A1B8              	OS_VTPL_MUTE
  26+ A1B8 0E 17       >    ld c,#17
  26+ A1BA E7          >    rst #20
  27+ A1BB
  28+ A1BB                  IFDEF AY
  29+ A1BB ~                call restoreAyState
  30+ A1BB                  ENDIF
  31+ A1BB
  32+ A1BB CD A0 86         call Console.waitForKeyUp
  33+ A1BE C9               ret
  34+ A1BF              .stopKey
  35+ A1BF AF               xor a
  35+ A1C0 32 81 85       ld (Render.play_next), a
  36+ A1C3 18 F3            jr .stop
  37+ A1C5
  38+ A1C5                  IFDEF AY
  39+ A1C5 ~            restoreAyState:
  40+ A1C5 ~                ld a, #07
  41+ A1C5 ~                ld bc, #fffd
  42+ A1C5 ~                out (c), a
  43+ A1C5 ~                ld a, #fc
  44+ A1C5 ~                ld b, #bf
  45+ A1C5 ~                out (c), a ; Enable read mode
  46+ A1C5 ~
  47+ A1C5 ~                ld a, #0e
  48+ A1C5 ~                ld bc, #fffd
  49+ A1C5 ~                out (c), a
  50+ A1C5 ~                ret
  51+ A1C5                  ENDIF
  52+ A1C5
  53+ A1C5 50 72 65 73  message db "Press key to stop...", 0
  53+ A1C9 73 20 6B 65
  53+ A1CD 79 20 74 6F
  53+ A1D1 20 73 74 6F
  53+ A1D5 70 2E 2E 2E
  53+ A1D9 00
  54+ A1DA                  ENDMODULE
  55+ A1DA                  ;include "player.asm"
  56+ A1DA
# file closed: player/vortex-processor.asm
  25  A1DA                  include "player/mod-processor.asm"
# file opened: player/mod-processor.asm
   1+ A1DA                  MODULE ModProcessor
   2+ A1DA                  ifdef GS
   3+ A1DA
   4+ A1DA                  macro _WaitCommand2
   5+ A1DA ~            .wait
   6+ A1DA ~                in a, (CMD)
   7+ A1DA ~                rrca
   8+ A1DA ~                jr c, .wait
   9+ A1DA                  endm
  10+ A1DA
  11+ A1DA                  macro _SendCommand2 nn
  12+ A1DA ~                ld a, nn
  12+ A1DA ~              out (CMD), a
  13+ A1DA                  endm
  14+ A1DA
  15+ A1DA              play:
  16+ A1DA CD A0 86         call Console.waitForKeyUp
  17+ A1DD
  18+ A1DD 21 87 9F         ld hl, Gopher.requestbuffer
  18+ A1E0 CD 30 86       call DialogBox.msgNoWait
  19+ A1E3
  20+ A1E3                  ;ld a, 1, (Render.play_next), a
  21+ A1E3 AF           	xor a
  22+ A1E4 32 1A A2     	ld (last_song_position),a
  23+ A1E7
  24+ A1E7              .loop
  25+ A1E7                  OS_WAIT
  25+ A1E7 DF          >	rst #18
  25+ A1E8
  26+ A1E8                  OS_GET_CHAR
  26+ A1E8 0E 10       >    ld c,#10
  26+ A1EA E7          >    rst #20
  27+ A1EB FE 20        	cp " " ;пробел
  28+ A1ED CA 14 A2     	jp z, .stopKey
  29+ A1F0 CD 4B A2     	call printRTC
  30+ A1F3                  ;проверка что MOD начал играть сначала
  31+ A1F3                  _SendCommand2 CMD_GET_SONG_POSITION
  31+ A1F3 3E 60       >    ld a, CMD_GET_SONG_POSITION
  31+ A1F5 D3 BB       >  out (CMD), a
  32+ A1F7                  _WaitCommand2
  32+ A1F7             >.wait
  32+ A1F7 DB BB       >    in a, (CMD)
  32+ A1F9 0F          >    rrca
  32+ A1FA 38 FB       >    jr c, .wait
  33+ A1FC 3A 1A A2     	ld a,(last_song_position) ;предыдущая позиция
  34+ A1FF 4F           	ld c,a
  35+ A200 DB B3        	in a,(DATA) ;текущая позиция
  36+ A202 32 1A A2     	ld (last_song_position),a
  37+ A205 B9           	cp c
  38+ A206 30 DF        	jr nc, .loop ;если не меньше, продолжаем играть
  39+ A208 3E 01 32 81      ld a, 1, (Render.play_next), a ;флаг что надо будет играть следующий файл
  39+ A20C 85
  40+ A20D              .stop
  41+ A20D CD 3C A3         call GeneralSound.stopModule
  42+ A210
  43+ A210 CD A0 86         call Console.waitForKeyUp
  44+ A213 C9               ret
  45+ A214              .stopKey
  46+ A214 AF               xor a
  46+ A215 32 81 85       ld (Render.play_next), a ;флаг что не надо играть следующий файл
  47+ A218 18 F3            jr .stop
  48+ A21A
  49+ A21A
  50+ A21A              ;message db "Press key to stop...", 0
  51+ A21A
  52+ A21A
  53+ A21A              CMD_GET_SONG_POSITION     = #60
  54+ A21A 00           last_song_position db 0
  55+ A21B
  56+ A21B              ;; Control ports
  57+ A21B              CMD  = 187
  58+ A21B              DATA = 179
  59+ A21B
  60+ A21B                  endif
  61+ A21B                  ENDMODULE
  62+ A21B
  63+ A21B
# file closed: player/mod-processor.asm
  26  A21B                  include "screen/screen.asm"
# file opened: screen/screen.asm
   1+ A21B                  module ScreenViewer
   2+ A21B              display:
   3+ A21B CD A0 86         call Console.waitForKeyUp
   4+ A21E                  ;ld a, 7 : call Memory.setPage
   5+ A21E                  ;ld hl, outputBuffer+6912, de, #c000+6912, bc, 6912 : lddr
   6+ A21E              	OS_GET_MAIN_PAGES
   6+ A21E 0E 1E       >    ld c,#1e
   6+ A220 E7          >    rst #20
   7+ A221 78           	ld a,b ; страница с буфером
   8+ A222 06 07        	ld b,7 ;страница назначения
   9+ A224 21 5B A3     	ld hl,outputBuffer
  10+ A227 11 00 C0     	ld de,#c000
  11+ A22A DD 21 00 1B  	ld ix,6912
  12+ A22E              	OS_RAM_COPY
  12+ A22E 0E 19       >    ld c,#19
  12+ A230 E7          >    rst #20
  13+ A231                  ;call TextMode.disable
  14+ A231              display_wait
  15+ A231 3E 07        	ld a,7
  16+ A233              	OS_SET_SCREEN ;включить экран
  16+ A233 0E 1D       >    ld c,#1d
  16+ A235 E7          >    rst #20
  17+ A236 30 03        	jr nc,.wait
  18+ A238              	OS_WAIT
  18+ A238 DF          >	rst #18
  19+ A239 18 F6        	jr display_wait
  20+ A23B              .wait
  21+ A23B              	OS_WAIT
  21+ A23B DF          >	rst #18
  22+ A23C              	OS_GET_CHAR
  22+ A23C 0E 10       >    ld c,#10
  22+ A23E E7          >    rst #20
  23+ A23F FE FF        	cp 255
  24+ A241 28 F8        	jr z, .wait
  25+ A243 3E 00        	ld a,0 ;текстовый
  26+ A245              	OS_SET_SCREEN
  26+ A245 0E 1D       >    ld c,#1d
  26+ A247 E7          >    rst #20
  27+ A248                  ;call TextMode.cls
  28+ A248 C3 B6 86         jp History.back
  29+ A24B
  30+ A24B                  endmodule
# file closed: screen/screen.asm
  27  A24B                  include "screen/rtc.asm"
# file opened: screen/rtc.asm
   1+ A24B              printRTC
   2+ A24B              	ifndef SMUCRTC
   3+ A24B C9           	ret
   4+ A24C              	endif
   5+ A24C              	ifdef SMUCRTC
   6+ A24C ~            	;печать текущего времени
   7+ A24C ~            	call Clock.readTime
   8+ A24C ~            	jr nc,read_time_ok
   9+ A24C ~            	; ld hl,mes_no_RTC
  10+ A24C ~            	; call print_mes
  11+ A24C ~            	; scf
  12+ A24C ~            	ret ;выход
  13+ A24C ~            read_time_ok
  14+ A24C ~            	push bc
  15+ A24C ~            	ld l,e ;часы
  16+ A24C ~            	ld h,0
  17+ A24C ~            	call toDecimal
  18+ A24C ~            	ld de,00 ;координаты
  19+ A24C ~            	call TextMode.gotoXY
  20+ A24C ~            	ld hl,decimalS+3
  21+ A24C ~            	call TextMode.printZ
  22+ A24C ~            	ld a,":"
  23+ A24C ~            	call TextMode.putC
  24+ A24C ~            	pop bc
  25+ A24C ~            	ld l,b ;минуты
  26+ A24C ~            	ld h,0
  27+ A24C ~            	call toDecimal
  28+ A24C ~            	ld hl,decimalS+3
  29+ A24C ~            	call TextMode.printZ
  30+ A24C ~            	; ld a,":"
  31+ A24C ~            	; call TextMode.putC
  32+ A24C ~            	; ld l,c ;секунды
  33+ A24C ~            	; ld h,0
  34+ A24C ~            	; call toDecimal
  35+ A24C ~            	; ld hl,decimalS+3
  36+ A24C ~            	; call TextMode.printZ
  37+ A24C ~            	; or a ;нет ошибки
  38+ A24C ~            	ret
  39+ A24C ~
  40+ A24C ~
  41+ A24C ~            toDecimal		;конвертирует 2 байта в 5 десятичных цифр
  42+ A24C ~            				;на входе в HL число
  43+ A24C ~            			ld de,10000 ;десятки тысяч
  44+ A24C ~            			ld a,255
  45+ A24C ~            toDecimal10k
  46+ A24C ~            			and a
  47+ A24C ~            			sbc hl,de
  48+ A24C ~            			inc a
  49+ A24C ~            			jr nc,toDecimal10k
  50+ A24C ~            			add hl,de
  51+ A24C ~            			add a,48
  52+ A24C ~            			ld (decimalS),a
  53+ A24C ~            			ld de,1000 ;тысячи
  54+ A24C ~            			ld a,255
  55+ A24C ~            toDecimal1k
  56+ A24C ~            			and a
  57+ A24C ~            			sbc hl,de
  58+ A24C ~            			inc a
  59+ A24C ~            			jr nc,toDecimal1k
  60+ A24C ~            			add hl,de
  61+ A24C ~            			add a,48
  62+ A24C ~            			ld (decimalS+1),a
  63+ A24C ~            			ld de,100 ;сотни
  64+ A24C ~            			ld a,255
  65+ A24C ~            toDecimal01k
  66+ A24C ~            			and a
  67+ A24C ~            			sbc hl,de
  68+ A24C ~            			inc a
  69+ A24C ~            			jr nc,toDecimal01k
  70+ A24C ~            			add hl,de
  71+ A24C ~            			add a,48
  72+ A24C ~            			ld (decimalS+2),a
  73+ A24C ~            			ld de,10 ;десятки
  74+ A24C ~            			ld a,255
  75+ A24C ~            toDecimal001k
  76+ A24C ~            			and a
  77+ A24C ~            			sbc hl,de
  78+ A24C ~            			inc a
  79+ A24C ~            			jr nc,toDecimal001k
  80+ A24C ~            			add hl,de
  81+ A24C ~            			add a,48
  82+ A24C ~            			ld (decimalS+3),a
  83+ A24C ~            			ld de,1 ;единицы
  84+ A24C ~            			ld a,255
  85+ A24C ~            toDecimal0001k
  86+ A24C ~            			and a
  87+ A24C ~            			sbc hl,de
  88+ A24C ~            			inc a
  89+ A24C ~            			jr nc,toDecimal0001k
  90+ A24C ~            			add hl,de
  91+ A24C ~            			add a,48
  92+ A24C ~            			ld (decimalS+4),a
  93+ A24C ~
  94+ A24C ~            			ret
  95+ A24C ~
  96+ A24C ~            decimalS	ds 6 ;десятичные цифры
  97+ A24C ~
  98+ A24C              	endif
# file closed: screen/rtc.asm
  28  A24C                  include "drivers/index.asm"
# file opened: drivers/index.asm
   1+ A24C                  IFDEF UNO
   2+ A24C ~                include "uno-uart.asm"
   3+ A24C                  ENDIF
   4+ A24C
   5+ A24C                  IFDEF MB03
   6+ A24C ~                include "mb03-uart.asm"
   7+ A24C                  ENDIF
   8+ A24C
   9+ A24C                  IFDEF AY
  10+ A24C ~                include "ay-uart.asm"
  11+ A24C                  ENDIF
  12+ A24C
  13+ A24C                  IFDEF ZW
  14+ A24C                  include "zx-wifi.asm"
# file opened: drivers/zx-wifi.asm
   1++A24C              ; ; This driver works with 16c550 uart that's support AFE
   2++A24C                  ; module Uart
   3++A24C              ; ; Make init shorter and readable:-)
   4++A24C                  ; macro outp port, value
   5++A24C              	; ld b, port
   6++A24C              	; ld c, #EF
   7++A24C                  ; ld a, value
   8++A24C                  ; out (c), a
   9++A24C                  ; endm
  10++A24C
  11++A24C              ; ; Internal port constants
  12++A24C              ; RBR_THR = #F8
  13++A24C              ; IER     = RBR_THR + 1
  14++A24C              ; IIR_FCR = RBR_THR + 2
  15++A24C              ; LCR     = RBR_THR + 3
  16++A24C              ; MCR     = RBR_THR + 4
  17++A24C              ; LSR     = RBR_THR + 5
  18++A24C              ; MSR     = RBR_THR + 6
  19++A24C              ; SR      = RBR_THR + 7
  20++A24C
  21++A24C              ; init:
  22++A24C                  ; outp MCR,     #0d  // Assert RTS
  23++A24C                  ; outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  24++A24C                  ; outp LCR,     #83  // 8n1, DLAB=1
  25++A24C                  ; outp RBR_THR, #01  // 115200 (divider 1)
  26++A24C                  ; outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  27++A24C
  28++A24C                  ; outp LCR,     #03 // 8n1, DLAB=0
  29++A24C                  ; outp IER,     #00 // Disable int
  30++A24C                  ; outp MCR,     #2f // Enable AFE
  31++A24C                  ; ret
  32++A24C
  33++A24C              ; ;retry_rec_count_max equ %00011111 ;ждать столько прерываний
  34++A24C
  35++A24C              ; ; Flag C <- Data available
  36++A24C              ; ; isAvailable:
  37++A24C                  ; ; ld a, LSR
  38++A24C                  ; ; in a, (#EF)
  39++A24C                  ; ; rrca
  40++A24C                  ; ; ret
  41++A24C
  42++A24C              ; ; Non-blocking read
  43++A24C              ; ; Flag C <- is byte was readen
  44++A24C              ; ; A <- byte
  45++A24C              ; ; read1:
  46++A24C                  ; ; ld a, LSR
  47++A24C                  ; ; in a, (#EF)
  48++A24C                  ; ; rrca
  49++A24C                  ; ; ret nc
  50++A24C                  ; ; ld a, RBR_THR
  51++A24C                  ; ; in a, (#EF)
  52++A24C                  ; ; scf
  53++A24C                  ; ; ret
  54++A24C
  55++A24C              ; ; Tries read byte with timeout
  56++A24C              ; ; Flag C <- is byte read
  57++A24C              ; ; A <- byte
  58++A24C              ; read:
  59++A24C              	; ;xor a ;4
  60++A24C              	; ;ld (#5C78),a ;обнулить счётчик ожидания ;13
  61++A24C              ; .wait
  62++A24C                  ; ld a, LSR
  63++A24C                  ; in a, (#EF)
  64++A24C                  ; rrca
  65++A24C              	; jr nc, .wait
  66++A24C                  ; ld a, RBR_THR
  67++A24C                  ; in a, (#EF)
  68++A24C              	; ret
  69++A24C              ; ; .readW
  70++A24C              	; ; OS_GETTIMER
  71++A24C              	; ; ld a,e
  72++A24C              	; ; and retry_rec_count_max
  73++A24C              	; ; ;ld a,(#5C78)
  74++A24C              	; ; ;cp retry_rec_count_max
  75++A24C              	; ; jr nz, .wait ;ещё попытка
  76++A24C              	; ; xor a ;выключим флаг переноса если время вышло
  77++A24C              	; ; ret
  78++A24C
  79++A24C
  80++A24C
  81++A24C
  82++A24C              ; ; Blocking read
  83++A24C              ; ; A <- Byte
  84++A24C              ; ; readB:
  85++A24C                  ; ; ld a, LSR
  86++A24C                  ; ; in a, (#EF)
  87++A24C                  ; ; rrca
  88++A24C                  ; ; jr nc, readB
  89++A24C              	; ; ld a, RBR_THR
  90++A24C                  ; ; in a, (#EF)
  91++A24C                  ; ; ret
  92++A24C
  93++A24C              ; ; A -> byte to send
  94++A24C              ; write:
  95++A24C                  ; push af
  96++A24C              ; .wait
  97++A24C              	; ld a, LSR
  98++A24C                  ; in a, (#EF)
  99++A24C                  ; and #20
 100++A24C                  ; jr z, .wait
 101++A24C                  ; pop af
 102++A24C              	; ld b, RBR_THR
 103++A24C              	; ld c, #EF
 104++A24C                  ; out (c), a
 105++A24C                  ; ret
 106++A24C
 107++A24C                  ; endmodule
# file closed: drivers/zx-wifi.asm
  15+ A24C                  ENDIF
  16+ A24C
  17+ A24C                  IFDEF SMUCRTC
  18+ A24C ~                include "smuc-rtc.asm"
  19+ A24C                  ENDIF
  20+ A24C
  21+ A24C                  include "utils.asm"
# file opened: drivers/utils.asm
   1++A24C              ; ;;; Macroses!!!!
   2++A24C                  ; MACRO EspSend Text
   3++A24C                  ; ld hl, .txtB
   4++A24C                  ; ld e, (.txtE - .txtB)
   5++A24C                  ; call espSend
   6++A24C                  ; jr .txtE
   7++A24C              ; .txtB
   8++A24C                  ; db Text
   9++A24C              ; .txtE
  10++A24C                  ; ENDM
  11++A24C
  12++A24C                  ; MACRO EspCmd Text
  13++A24C                  ; ld hl, .txtB
  14++A24C                  ; ld e, (.txtE - .txtB)
  15++A24C                  ; call espSend
  16++A24C                  ; jr .txtE
  17++A24C              ; .txtB
  18++A24C                  ; db Text
  19++A24C                  ; db 13, 10
  20++A24C              ; .txtE
  21++A24C                  ; ENDM
  22++A24C
  23++A24C                  ; MACRO EspCmdOkErr text
  24++A24C                  ; EspCmd text
  25++A24C                  ; call checkOkErr
  26++A24C                  ; ENDM
  27++A24C
  28++A24C              ; IN DE - string pointer
  29++A24C              ; OUT HL - string len
  30++A24C              strLen:
  31++A24C 21 00 00         ld hl, 0
  32++A24F              .loop
  33++A24F 1A               ld a, (de)
  33++A250 A7             and a
  33++A251 C8             ret z
  34++A252 13 23            inc de, hl
  35++A254 18 F9            jr .loop
# file closed: drivers/utils.asm
  22+ A256                  include "wifi.asm"
# file opened: drivers/wifi.asm
   1++A256                  MODULE Wifi
   2++A256 00 00        bytes_avail dw 0
   3++A258 00 00        buffer_pointer dw 0
   4++A25A 01           closed db 1
   5++A25B              ;link_id db 0;
   6++A25B              wait_count equ 5*50 ; ожидание в кадрах
   7++A25B              buffer_top equ #fa;ограничение буфера сверху #ffff - 1500
   8++A25B              ; ; Initialize Wifi chip to work
   9++A25B              ;init:
  10++A25B              	;ld hl,uartGetID : call TextMode.printZ
  11++A25B              ; init1:
  12++A25B              	; halt
  13++A25B              	; xor a ;CY=0
  14++A25B              	; OS_ESP_LINK_ID ;получить номер соединения
  15++A25B              	; jr c,init1:
  16++A25B              	; ld (link_id),a
  17++A25B              	;ret
  18++A25B                  ; ; ld hl, .uartIniting : call TextMode.printZ
  19++A25B                  ; ; call Uart.init
  20++A25B                  ; ld hl, .chipIniting : call TextMode.printZ
  21++A25B                  ; EspCmdOkErr "ATE0"
  22++A25B                  ; jr c, .initError
  23++A25B
  24++A25B                  ; EspCmdOkErr "AT+CIPSERVER=0"
  25++A25B                  ; EspCmdOkErr "AT+CIPCLOSE" ; Close if there some connection was. Don't care about result
  26++A25B                  ; EspCmdOkErr "AT+CIPMUX=0" ; Single connection mode
  27++A25B                  ; jr c, .initError
  28++A25B
  29++A25B                  ; EspCmdOkErr "AT+CIPDINFO=0" ; Disable additional info
  30++A25B                  ; jr c, .initError
  31++A25B
  32++A25B                  ; ld hl, .doneInit : call TextMode.printZ
  33++A25B
  34++A25B                  ; or a
  35++A25B                  ; ret
  36++A25B              ; .initError
  37++A25B                  ; ld hl, .errMsg : call DialogBox.msgBox
  38++A25B                  ; scf
  39++A25B                  ; ret
  40++A25B              ; .errMsg db "WiFi chip init failed!",0
  41++A25B              ;.uartIniting db "Uart initing...",13,0
  42++A25B              ;uartGetID db "Get link ID...",13,0
  43++A25B              ; .chipIniting db "Chip initing...",13,0
  44++A25B              ; .doneInit    db "Done!",0
  45++A25B                  ; IFNDEF PROXY
  46++A25B              ; ; HL - host pointer in gopher row
  47++A25B              ; ; DE - port pointer in gopher row
  48++A25B              openTCP:
  49++A25B              	;ld a,(link_id)
  50++A25B              	OS_ESP_CLOSE ;если уже пытались раньше, то закрыть
  50++A25B 0E 0C       >    ld c,#0c
  50++A25D E7          >    rst #20
  51++A25E
  52++A25E 06 FA        	ld b,wait_count ; пробуем открыть
  53++A260              openTCP_wait1
  54++A260              	OS_WAIT
  54++A260 DF          >	rst #18
  55++A261 C5           	push bc
  56++A262 AF           	xor a ;TCP
  57++A263              	OS_ESP_OPEN
  57++A263 0E 0D       >    ld c,#0d
  57++A265 E7          >    rst #20
  58++A266 C1           	pop bc
  59++A267 30 03        	jr nc,openTCP_wait1_ok
  60++A269 10 F5        	djnz openTCP_wait1
  61++A26B C9           	ret ;не удалось, наверное очередь
  62++A26C              openTCP_wait1_ok
  63++A26C
  64++A26C              	;или подождём открытия
  65++A26C 06 FA        	ld b,wait_count ;
  66++A26E              openTCP_wait
  67++A26E              	OS_WAIT
  67++A26E DF          >	rst #18
  68++A26F DD 7E 02     	ld a,(ix+2) ;флаг
  69++A272 07           	rlca
  70++A273 D8           	ret c ;если ошибка (=255)
  71++A274 B7           	or a
  72++A275 20 04        	jr nz,openTCP_wait_skip
  73++A277 10 F5        	djnz openTCP_wait
  74++A279 37           	scf
  75++A27A C9           	ret
  76++A27B              openTCP_wait_skip
  77++A27B DD 7E 02     	ld a,(ix+2) ;флаг
  78++A27E EE 01        	xor 1
  79++A280 32 5A A2     	ld (closed), a
  80++A283 B7           	or a ;успешно
  81++A284 C9           	ret
  82++A285
  83++A285
  84++A285
  85++A285                  ; push de
  86++A285                  ; push hl
  87++A285                  ; EspCmdOkErr "AT+CIPCLOSE" ; Don't care about result. Just close if it didn't happens before
  88++A285                  ; EspSend 'AT+CIPSTART="TCP","'
  89++A285                  ; pop hl
  90++A285                  ; call espSendT
  91++A285                  ; EspSend '",'
  92++A285                  ; pop hl
  93++A285                  ; call espSendT
  94++A285                  ; ld a, 13 : call Uart.write
  95++A285                  ; ld a, 10 : call Uart.write
  96++A285                  ; xor a : ld (closed), a
  97++A285                  ; jp checkOkErr
  98++A285
  99++A285              ; continue:
 100++A285                  ; ret
 101++A285                  ; ENDIF
 102++A285
 103++A285
 104++A285
 105++A285              ; checkOkErr:
 106++A285                  ; call Uart.read
 107++A285                  ; cp 'O' : jr z, .okStart ; OK
 108++A285                  ; cp 'E' : jr z, .errStart ; ERROR
 109++A285                  ; cp 'F' : jr z, .failStart ; FAIL
 110++A285                  ; jr checkOkErr
 111++A285              ; .okStart
 112++A285                  ; call Uart.read : cp 'K' : jr nz, checkOkErr
 113++A285                  ; call Uart.read : cp 13  : jr nz, checkOkErr
 114++A285                  ; call .flushToLF
 115++A285                  ; or a
 116++A285                  ; ret
 117++A285              ; .errStart
 118++A285                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 119++A285                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 120++A285                  ; call Uart.read : cp 'O' : jr nz, checkOkErr
 121++A285                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 122++A285                  ; call .flushToLF
 123++A285                  ; scf
 124++A285                  ; ret
 125++A285              ; .failStart
 126++A285                  ; call Uart.read : cp 'A' : jr nz, checkOkErr
 127++A285                  ; call Uart.read : cp 'I' : jr nz, checkOkErr
 128++A285                  ; call Uart.read : cp 'L' : jr nz, checkOkErr
 129++A285                  ; call .flushToLF
 130++A285                  ; scf
 131++A285                  ; ret
 132++A285              ; .flushToLF
 133++A285                  ; call Uart.read
 134++A285                  ; cp 10 : jr nz, .flushToLF
 135++A285                  ; ret
 136++A285
 137++A285              ; ; Send buffer to UART
 138++A285              ; ; HL - buff
 139++A285              ; ; E - count
 140++A285              ; espSend:
 141++A285                  ; ld a, (hl) : call Uart.write
 142++A285                  ; inc hl
 143++A285                  ; dec e
 144++A285                  ; jr nz, espSend
 145++A285                  ; ret
 146++A285
 147++A285              ; ; HL - string that ends with one of the terminator(CR/LF/TAB/NULL)
 148++A285              ; espSendT:
 149++A285                  ; ld a, (hl)
 150++A285
 151++A285                  ; and a : ret z
 152++A285                  ; cp 9 : ret z
 153++A285                  ; cp 13 : ret z
 154++A285                  ; cp 10 : ret z
 155++A285
 156++A285                  ; call Uart.write
 157++A285                  ; inc hl
 158++A285                  ; jr espSendT
 159++A285
 160++A285              ; ; HL - stringZ to send
 161++A285              ; ; Adds CR LF
 162++A285              tcpSendZ:
 163++A285 E5           	push hl
 164++A286 EB           	ex de,hl
 165++A287 CD 4C A2     	call strLen ;узнать длину
 166++A28A EB           	ex de,hl
 167++A28B E1           	pop hl ;буфер
 168++A28C E5           	push hl
 169++A28D 19           	add hl,de ;добавить в конце 13 и 10
 170++A28E 36 0D        	ld (hl),13
 171++A290 23           	inc hl
 172++A291 36 0A        	ld (hl),10
 173++A293 E1           	pop hl
 174++A294 13           	inc de ;увеличить длину
 175++A295 13           	inc de
 176++A296
 177++A296              	;call Wifi.tcpSendZ ;послать запрос
 178++A296              	;ld a,(link_id)
 179++A296              	OS_ESP_SEND
 179++A296 0E 0E       >    ld c,#0e
 179++A298 E7          >    rst #20
 180++A299              	;ret c ;сразу не удалось (может, очередь)
 181++A299              	;ждём когда запрос пройдёт
 182++A299              	;ld b,wait_count ;
 183++A299              tcpSendZ_wait1 ;бесконечно ждём
 184++A299              	OS_WAIT
 184++A299 DF          >	rst #18
 185++A29A DD 7E 04     	ld a,(ix+4) ;флаг
 186++A29D FE 01        	cp 1
 187++A29F 20 F8        	jr nz,tcpSendZ_wait1
 188++A2A1 B7           	or a
 189++A2A2 C9           	ret
 190++A2A3
 191++A2A3
 192++A2A3                  ; push hl
 193++A2A3                  ; EspSend "AT+CIPSEND="
 194++A2A3                  ; pop de : push de
 195++A2A3                  ; call strLen
 196++A2A3                  ; inc hl : inc hl ; +CRLF
 197++A2A3                  ; call hlToNumEsp
 198++A2A3                  ; ld a, 13 : call Uart.write
 199++A2A3                  ; ld a, 10 : call Uart.write
 200++A2A3                  ; call checkOkErr : ret c
 201++A2A3              ; .wait
 202++A2A3                  ; call Uart.read : cp '>' : jr nz, .wait
 203++A2A3                  ; pop hl
 204++A2A3              ; .loop
 205++A2A3                  ; ld a, (hl) : and a : jr z, .exit
 206++A2A3                  ; call Uart.write
 207++A2A3                  ; inc hl
 208++A2A3                  ; jp .loop
 209++A2A3              ; .exit
 210++A2A3                  ; ld a, 13 : call Uart.write
 211++A2A3                  ; ld a, 10 : call Uart.write
 212++A2A3                  ; jp checkOkErr
 213++A2A3
 214++A2A3              ;вх: hl - адрес буфера
 215++A2A3              getPacket:
 216++A2A3              	;переделано под ОС
 217++A2A3 7C           	ld a,h
 218++A2A4 FE FA        	cp buffer_top ;ограничение буфера
 219++A2A6 38 10        	jr c,getPacket_skip_over ; ниже ограничения грузим
 220++A2A8 3E 01        	ld a,1 ;или прекращаем
 221++A2AA 32 5A A2     	ld (closed),a ;флаг закрытия
 222++A2AD 21 00 00     	ld hl,0
 223++A2B0 22 56 A2     	ld (bytes_avail), hl
 224++A2B3              	OS_ESP_CLOSE ;освободить очередь
 224++A2B3 0E 0C       >    ld c,#0c
 224++A2B5 E7          >    rst #20
 225++A2B6 37           	scf
 226++A2B7 C9           	ret
 227++A2B8              getPacket_skip_over
 228++A2B8
 229++A2B8              	;ld a,(link_id)
 230++A2B8              	OS_ESP_GET
 230++A2B8 0E 0F       >    ld c,#0f
 230++A2BA E7          >    rst #20
 231++A2BB              	; ret c ;сразу не удалось (может, очередь)
 232++A2BB              	; ld b,wait_count ;
 233++A2BB              getPacket_wait1
 234++A2BB              	OS_WAIT
 234++A2BB DF          >	rst #18
 235++A2BC DD 7E 06     	ld a,(ix+6) ;флаг результат приёма
 236++A2BF              	; rlca
 237++A2BF              	; ret c ;если ошибка (=255)
 238++A2BF FE 01        	cp 1
 239++A2C1 20 F8        	jr nz,getPacket_wait1
 240++A2C3
 241++A2C3
 242++A2C3              ;getPacket_wait1_skip
 243++A2C3 2A 58 A2     	ld hl,(buffer_pointer)
 244++A2C6 DD 4E 09     	ld c,(ix+9) ; длина принятого
 245++A2C9 DD 46 0A     	ld b,(ix+10)
 246++A2CC ED 43 56 A2  	ld (bytes_avail), bc
 247++A2D0 09           	add hl,bc
 248++A2D1 22 58 A2     	ld (buffer_pointer),hl ;продолжить загружать с этого места
 249++A2D4
 250++A2D4 DD 7E 02     	ld a,(ix+2) ;!!! closed
 251++A2D7 EE 01        	xor 1
 252++A2D9 32 5A A2     	ld (closed),a ;флаг закрытия
 253++A2DC 28 03        	jr z,getPacket_ex
 254++A2DE              	OS_ESP_CLOSE ;освободить очередь
 254++A2DE 0E 0C       >    ld c,#0c
 254++A2E0 E7          >    rst #20
 255++A2E1              getPacket_ex
 256++A2E1 B7           	or a
 257++A2E2 C9           	ret
 258++A2E3
 259++A2E3
 260++A2E3                  ; call Uart.read
 261++A2E3                  ; cp '+' : jr z, .ipdBegun    ; "+IPD," packet
 262++A2E3                  ; cp 'O' : jr z, .closedBegun ; It enough to check "OSED\n" :-)
 263++A2E3                  ; jr getPacket
 264++A2E3              ; .closedBegun
 265++A2E3                  ; call Uart.read : cp 'S' : jr nz, getPacket
 266++A2E3                  ; call Uart.read : cp 'E' : jr nz, getPacket
 267++A2E3                  ; call Uart.read : cp 'D' : jr nz, getPacket
 268++A2E3                  ; call Uart.read : cp 13 : jr nz, getPacket
 269++A2E3                  ; ld a, 1, (closed), a
 270++A2E3                  ; ret
 271++A2E3              ; .ipdBegun
 272++A2E3                  ; call Uart.read : cp 'I' : jr nz, getPacket
 273++A2E3                  ; call Uart.read : cp 'P' : jr nz, getPacket
 274++A2E3                  ; call Uart.read : cp 'D' : jr nz, getPacket
 275++A2E3                  ; call Uart.read ; Comma
 276++A2E3                  ; call .count_ipd_lenght : ld (bytes_avail), hl
 277++A2E3                  ; ld bc, hl
 278++A2E3                  ; ld hl, (buffer_pointer)
 279++A2E3              ; .readp
 280++A2E3                  ; ld a, h : cp #ff : jr nc, .skipbuff
 281++A2E3                  ; push bc, hl
 282++A2E3                  ; call Uart.read
 283++A2E3                  ; pop hl, bc
 284++A2E3                  ; ld (hl), a
 285++A2E3                  ; dec bc : inc hl
 286++A2E3                  ; ld a, b : or c : jr nz, .readp
 287++A2E3                  ; ld (buffer_pointer), hl
 288++A2E3                  ; ret
 289++A2E3              ; .skipbuff
 290++A2E3                  ; push bc
 291++A2E3                  ; call Uart.read
 292++A2E3                  ; pop bc
 293++A2E3                  ; dec bc : ld a, b : or c : jr nz, .skipbuff
 294++A2E3                  ; ret
 295++A2E3              ; .count_ipd_lenght
 296++A2E3              		; ld hl,0			; count lenght
 297++A2E3              ; .cil1	push  hl
 298++A2E3                      ; call Uart.read
 299++A2E3                      ; pop hl
 300++A2E3              		; cp ':' : ret z
 301++A2E3              		; sub 0x30 : ld c,l : ld b,h : add hl,hl : add hl,hl : add hl,bc : add hl,hl : ld c,a : ld b,0 : add hl,bc
 302++A2E3              		; jr .cil1
 303++A2E3
 304++A2E3              ; ; Based on: https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
 305++A2E3              ; ; HL - number
 306++A2E3              ; ; It will be written to UART
 307++A2E3              ; hlToNumEsp:
 308++A2E3              	; ld	bc,-10000
 309++A2E3              	; call	.n1
 310++A2E3              	; ld	bc,-1000
 311++A2E3              	; call	.n1
 312++A2E3              	; ld	bc,-100
 313++A2E3              	; call	.n1
 314++A2E3              	; ld	c,-10
 315++A2E3              	; call	.n1
 316++A2E3              	; ld	c,-1
 317++A2E3              ; .n1	ld	a,'0'-1
 318++A2E3              ; .n2	inc	a
 319++A2E3              	; add	hl,bc
 320++A2E3              	; jr	c, .n2
 321++A2E3              	; sbc	hl,bc
 322++A2E3                  ; push bc
 323++A2E3              	; call Uart.write
 324++A2E3                  ; pop bc
 325++A2E3                  ; ret
 326++A2E3
 327++A2E3                  ENDMODULE
# file closed: drivers/wifi.asm
  23+ A2E3                  include "proxy.asm"
# file opened: drivers/proxy.asm
   1++A2E3                  IFDEF PROXY
   2++A2E3 ~                MODULE Wifi
   3++A2E3 ~            ; Same singature as wifi.openTCP
   4++A2E3 ~            ; HL - host pointer in gopher row
   5++A2E3 ~            ; DE - port pointer in gopher row
   6++A2E3 ~            openTCP:
   7++A2E3 ~                push de
   8++A2E3 ~                push hl
   9++A2E3 ~
  10++A2E3 ~                xor a
  10++A2E3 ~              ld hl, hostBuff, de, hostBuff + 1, bc, 102, (hl), a
  10++A2E3 ~              ldir
  11++A2E3 ~
  12++A2E3 ~                EspCmdOkErr "AT+CIPCLOSE"
  13++A2E3 ~                EspCmdOkErr 'AT+CIPSTART="TCP","138.68.76.243",6912' // Replace here for yourown proxy. If you wish
  14++A2E3 ~                jr c, .error
  15++A2E3 ~                pop hl
  15++A2E3 ~              ld de, hostBuff
  16++A2E3 ~            .copyHost
  17++A2E3 ~                ld a, (hl)
  17++A2E3 ~              and a
  17++A2E3 ~              jr z, 1F
  17++A2E3 ~              and a
  17++A2E3 ~              jr z, 1F
  18++A2E3 ~                ld (de), a
  18++A2E3 ~              inc hl, de
  19++A2E3 ~                jr .copyHost
  20++A2E3 ~            1   xor a
  20++A2E3 ~              ld (de), a
  21++A2E3 ~                pop hl
  21++A2E3 ~              ld de, portBuff
  22++A2E3 ~            .copyPort
  23++A2E3 ~                ld a, (hl)
  23++A2E3 ~              and a
  23++A2E3 ~              jr z, 1F
  23++A2E3 ~              and a
  23++A2E3 ~              jr z, 1F
  24++A2E3 ~                ld (de), a
  24++A2E3 ~              inc hl, de
  25++A2E3 ~                jr .copyPort
  26++A2E3 ~            1   ld hl, hostBuff
  26++A2E3 ~              call tcpSendZ
  27++A2E3 ~                ld hl, portBuff
  27++A2E3 ~              call tcpSendZ
  28++A2E3 ~                xor a
  28++A2E3 ~              ld (closed), a
  29++A2E3 ~                ret
  30++A2E3 ~            .error
  31++A2E3 ~                pop hl
  31++A2E3 ~              pop de
  32++A2E3 ~                ret
  33++A2E3 ~
  34++A2E3 ~            continue:
  35++A2E3 ~                EspCmdOkErr "AT+CIPSEND=1"
  36++A2E3 ~                ret c
  37++A2E3 ~            .wait
  38++A2E3 ~                call Uart.read
  38++A2E3 ~              cp '>'
  38++A2E3 ~              jr nz, .wait
  39++A2E3 ~                ld a, 'c'
  39++A2E3 ~              call Uart.write
  40++A2E3 ~                jp checkOkErr
  41++A2E3 ~
  42++A2E3 ~            hostBuff ds 96
  43++A2E3 ~            portBuff ds 7
  44++A2E3 ~                ENDMODULE
  45++A2E3                  ENDIF
# file closed: drivers/proxy.asm
  24+ A2E3                  include "memory.asm"
# file opened: drivers/memory.asm
   1++A2E3                  module Memory
   2++A2E3              BANKM = #5b5c
   3++A2E3              MEM_PORT = #7ffd
   4++A2E3
   5++A2E3              init:
   6++A2E3 F3               di
   7++A2E4 FD CB 01 A6      res 4, (iy + 1)
   8++A2E8
   9++A2E8 AF               xor a
   9++A2E9 CD ED A2       call setPage
  10++A2EC C9               ret
  11++A2ED
  12++A2ED              ; a - page
  13++A2ED              setPage:
  14++A2ED F6 18            or #18
  14++A2EF 32 5C 5B       ld (BANKM), a
  15++A2F2 01 FD 7F         ld bc, MEM_PORT
  15++A2F5 ED 79          out (c), a
  16++A2F7 C9               ret
  17++A2F8
  18++A2F8                  endmodule
# file closed: drivers/memory.asm
  25+ A2F8                  include "general-sound.asm"
# file opened: drivers/general-sound.asm
   1++A2F8                  ifdef GS
   2++A2F8                  macro _WaitCommand
   3++A2F8 ~            .wait
   4++A2F8 ~                in a, (GeneralSound.CMD)
   5++A2F8 ~                rrca
   6++A2F8 ~                jr c, .wait
   7++A2F8                  endm
   8++A2F8
   9++A2F8                  macro _WaitData
  10++A2F8 ~            .wait
  11++A2F8 ~                in a, (GeneralSound.CMD)
  12++A2F8 ~                rlca
  13++A2F8 ~                jr c, .wait
  14++A2F8                  endm
  15++A2F8
  16++A2F8                  macro _SendCommand nn
  17++A2F8 ~                ld a, nn
  17++A2F8 ~              out (GeneralSound.CMD), a
  18++A2F8                  endm
  19++A2F8
  20++A2F8                  module GeneralSound
  21++A2F8              ;; Control ports
  22++A2F8              CMD  = 187
  23++A2F8              DATA = 179
  24++A2F8
  25++A2F8              ;; Commands
  26++A2F8              CMD_WARM_RESET      = #F3
  27++A2F8              CMD_COLD_RESET      = #F4
  28++A2F8              CMD_LOAD_MODULE     = #30
  29++A2F8              CMD_PLAY_MODULE     = #31
  30++A2F8              CMD_STOP_MODULE     = #32
  31++A2F8              CMD_CONTINUE_MODULE = #33
  32++A2F8              CMD_OPEN_STREAM     = #D1
  33++A2F8              CMD_CLOSE_STREAM    = #D2
  34++A2F8
  35++A2F8              ; A - 0 warm reset, other - cold
  36++A2F8              init:
  37++A2F8 A7               and a
  37++A2F9 20 05          jr nz, .cold
  38++A2FB                  _SendCommand CMD_WARM_RESET
  38++A2FB 3E F3       >    ld a, CMD_WARM_RESET
  38++A2FD D3 BB       >  out (GeneralSound.CMD), a
  39++A2FF C9               ret
  40++A300              .cold
  41++A300                  _SendCommand CMD_COLD_RESET
  41++A300 3E F4       >    ld a, CMD_COLD_RESET
  41++A302 D3 BB       >  out (GeneralSound.CMD), a
  42++A304 C9               ret
  43++A305
  44++A305              ;; Initializes loading module
  45++A305              loadModule:
  46++A305                  _SendCommand CMD_LOAD_MODULE
  46++A305 3E 30       >    ld a, CMD_LOAD_MODULE
  46++A307 D3 BB       >  out (GeneralSound.CMD), a
  47++A309                  _WaitCommand
  47++A309             >.wait
  47++A309 DB BB       >    in a, (GeneralSound.CMD)
  47++A30B 0F          >    rrca
  47++A30C 38 FB       >    jr c, .wait
  48++A30E                  _SendCommand CMD_OPEN_STREAM
  48++A30E 3E D1       >    ld a, CMD_OPEN_STREAM
  48++A310 D3 BB       >  out (GeneralSound.CMD), a
  49++A312                  _WaitCommand
  49++A312             >.wait
  49++A312 DB BB       >    in a, (GeneralSound.CMD)
  49++A314 0F          >    rrca
  49++A315 38 FB       >    jr c, .wait
  50++A317 C9               ret
  51++A318
  52++A318              ;; Use it for streaming mod file
  53++A318              sendByte:
  54++A318 D3 B3            out (DATA), a
  55++A31A                  _WaitData
  55++A31A             >.wait
  55++A31A DB BB       >    in a, (GeneralSound.CMD)
  55++A31C 07          >    rlca
  55++A31D 38 FB       >    jr c, .wait
  56++A31F C9               ret
  57++A320
  58++A320              ;; Call it when module was loaded
  59++A320              finishLoadingModule:
  60++A320                  _SendCommand CMD_CLOSE_STREAM
  60++A320 3E D2       >    ld a, CMD_CLOSE_STREAM
  60++A322 D3 BB       >  out (GeneralSound.CMD), a
  61++A324                  _WaitCommand
  61++A324             >.wait
  61++A324 DB BB       >    in a, (GeneralSound.CMD)
  61++A326 0F          >    rrca
  61++A327 38 FB       >    jr c, .wait
  62++A329              rewind:
  63++A329 3E 01            ld a, 1
  63++A32B D3 B3          out (DATA), a
  64++A32D                  _SendCommand CMD_PLAY_MODULE
  64++A32D 3E 31       >    ld a, CMD_PLAY_MODULE
  64++A32F D3 BB       >  out (GeneralSound.CMD), a
  65++A331                  _WaitCommand
  65++A331             >.wait
  65++A331 DB BB       >    in a, (GeneralSound.CMD)
  65++A333 0F          >    rrca
  65++A334 38 FB       >    jr c, .wait
  66++A336 3E 01 32 5A      ld a, 1, (state),a
  66++A33A A3
  67++A33B C9               ret
  68++A33C
  69++A33C              ;; Works like pause too
  70++A33C              stopModule:
  71++A33C AF               xor a
  71++A33D 32 5A A3       ld (state), a
  72++A340                  _SendCommand CMD_STOP_MODULE
  72++A340 3E 32       >    ld a, CMD_STOP_MODULE
  72++A342 D3 BB       >  out (GeneralSound.CMD), a
  73++A344 C9               ret
  74++A345
  75++A345              continueModule:
  76++A345 3E 01            ld a, 1
  76++A347 32 5A A3       ld (state), a
  77++A34A                  _SendCommand CMD_CONTINUE_MODULE
  77++A34A 3E 33       >    ld a, CMD_CONTINUE_MODULE
  77++A34C D3 BB       >  out (GeneralSound.CMD), a
  78++A34E C9               ret
  79++A34F
  80++A34F              ; Pauses resumes
  81++A34F              toggleModule:
  82++A34F CD A0 86         call Console.waitForKeyUp
  83++A352 3A 5A A3         ld a, (state)
  83++A355 A7             and a
  84++A356 28 ED            jr z, continueModule
  85++A358 18 E2            jr stopModule
  86++A35A
  87++A35A 00           state db 0
  88++A35B                  endmodule
  89++A35B
  90++A35B                  endif
# file closed: drivers/general-sound.asm
  26+ A35B
# file closed: drivers/index.asm
  29  A35B              start:
  30  A35B              	; IFDEF TRD
  31  A35B              	; align 256 ;временно
  32  A35B              	; ENDIF
  33  A35B              outputBuffer: ;equ #c000
  34  A35B                  ;di
  35  A35B                  ;xor a : ld (#5c6a), a  ; Thank you, Mario Prato, for feedback
  36  A35B                  ;ld (#5c00),a
  37  A35B                  ;ld sp, asmOrg
  38  A35B                  ;call Memory.init
  39  A35B                  ;xor a : out (#fe),a
  40  A35B                  ;ei
  41  A35B
  42  A35B                  ;ld a, 7 : call Memory.setPage
  43  A35B                  ;; Logo
  44  A35B                  ; ld hl, logo, b, Dos.FMODE_READ : call Dos.fopen
  45  A35B                  ; push af
  46  A35B                  ; ld hl, #c000, bc, 6912 : call Dos.fread
  47  A35B                  ; pop af
  48  A35B                  ; call Dos.fclose
  49  A35B
  50  A35B              	; ifdef ZSGMX
  51  A35B              	; call TextMode.disable
  52  A35B              	; endif
  53  A35B
  54  A35B                  ; ld b, 50
  55  A35B              ; 1   halt
  56  A35B                  ; djnz 1b
  57  A35B                  ;; End of logo :-)
  58  A35B
  59  A35B CD 03 80         call TextMode.init
  60  A35E
  61  A35E                  ; ld hl, initing : call TextMode.printZ
  62  A35E                  ; IFNDEF EMU
  63  A35E                  ; call Wifi.init
  64  A35E                  ; ENDIF
  65  A35E
  66  A35E C3 1F 87         jp History.home
  67  A361
  68  A361              ;initing db "Initing Wifi...",13,0
  69  A361 64 61 74 61  logo    db  "data/logo.scr", 0
  69  A365 2F 6C 6F 67
  69  A369 6F 2E 73 63
  69  A36D 72 00
  70  A36F                  display "ENDS: ", $
  71  A36F                  display "Buff size", #ffff - $
  72  A36F
  73  A36F                  ;IFDEF ESX
  74  A36F                  ;save3dos "moon.bin", asmOrg, $ - asmOrg
  75  A36F                  savebin "moonr.apg", asmOrg, $ - asmOrg
  76  A36F              	;ELSE
  77  A36F                  ;SAVETRD "MOONR.TRD",|"moon.C",asmOrg, $ - asmOrg
  78  A36F                  ;ENDIF
# file closed: main.asm
