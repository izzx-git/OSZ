# file opened: main.asm
   1  0000                  device	zxspectrum128
   2  0000              	include "../os_defs.asm"
# file opened: ../os_defs.asm
   1+ 0000              ;Список всех вызовов (функций) ОС GMX
   2+ 0000
   3+ 0000              ;Включить в свой код (в начале файла):
   4+ 0000              	; include os_defs.asm
   5+ 0000
   6+ 0000              ;Использовать только имена функций, коды могут поменяться
   7+ 0000
   8+ 0000              ;например:
   9+ 0000              	; org PROGSTART
  10+ 0000              	; ../include os_defs.asm
  11+ 0000              	; ld hl,text
  12+ 0000              	; OS_PRINTZ ;печать	до кода 0
  13+ 0000
  14+ 0000              ;сохранность регистров не гарантируется
  15+ 0000              ;на выходе обычно (но не всегда) CY=1 = ошибка
  16+ 0000
  17+ 0000              PROGSTART equ #8000 ;адрес старта приложений
  18+ 0000
  19+ 0000
  20+ 0000              ;короткие вызовы (именные RST) -------------------------
  21+ 0000
  22+ 0000              ;печать символа в консоль (ускоренная)
  23+ 0000              	MACRO OS_PRINT_CHARF ;a=char
  24+ 0000 ~            	rst #10
  25+ 0000              	ENDM
  26+ 0000
  27+ 0000
  28+ 0000              ;передача управления ОС до следующего прерывания (когда придёт очередь процесса в следующий раз);
  29+ 0000              ;все регистры сохраняются
  30+ 0000              ;рекомендуется использовать вместо обычного halt
  31+ 0000              	MACRO OS_WAIT
  32+ 0000 ~            	rst #18
  33+ 0000              	ENDM
  34+ 0000
  35+ 0000              	; MACRO OS_
  36+ 0000              	; rst #28
  37+ 0000              	; ENDM
  38+ 0000
  39+ 0000              	; MACRO OS_
  40+ 0000              	; rst #30
  41+ 0000              	; ENDM
  42+ 0000
  43+ 0000
  44+ 0000
  45+ 0000              ;вызовы через единую точку входа RST #20 ----------------
  46+ 0000
  47+ 0000              ;вывод в консоль --------------------
  48+ 0000
  49+ 0000              ;очистить консоль
  50+ 0000              	macro OS_CLS ;clear visible area of terminal
  51+ 0000 ~                ld c,#00
  52+ 0000 ~                rst #20
  53+ 0000                  endm
  54+ 0000
  55+ 0000              ;установить позицию курсора в консоли
  56+ 0000                  macro OS_SET_XY ;de=yx ;SET CURSOR POSITION
  57+ 0000 ~                ld c,#01
  58+ 0000 ~                rst #20
  59+ 0000                  endm
  60+ 0000
  61+ 0000              ;печать символа в консоль
  62+ 0000                  macro OS_PRINT_CHAR ;a=char
  63+ 0000 ~                ld c,#02
  64+ 0000 ~                rst #20
  65+ 0000                  endm
  66+ 0000
  67+ 0000              ;заполнение строки одним символом
  68+ 0000                  macro OS_FILL_LINE ;; H - line ; A - char
  69+ 0000 ~                ld c,#03
  70+ 0000 ~                rst #20
  71+ 0000                  endm
  72+ 0000
  73+ 0000              ;покрасить строку цветом
  74+ 0000                  macro OS_PAINT_LINE ;a - line, b - color
  75+ 0000 ~                ld c,#04
  76+ 0000 ~                rst #20
  77+ 0000                  endm
  78+ 0000
  79+ 0000
  80+ 0000                  ; macro OS_ ;
  81+ 0000                  ; ld c,#05
  82+ 0000                  ; rst #20
  83+ 0000                  ; endm
  84+ 0000
  85+ 0000              ;установить цвет текста в консоли;
  86+ 0000                  macro OS_SET_COLOR ;a = color, b = color 2 (highlight)
  87+ 0000 ~                ld c,#06
  88+ 0000 ~                rst #20
  89+ 0000                  endm
  90+ 0000
  91+ 0000                  ; macro OS_ ;
  92+ 0000                  ; ld c,#07
  93+ 0000                  ; rst #20
  94+ 0000                  ; endm
  95+ 0000
  96+ 0000                  ; macro OS_ ;
  97+ 0000                  ; ld c,#08
  98+ 0000                  ; rst #20
  99+ 0000                  ; endm
 100+ 0000
 101+ 0000
 102+ 0000
 103+ 0000              ;печать в консоль до кода 0
 104+ 0000                  macro OS_PRINTZ ;hl=text ;PRINT to 0
 105+ 0000 ~                ld c,#09
 106+ 0000 ~                rst #20
 107+ 0000                  endm
 108+ 0000
 109+ 0000
 110+ 0000              ;прочитать байт из порта uart
 111+ 0000              ;вх:
 112+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart или нет данных для приёма
 113+ 0000              ;вых: A - считанный байт
 114+ 0000                  macro OS_UART_READ
 115+ 0000 ~                ld c,#0a
 116+ 0000 ~                rst #20
 117+ 0000                  endm
 118+ 0000
 119+ 0000              ;записать байт в порт uart
 120+ 0000              ;вх: A -байт
 121+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 122+ 0000                  macro OS_UART_WRITE
 123+ 0000 ~                ld c,#0b
 124+ 0000 ~                rst #20
 125+ 0000                  endm
 126+ 0000
 127+ 0000              ;закрыть соединение ESP
 128+ 0000              ;вх:
 129+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 130+ 0000                  macro OS_ESP_CLOSE
 131+ 0000 ~                ld c,#0c
 132+ 0000 ~                rst #20
 133+ 0000                  endm
 134+ 0000
 135+ 0000              ;установить соединение ESP (CIPSTART);
 136+ 0000              ;вх: a - тип соединения 0-tcp, 1-udp, 2-ssl; 3-прямое соединение с портом; hl - строка адрес, de - строка порт
 137+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 138+ 0000              ;вых: ix - адрес в таблице соединений (ix+2 - флаг открытия =1 - открыто, 255 - ошибка);
 139+ 0000                  macro OS_ESP_OPEN
 140+ 0000 ~                ld c,#0d
 141+ 0000 ~                rst #20
 142+ 0000                  endm
 143+ 0000
 144+ 0000              ;послать запрос ESP (CIPSEND);
 145+ 0000              ;вх: hl - адрес данных, de - длина данных
 146+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 147+ 0000              ;вых: ix - адрес в таблице соединений (ix+4 - флаг =1 - отправлено, 255 - ошибка)
 148+ 0000                  macro OS_ESP_SEND
 149+ 0000 ~                ld c,#0e
 150+ 0000 ~                rst #20
 151+ 0000                  endm
 152+ 0000
 153+ 0000              ;получить пакет ESP (+IPD);
 154+ 0000              ;вх: hl - адрес для данных
 155+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 156+ 0000              ;вых: ix - адрес в таблице соединений (ix+6 - флаг =1 - принято, 255 - ошибка)
 157+ 0000                  macro OS_ESP_GET
 158+ 0000 ~                ld c,#0f
 159+ 0000 ~                rst #20
 160+ 0000                  endm
 161+ 0000
 162+ 0000              ;ввод с консоли ----------------------
 163+ 0000
 164+ 0000              ;получить код нажатой клавиши
 165+ 0000                  macro OS_GET_CHAR ;read char from stdin (out: A=char, 255-no char)
 166+ 0000 ~                ld c,#10
 167+ 0000 ~                rst #20
 168+ 0000                  endm
 169+ 0000
 170+ 0000
 171+ 0000              ;процессы ----------------------------
 172+ 0000
 173+ 0000              ;запустить процесс
 174+ 0000              ;вх: hl - имя файла (заканчивается на 0)
 175+ 0000                  macro OS_PROC_RUN ;
 176+ 0000 ~                ld c,#11
 177+ 0000 ~                rst #20
 178+ 0000                  endm
 179+ 0000
 180+ 0000              ;установить фокус
 181+ 0000              ;вх: a - id процесса
 182+ 0000                  macro OS_PROC_SET_FOCUS ;
 183+ 0000 ~                ld c,#12
 184+ 0000 ~                rst #20
 185+ 0000                  endm
 186+ 0000
 187+ 0000              ;закрыть процесс
 188+ 0000              ;вх: A - ID процесса. Если A=0, закрыть текущий (себя)
 189+ 0000              ;останавливается процесс и освобождаются все его страницы памяти, файлы, соединения
 190+ 0000                  macro OS_PROC_CLOSE ;
 191+ 0000 ~                ld c,#13
 192+ 0000 ~                rst #20
 193+ 0000                  endm
 194+ 0000
 195+ 0000
 196+ 0000              ;прерывания --------------------------
 197+ 0000
 198+ 0000              ;установка адреса обработчика прерываний процесса;
 199+ 0000                  ; macro OS_SET_INTER ;(HL - address, A = 1 - On, A = 0 - Off)
 200+ 0000                  ; ld c,#14
 201+ 0000                  ; rst #20
 202+ 0000                  ; endm
 203+ 0000
 204+ 0000
 205+ 0000              ;плеер AY ----------------------------
 206+ 0000
 207+ 0000              ;инициализация плеера AY;
 208+ 0000                  macro OS_VTPL_INIT ;(HL - address music)
 209+ 0000 ~                ld c,#15
 210+ 0000 ~                rst #20
 211+ 0000                  endm
 212+ 0000
 213+ 0000              ;запустить плеер AY (система будет сама вызывать его каждое прерывание);
 214+ 0000                  macro OS_VTPL_PLAY ;()
 215+ 0000 ~                ld c,#16
 216+ 0000 ~                rst #20
 217+ 0000                  endm
 218+ 0000
 219+ 0000              ;заглушить плеер AY;
 220+ 0000                  macro OS_VTPL_MUTE ;()
 221+ 0000 ~                ld c,#17
 222+ 0000 ~                rst #20
 223+ 0000                  endm
 224+ 0000
 225+ 0000              ;получить значение переменной плеера;
 226+ 0000                  macro OS_GET_VTPL_SETUP ;(out: HL - setup address)
 227+ 0000 ~                ld c,#18
 228+ 0000 ~                rst #20
 229+ 0000                  endm
 230+ 0000
 231+ 0000
 232+ 0000              ;прочие ------------------------------
 233+ 0000
 234+ 0000
 235+ 0000              ;скопировать данные из страницы в страницу
 236+ 0000              ;вх: hl - откуда (абсолютный адрес 0-ffff); de - куда; ix - длина; a - страница слот2; b - страница слот3;
 237+ 0000                  macro OS_RAM_COPY
 238+ 0000 ~                ld c,#19
 239+ 0000 ~                rst #20
 240+ 0000                  endm
 241+ 0000
 242+ 0000              ;получить дополнительную страницу памяти;
 243+ 0000                  macro OS_GET_PAGE ;(out A - number page)
 244+ 0000 ~                ld c,#1a
 245+ 0000 ~                rst #20
 246+ 0000                  endm
 247+ 0000
 248+ 0000              ;включить страницу в слот 2 (#8000); предварительно зарезервировать страницу OS_GET_PAGE
 249+ 0000                  macro OS_SET_PAGE_SLOT2 ;(A - page number)
 250+ 0000 ~                ld c,#1b
 251+ 0000 ~                rst #20
 252+ 0000                  endm
 253+ 0000
 254+ 0000              ;включить страницу в слот 3 (#C000); предварительно зарезервировать страницу OS_GET_PAGE
 255+ 0000                  macro OS_SET_PAGE_SLOT3 ;(A - page number)
 256+ 0000 ~                ld c,#1c
 257+ 0000 ~                rst #20
 258+ 0000                  endm
 259+ 0000
 260+ 0000              ;включить экран N;
 261+ 0000              ;вх: A - номер экрана (5, 7, #39, #3a; 0 = текстовый)
 262+ 0000              ;переключать может только приложение в фокусе
 263+ 0000              ;если режим не текстовый, то приложение работает только когда в фокусе. Иначе временно останавливается.
 264+ 0000              ;при переключении процессов сохраняется только экран #39
 265+ 0000                  macro OS_SET_SCREEN ;
 266+ 0000 ~                ld c,#1d
 267+ 0000 ~                rst #20
 268+ 0000                  endm
 269+ 0000
 270+ 0000
 271+ 0000              ;получить номера страниц процесса;
 272+ 0000              ;вх:
 273+ 0000              ;вых: b, c - страницы в слотах 2, 3
 274+ 0000                  macro OS_GET_MAIN_PAGES ;
 275+ 0000 ~                ld c,#1e
 276+ 0000 ~                rst #20
 277+ 0000                  endm
 278+ 0000
 279+ 0000              ;получить значение системного таймера
 280+ 0000                  macro OS_GET_TIMER ;(out: HL, DE - timer)
 281+ 0000 ~                ld c,#1F
 282+ 0000 ~                rst #20
 283+ 0000                  endm
 284+ 0000
 285+ 0000
 286+ 0000
 287+ 0000                  ; macro OS_ ;
 288+ 0000                  ; ld c,#20
 289+ 0000                  ; rst #20
 290+ 0000                  ; endm
 291+ 0000
 292+ 0000
 293+ 0000              ;дисковые операции -------------------
 294+ 0000
 295+ 0000              ;открыть файл для чтения или записи
 296+ 0000                  macro OS_FILE_OPEN ;HL - File name (out: A - id file, bc, de - size)
 297+ 0000 ~                ld c,#21
 298+ 0000 ~                rst #20
 299+ 0000                  endm
 300+ 0000
 301+ 0000              ;создать файл
 302+ 0000                  macro OS_FILE_CREATE ;HL - File name  (out: A - id file)
 303+ 0000 ~                ld c,#22
 304+ 0000 ~                rst #20
 305+ 0000                  endm
 306+ 0000
 307+ 0000              ;прочитать из файла
 308+ 0000                  macro OS_FILE_READ ;HL - address, A - id file, DE - length (out: bc - size readed)
 309+ 0000 ~                ld c,#23
 310+ 0000 ~                rst #20
 311+ 0000                  endm
 312+ 0000
 313+ 0000              ;записать в файл
 314+ 0000                  macro OS_FILE_WRITE ;HL - address, A - id file, DE - length (out: bc - size writed)
 315+ 0000 ~                ld c,#24
 316+ 0000 ~                rst #20
 317+ 0000                  endm
 318+ 0000
 319+ 0000              ;закрыть файл
 320+ 0000                  macro OS_FILE_CLOSE ;A - id file
 321+ 0000 ~                ld c,#25
 322+ 0000 ~                rst #20
 323+ 0000                  endm
 324+ 0000
 325+ 0000              ;чтение секторов текущего каталога
 326+ 0000              ; вх:
 327+ 0000                   ; hl - буфер для чтения
 328+ 0000                   ; de - относительный номер первого сектора каталога для чтения [0..nn]
 329+ 0000                   ; b - максимальное количество секторов для чтения
 330+ 0000              ; вых: cy=1, если были ошибки, код ошибки возвращается в аккумуляторе
 331+ 0000                     ; a=errRWnum
 332+ 0000                     ; a=errInvalidPart
 333+ 0000                     ; a=errFileEmpty
 334+ 0000                   ; cy=0, a=errEoF - каталог закончился
 335+ 0000                     ; hl - следующий адрес в буфере
 336+ 0000                     ; de - номер первого непрочитанного сектора
 337+ 0000                     ; b - не прочитано секторов
 338+ 0000                   ; cy=0 - считано успешно
 339+ 0000                     ; hl - следующий адрес в буфере
 340+ 0000                     ; de - номер первого непрочитанного сектора
 341+ 0000                     ; b=#00
 342+ 0000                  macro OS_READ_DIR ;
 343+ 0000 ~                ld c,#26
 344+ 0000 ~                rst #20
 345+ 0000                  endm
 346+ 0000
 347+ 0000              ;вход в каталог/выход в родительский каталог
 348+ 0000              	; Если путь не указан производится только настройка переменных драйвера,
 349+ 0000              	; при этом если передан дескриптор файла, текущий каталог не изменится)
 350+ 0000              	; Если пусть указан, в конец пути добавится название каталога (если это
 351+ 0000              	; переход в родительский, последнее имя в пути удалится).
 352+ 0000              	; Если передан дескриптор файла, текущий каталог не изменится, к пути
 353+ 0000              	; добавится имя файла
 354+ 0000              ; вх:
 355+ 0000                   ; hl - адрес пути (=#0000 - путь отсутствует)
 356+ 0000                   ; de - адрес дескриптора директории/файла
 357+ 0000              ; вых: a - если путь был указан, новая длина пути
 358+ 0000                  macro OS_OPEN_DIR ;
 359+ 0000 ~                ld c,#27
 360+ 0000 ~                rst #20
 361+ 0000                  endm
 362+ 0000
 363+ 0000
 364+ 0000                  ; macro OS_ ;
 365+ 0000                  ; ld c,#28
 366+ 0000                  ; rst #20
 367+ 0000                  ; endm
 368+ 0000
 369+ 0000                  ; macro OS_ ;
 370+ 0000                  ; ld c,#29
 371+ 0000                  ; rst #20
 372+ 0000                  ; endm
 373+ 0000
 374+ 0000
# file closed: ../os_defs.asm
   3  0000                  org PROGSTART
   4  8000              asmOrg:
   5  8000 C3 5F A3         jp start
   6  8003
   7  8003              ; Generate version string
   8  8003                  LUA ALLPASS
   9  8003 ~                v = tostring(sj.get_define("V"))
  10  8003 ~                maj = string.sub(v, 1,1)
  11  8003 ~                min = string.sub(v, 2,2)
  12  8003 ~                sj.insert_define("VERSION_STRING", "\"" .. maj .. "." .. min .. "\"")
  13  8003                  ENDLUA
  14  8003
  15  8003                  include "vdp/index.asm"
# file opened: vdp/index.asm
   1+ 8003                  IFDEF TIMEX
   2+ 8003 ~                include "timex.asm"
   3+ 8003                  ENDIF
   4+ 8003
   5+ 8003                  IFDEF TIMEX80
   6+ 8003 ~                include "timex80.asm"
   7+ 8003                  ENDIF
   8+ 8003
   9+ 8003                  IFDEF ZXSCR
  10+ 8003 ~                include "zx.asm"
  11+ 8003                  ENDIF
  12+ 8003
  13+ 8003                  IFDEF ZSGMX
  14+ 8003                  include "zsgmx.asm"
# file opened: vdp/zsgmx.asm
   1++8003              COLOR=1
   2++8003              ;; ZS GMX screen driver (izzx)
   3++8003              	;define LINE_LIMIT 80
   4++8003                  module TextMode
   5++8003              init:
   6++8003                  ; ld hl, font_file, b, Dos.FMODE_READ
   7++8003                  ; call Dos.fopen
   8++8003                  ; push af
   9++8003                  ; ld bc, 2048, hl, font
  10++8003                  ; call Dos.fread
  11++8003                  ; pop af
  12++8003                  ; call Dos.fclose
  13++8003              	; xor a : out (#fe), a
  14++8003              	; call cls
  15++8003              	; ret
  16++8003              cls:
  17++8003              	OS_CLS
  17++8003 0E 00       >    ld c,#00
  17++8005 E7          >    rst #20
  18++8006 C9           	ret
  19++8007                  ; ld de, 0 : call gotoXY
  20++8007                  ; ;ld a, 7 : call Memory.setPage
  21++8007              	; ld a,#3b
  22++8007              	; call PageSlot3 ;включить страницу пикселей
  23++8007                  ; xor a : out (#fe), a
  24++8007                  ; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  25++8007              	; ld a,#7b
  26++8007              	; call PageSlot3 ;включить страницу атрибутов
  27++8007              	; ld a,(attr_screen) ;цвет
  28++8007              	; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  29++8007              	; call gmxscron ;включить расширенный экран
  30++8007              	; xor a
  31++8007              	; jp PageSlot3 ;вернуть страницу 0
  32++8007                  ;jp Memory.setPage
  33++8007
  34++8007
  35++8007              ; Set console coordinates
  36++8007              ; d = row(0..23), e = column (0..79)
  37++8007              gotoXY:
  38++8007              	OS_SET_XY
  38++8007 0E 01       >    ld c,#01
  38++8009 E7          >    rst #20
  39++800A              	;rr e
  40++800A              	; ld a, 0
  41++800A              	; ld (half_tile_screen), a
  42++800A                  ;ld (col_screen), de
  43++800A C9               ret
  44++800B
  45++800B              disable:
  46++800B                  ; Nothing to disable
  47++800B              	;call gmxscroff ;выключить расширенный экран
  48++800B C9               ret
  49++800C
  50++800C              ; H - line
  51++800C              ; A - char
  52++800C              fillLine: ;заполнение строки одним символом
  53++800C              	OS_FILL_LINE
  53++800C 0E 03       >    ld c,#03
  53++800E E7          >    rst #20
  54++800F C9           	ret
  55++8010                  ; push af
  56++8010                  ; ld d, h, e, 0 : call gotoXY
  57++8010                  ; pop af
  58++8010                  ; ld hl, fill_buff, de, fill_buff + 1, bc, 80-1, (hl), a : ldir
  59++8010                  ; ld hl, fill_buff : jp printZ
  60++8010
  61++8010              usualLine: ;на входе в A номер строки, которую надо покрасить обычным цветом
  62++8010 06 07        	ld b,#07 ;цвет
  63++8012              	OS_PAINT_LINE
  63++8012 0E 04       >    ld c,#04
  63++8014 E7          >    rst #20
  64++8015 C9           	ret
  65++8016                  ; ld b, a
  66++8016                  ; ld c, 0
  67++8016                  ; call bc_to_attr
  68++8016                  ; ;ld a, 7 : call Memory.setPage
  69++8016              	; push hl
  70++8016              	; ld a,#7b ;атрибуты
  71++8016              	; call PageSlot3
  72++8016              	; pop hl
  73++8016              	; ld a,(attr_screen) ;цвет
  74++8016                  ; ld (hl), a
  75++8016                  ; ld de, hl
  76++8016                  ; inc de
  77++8016                  ; ld bc, (80*8)-1
  78++8016                  ; ldir
  79++8016                  ; xor a : ;jp Memory.setPage
  80++8016              	; jp PageSlot3 ;вернуть страницу 0
  81++8016
  82++8016              highlightLine: ;на входе в A номер строки, которую надо покрасить другим цветом
  83++8016 06 0C        	ld b,#0c ;цвет
  84++8018              	OS_PAINT_LINE
  84++8018 0E 04       >    ld c,#04
  84++801A E7          >    rst #20
  85++801B C9           	ret
  86++801C                  ; ld b, a
  87++801C                  ; ld c, 0
  88++801C                  ; call bc_to_attr
  89++801C                  ; ;ld a, 7 : call Memory.setPage
  90++801C              	; push hl
  91++801C              	; ld a,#7b ;атрибуты
  92++801C              	; call PageSlot3
  93++801C              	; pop hl
  94++801C              	; ld a,(attr_screen2) ;цвет
  95++801C                  ; ld (hl), a
  96++801C                  ; ld de, hl
  97++801C                  ; inc de
  98++801C                  ; ld bc, (80*8)-1
  99++801C                  ; ldir
 100++801C                  ; xor a : ;jp Memory.setPage
 101++801C              	; jp PageSlot3 ;вернуть страницу 0
 102++801C
 103++801C              ; mvCR ;каретка вниз
 104++801C              	; ld de, (col_screen)
 105++801C              	; inc d
 106++801C              	; ld e, 0
 107++801C              	; ; ld a, 0
 108++801C              	; ; ld (half_tile_screen), a
 109++801C              	; jp gotoXY
 110++801C
 111++801C              ; Print just one symbol
 112++801C              ; A - symbol
 113++801C              putC
 114++801C              	OS_PRINT_CHARF
 114++801C D7          >	rst #10
 115++801D C9           	ret
 116++801E                  ; cp 13 : jp z, mvCR
 117++801E
 118++801E              	; ld hl, single_symbol
 119++801E              	; ld (hl), a
 120++801E              	; ;ld a, 7 : call Memory.setPage
 121++801E              	; ld a,#3b ;пиксели
 122++801E              	; call PageSlot3
 123++801E                  ; ld hl, single_symbol_print
 124++801E                  ; call printL
 125++801E                  ; xor a : ;jp Memory.setPage
 126++801E              	; jp PageSlot3 ;вернуть страницу 0
 127++801E
 128++801E              ; Put string
 129++801E              ; hl - string pointer that's begins from symbol count
 130++801E              printZ
 131++801E              	OS_PRINTZ
 131++801E 0E 09       >    ld c,#09
 131++8020 E7          >    rst #20
 132++8021 C9           	ret
 133++8022                  ; ld a, (hl) : and a : ret z
 134++8022                  ; push hl
 135++8022                  ; call putC
 136++8022                  ; pop hl
 137++8022                  ; inc hl
 138++8022                  ; jr printZ
 139++8022
 140++8022              ; printL
 141++8022                      ; ld	a, (hl)
 142++8022              		; and	a
 143++8022              		; ret	z
 144++8022
 145++8022              		; ; push	hl
 146++8022              		; ; call	calc_addr_scr
 147++8022              		; ; ld	a,(attr_screen)
 148++8022              		; ; ;ld	(hl),a ;покрасить символ
 149++8022              		; ; pop	hl
 150++8022
 151++8022              		; ;call	calc_addr_scr
 152++8022
 153++8022              		; ; ld	a,(half_tile_screen)
 154++8022              		; ; bit	0,a
 155++8022              		; ; ld	a,(hl)
 156++8022              		; ; jp	nz,print64_4
 157++8022              ; ;print80_3
 158++8022                      ; push    af
 159++8022              		; push	hl
 160++8022              		; ; ld a,#7b ;атрибуты
 161++8022              		; ; call PageSlot3
 162++8022              		; call	calc_addr_scr
 163++8022              		; ; ld	a,(attr_screen)
 164++8022              		; ; ld	(hl),a ;покрасить символ
 165++8022              		; ld d,h ;координаты экрана в DE
 166++8022              		; ld e,l
 167++8022              		; ; ld a,#3b ;пиксели
 168++8022              		; ; call PageSlot3
 169++8022              		; pop	hl
 170++8022
 171++8022                      ; inc     hl
 172++8022                      ; push    hl
 173++8022
 174++8022                      ; ld      a,(hl)
 175++8022              		; ld	l,a
 176++8022              		; ld	h,0
 177++8022              		; add	hl,hl
 178++8022              		; add	hl,hl
 179++8022              		; add	hl,hl
 180++8022                      ; ld      bc,font
 181++8022                      ; add     hl,bc
 182++8022
 183++8022                      ; ;push    de
 184++8022
 185++8022                      ; ld      b,8
 186++8022              		; ; xor	a
 187++8022              		; ; ld	(de),a
 188++8022              ; print80_1
 189++8022              	; ;inc     d
 190++8022
 191++8022              	; ld      a,(hl)
 192++8022              	; ;and	#f0
 193++8022              	; ld      (de),a
 194++8022              	; inc     hl
 195++8022
 196++8022              	; push hl ;на строку пикселей вниз
 197++8022              	; ld hl,80
 198++8022              	; add hl,de
 199++8022              	; ex de,hl
 200++8022              	; pop hl
 201++8022
 202++8022              	; djnz    print80_1
 203++8022
 204++8022              	; ;inc	d
 205++8022              	; ; push hl
 206++8022              	; ; ld hl,80
 207++8022              	; ; add hl,de
 208++8022              	; ; ex de,hl
 209++8022              	; ; pop hl
 210++8022
 211++8022              	; ; xor	a
 212++8022              	; ; ld	(de),a
 213++8022
 214++8022              	; ; ld	a,1
 215++8022              	; ; ld	(half_tile_screen),a
 216++8022
 217++8022              	; ;pop     de
 218++8022              	; pop     hl
 219++8022              	; pop     af
 220++8022
 221++8022              	; ;dec     a
 222++8022              	; ; ret     ;z
 223++8022
 224++8022              ; ; print64_4
 225++8022              	; ; push    af
 226++8022
 227++8022              	; ; inc     hl
 228++8022              	; ; push    hl
 229++8022
 230++8022              	; ; ld      a,(hl)
 231++8022              	; ; ld	l,a
 232++8022              	; ; ld	h,0
 233++8022              	; ; add	hl,hl
 234++8022              	; ; add	hl,hl
 235++8022              	; ; add	hl,hl
 236++8022              	; ; ld      bc,font
 237++8022              	; ; add     hl,bc
 238++8022
 239++8022              	; ; push    de
 240++8022
 241++8022              	; ; ld      b,6
 242++8022              	; ; xor	a
 243++8022              	; ; ld	(de),a
 244++8022              ; ; print64_2
 245++8022              	; ; ;inc     d
 246++8022              	; ; push hl
 247++8022              	; ; ld hl,80
 248++8022              	; ; add hl,de
 249++8022              	; ; ex de,hl
 250++8022              	; ; pop hl
 251++8022              	; ; ld      a,(hl)
 252++8022              	; ; ;and     #0f
 253++8022              	; ; ld      c,a
 254++8022              	; ; ld      a,(de)
 255++8022              	; ; or      c
 256++8022              	; ; ld      (de),a
 257++8022              	; ; inc     hl
 258++8022              	; ; djnz    print64_2
 259++8022
 260++8022              	; ; ;inc	d
 261++8022              	; ; push hl
 262++8022              	; ; ld hl,80
 263++8022              	; ; add hl,de
 264++8022              	; ; ex de,hl
 265++8022              	; ; pop hl
 266++8022              	; ; xor	a
 267++8022              	; ; ld	(de),a
 268++8022
 269++8022              	; ; ld	(half_tile_screen),a
 270++8022
 271++8022              	; ; pop     de
 272++8022
 273++8022              	; ; call	move_cr64
 274++8022
 275++8022              	; ; pop     hl
 276++8022              	; ; pop     af
 277++8022              	; ; dec     a
 278++8022
 279++8022              	; ; jp      nz,print64_3
 280++8022
 281++8022              	; ; ret
 282++8022
 283++8022              ; ; move cursor на одну позицию вперёд
 284++8022              ; move_cr80
 285++8022              	; ;inc	de
 286++8022
 287++8022              	; ld	hl,col_screen
 288++8022              	; inc	(hl) ;увеличить столбец
 289++8022              	; ld	a,(hl)
 290++8022
 291++8022              	; cp	80
 292++8022              	; ret	c
 293++8022
 294++8022              	; xor	a
 295++8022              	; ;ld	(half_tile_screen),a
 296++8022              	; ld	(hl),a
 297++8022              	; ld	c,a
 298++8022
 299++8022              	; inc	hl ;на переменную row
 300++8022              	; inc	(hl)
 301++8022              	; ld	a,(hl)
 302++8022              	; ld	b,a
 303++8022
 304++8022              	; cp	24
 305++8022              	; jp	c,move_cr80_01
 306++8022
 307++8022              	; ld	a,23
 308++8022              	; ld	(hl),a
 309++8022              	; ld	b,a
 310++8022
 311++8022              	; ; push	bc
 312++8022              	; ; call	scroll_up8
 313++8022              	; ; pop	bc
 314++8022
 315++8022              ; move_cr80_01
 316++8022              	; ; call	calc_addr_scr
 317++8022              	; ; ret
 318++8022
 319++8022              ; calc_addr_scr	;определение адреса экрана по координатам символа
 320++8022              	; ld	bc,(col_screen)
 321++8022              ; bc_to_attr:
 322++8022              	; ld h,0
 323++8022              	; ld l,b ;строка
 324++8022              	; add hl,hl ;*2
 325++8022              	; ld de,table_addr_scr
 326++8022              	; add hl,de
 327++8022              	; ld e,(hl)
 328++8022              	; inc hl
 329++8022              	; ld d,(hl) ;узнали координаты строки
 330++8022              	; ld h,0
 331++8022              	; ld l,c ;колонка
 332++8022              	; add hl,de ;узнали адрес символа
 333++8022              	; ; ld      a,b
 334++8022              	; ; ld      d,a
 335++8022              	; ; rrca
 336++8022              	; ; rrca
 337++8022              	; ; rrca
 338++8022              	; ; and     a,224
 339++8022              	; ; add     a,c
 340++8022              	; ; ld      e,a
 341++8022              	; ; ld      a,d
 342++8022              	; ; and     24
 343++8022              	; ; or      #c0
 344++8022              	; ; ld      d,a
 345++8022              	; ret
 346++8022
 347++8022              ; ; calc_addr_attr
 348++8022              	; ; ld	bc,(col_screen)
 349++8022              ; ; bc_to_attr:
 350++8022              	; ; ld	a,b
 351++8022              	; ; rrca
 352++8022              	; ; rrca
 353++8022              	; ; rrca
 354++8022              	; ; ld	l,a
 355++8022              	; ; and	31
 356++8022              	; ; or	#d8
 357++8022              	; ; ld	h,a
 358++8022              	; ; ld	a,l
 359++8022              	; ; and	252
 360++8022              	; ; or	c
 361++8022              	; ; ld	l,a
 362++8022              	; ; ret
 363++8022
 364++8022              ; ; scroll_up8	;
 365++8022              	; ; ld	hl,table_addr_scr
 366++8022              	; ; ld	b,184
 367++8022
 368++8022              ; ; scroll_up8_01
 369++8022              	; ; push	bc
 370++8022
 371++8022              	; ; ld	e,(hl)
 372++8022              	; ; inc	hl
 373++8022              	; ; ld	d,(hl)
 374++8022              	; ; inc	hl
 375++8022
 376++8022              	; ; push	hl
 377++8022
 378++8022              	; ; ld	bc,14
 379++8022              	; ; add	hl,bc
 380++8022              	; ; ld	c,(hl)
 381++8022              	; ; inc	hl
 382++8022              	; ; ld	b,(hl)
 383++8022
 384++8022              	; ; ld	h,b
 385++8022              	; ; ld	l,c
 386++8022
 387++8022              	; ; ld	bc,32
 388++8022              	; ; ldir
 389++8022
 390++8022              	; ; pop	hl
 391++8022              	; ; pop	bc
 392++8022              	; ; djnz	scroll_up8_01
 393++8022
 394++8022              	; ; ld	b,8
 395++8022
 396++8022              ; ; scroll_up8_02
 397++8022              	; ; push	bc
 398++8022
 399++8022              	; ; ld	e,(hl)
 400++8022              	; ; inc	hl
 401++8022              	; ; ld	d,(hl)
 402++8022              	; ; inc	hl
 403++8022
 404++8022              	; ; push	hl
 405++8022
 406++8022              	; ; ld	h,d
 407++8022              	; ; ld	l,e
 408++8022              	; ; inc	de
 409++8022              	; ; ld	(hl),0
 410++8022              	; ; ld	bc,31
 411++8022              	; ; ldir
 412++8022
 413++8022              	; ; pop	hl
 414++8022              	; ; pop	bc
 415++8022              	; ; djnz	scroll_up8_02
 416++8022              	; ; ld	de,#D800, hl,#D820, bc,736
 417++8022              	; ; ldir
 418++8022              	; ; ld	a,(de)
 419++8022              	; ; ld	hl,#dae0, de,#dae1, (hl),a, bc,31
 420++8022              	; ; ldir
 421++8022
 422++8022              	; ; ret
 423++8022
 424++8022
 425++8022              ; gmxscron
 426++8022                          ; ld      bc,#7efd
 427++8022                          ; ld      a,#c8
 428++8022                          ; out     (c),a
 429++8022                          ; ; ld      bc,#7ffd
 430++8022                          ; ; ld      a,#10    ;5 screen
 431++8022                          ; ; out     (c),a
 432++8022                          ; ret
 433++8022
 434++8022              ; ; gmxscron2
 435++8022                          ; ; ld      bc,#7efd
 436++8022                          ; ; ld      a,#c8
 437++8022                          ; ; out     (c),a
 438++8022                          ; ; ld      bc,#7ffd
 439++8022                          ; ; ld      a,#18    ;7 screen
 440++8022                          ; ; out     (c),a
 441++8022                          ; ; ret
 442++8022
 443++8022              ; gmxscroff
 444++8022                          ; ld      bc,#7efd
 445++8022                          ; ld      a,#c0
 446++8022                          ; out     (c),a
 447++8022                          ; ; ld      bc,#7ffd
 448++8022                          ; ; ld      a,#10    ;5 screen
 449++8022                          ; ; out     (c),a
 450++8022                          ; ret
 451++8022
 452++8022
 453++8022              ; PageSlot3
 454++8022              ; ; драйвер памяти для TR-DOS Navigator
 455++8022              ; ; и Scorpion GMX 2Mb
 456++8022                       ; ; org  #5b00
 457++8022                       ; ; jr   pag_on
 458++8022                       ; ; jr   clock
 459++8022                       ; ; db   #00
 460++8022                       ; ; db   #00
 461++8022
 462++8022                       ; ;push hl
 463++8022                       ; ld   hl,table
 464++8022                       ; add  a,l
 465++8022                       ; jr   nc,PageSlot3_1
 466++8022                       ; inc  h          ;коррекция
 467++8022              ; PageSlot3_1  ld   l,a
 468++8022                       ; ld   a,(hl)
 469++8022                       ; ;pop  hl
 470++8022                       ; ;cp   #ff
 471++8022                       ; ;scf
 472++8022                       ; ;ret  z
 473++8022                       ; ;push bc
 474++8022                       ; push af
 475++8022                       ; rlca
 476++8022                       ; and  #10
 477++8022                       ; ld   bc,#1ffd
 478++8022              ; PageSlot3DOS
 479++8022              		 ; ;or #00 ; #04 тут выбор ПЗУ TRDOS
 480++8022                       ; out  (c),a
 481++8022                       ; pop  af
 482++8022                       ; push af
 483++8022                       ; and  #07
 484++8022              ; PageSlot3Scr ;тут выбор экрана и ПЗУ
 485++8022                       ; or   #18 ;#0 ;#18
 486++8022                       ; ld   b,#7f
 487++8022                       ; out  (c),a
 488++8022                       ; pop  af
 489++8022                       ; rrca
 490++8022                       ; rrca
 491++8022                       ; rrca
 492++8022                       ; rrca
 493++8022                       ; and  #07
 494++8022                       ; ld   b,#df
 495++8022                       ; out  (c),a
 496++8022                       ; ;pop  hl
 497++8022                       ; ret
 498++8022              ; ; clock    ld   d,%00100000
 499++8022                       ; ; rst  8
 500++8022                       ; ; db   #89
 501++8022                       ; ; ret
 502++8022
 503++8022                       ; ; org  #5b5c ; здесь системная переменая
 504++8022                       ; ; db   #10
 505++8022              ; ;все страницы
 506++8022              ; table    db   #00,#01,#02,#03,#04,#05,#06,#07,#08,#09
 507++8022                       ; db   #0a,#0b,#0c,#0d,#0e
 508++8022                       ; db   #0f,#10,#11,#12,#13,#14
 509++8022                       ; db   #15,#16,#17,#18,#19,#1a
 510++8022                       ; db   #1b,#1c,#1d,#1e,#1f,#20
 511++8022                       ; db   #21,#22,#23,#24,#25,#26
 512++8022                       ; db   #27,#28,#29,#2a,#2b,#2c
 513++8022                       ; db   #2d,#2e,#2f,#30,#31,#32
 514++8022                       ; db   #33,#34,#35,#36,#37,#38,#39
 515++8022                       ; db   #3a,#3b,#3c,#3d,#3e,#3f,#40
 516++8022                       ; db   #41,#42,#43,#44,#45,#46
 517++8022                       ; db   #47,#48,#49,#4a,#4b,#4c
 518++8022
 519++8022                       ; db   #4d,#4e,#4f,#50,#51,#52
 520++8022                       ; db   #53,#54,#55,#56,#57,#58
 521++8022                       ; db   #59,#5a,#5b,#5c,#5d,#5e
 522++8022                       ; db   #5f,#60,#61,#62,#63,#64
 523++8022                       ; db   #65,#66,#67,#68,#69,#6a
 524++8022                       ; db   #6b,#6c,#6d,#6e,#6f,#70
 525++8022                       ; db   #71,#72,#73,#74,#75,#76
 526++8022                       ; db   #77,#78,#79,#7a,#7b,#7c,#7d,#7e
 527++8022                       ; db   #7f
 528++8022
 529++8022                       ; db   #ff ;конец таблицы
 530++8022
 531++8022
 532++8022
 533++8022              ; font equ #4000 ; Using ZX-Spectrum screen as font buffer
 534++8022              ; font_file db "data/font.bin", 0
 535++8022
 536++8022
 537++8022              ; table_addr_scr	;адреса строк текста
 538++8022              	; defw	#c000 ;0
 539++8022              	; defw	#c280
 540++8022              	; defw	#c500
 541++8022              	; defw	#c780
 542++8022              	; defw	#ca00
 543++8022              	; defw	#cc80
 544++8022              	; defw	#cf00
 545++8022              	; defw	#d180
 546++8022
 547++8022              	; defw	#d400 ;8
 548++8022              	; defw	#d680
 549++8022              	; defw	#d900
 550++8022              	; defw	#db80
 551++8022              	; defw	#de00
 552++8022              	; defw	#e080
 553++8022              	; defw	#e300
 554++8022              	; defw	#e580
 555++8022
 556++8022              	; defw	#e800 ;16
 557++8022              	; defw	#ea80
 558++8022              	; defw	#ed00
 559++8022              	; defw	#ef80
 560++8022              	; defw	#f200
 561++8022              	; defw	#f480
 562++8022              	; defw	#f700
 563++8022              	; defw	#f980
 564++8022
 565++8022              	; defw	#fc00 ;24
 566++8022              	; defw	#fe80 ;25 вне экрана
 567++8022
 568++8022
 569++8022              ; col_screen			db	0	;столбец
 570++8022              ; row_screen			db	0	;строка
 571++8022              ; ;half_tile_screen	db	0
 572++8022              ; attr_screen			db	07	;основной цвет
 573++8022              ; attr_screen2		db	#c	;другой цвет
 574++8022
 575++8022              ; ;col_screen_temp			dw	0
 576++8022              ; ;half_tile_screen_temp	db	0
 577++8022
 578++8022              ; single_symbol_print db 1
 579++8022              ; single_symbol 		db 0
 580++8022
 581++8022              ; fill_buff ds 80+1
 582++8022
 583++8022                  endmodule
# file closed: vdp/zsgmx.asm
  15+ 8022                  ENDIF
# file closed: vdp/index.asm
  16  8022                  include "utils/index.asm"
# file opened: utils/index.asm
   1+ 8022                  include "atoi.asm"
# file opened: utils/atoi.asm
   1++8022              ; DE - buffer
   2++8022              ; HL - output
   3++8022              atohl:
   4++8022 21 00 00         ld hl, 0
   5++8025              .loop
   6++8025 1A               ld a, (de)
   7++8026 13               inc de
   8++8027                  ; Sepparators
   9++8027 C5 E5            push bc, hl
  10++8029 01 05 00             ld bc, sepparators_len
  11++802C 21 44 80             ld hl, sepparators
  12++802F ED B1                cpir
  13++8031 E1 C1            pop hl, bc
  14++8033 C8               ret z
  15++8034
  16++8034 D6 30            sub '0'
  17++8036
  18++8036 C5               push bc
  19++8037 4D                   ld c, l
  20++8038 44                   ld b, h
  21++8039
  22++8039 29                   add hl, hl
  23++803A 29                   add hl, hl
  24++803B 09                   add hl, bc
  25++803C 29                   add hl, hl
  26++803D 4F                   ld c, a
  27++803E 06 00                ld b, 0
  28++8040 09                   add hl, bc
  29++8041 C1               pop bc
  30++8042 18 E1            jr .loop
  31++8044
# file closed: utils/atoi.asm
   2+ 8044                  include "constants.asm"
# file opened: utils/constants.asm
   1++8044              TAB = 9
   2++8044              CR = 13
   3++8044              LF = 10
   4++8044              NULL = 0
   5++8044              SPACE = ' '
   6++8044              ESC = 27
   7++8044
   8++8044                  IFNDEF TIMEX80
   9++8044              MIME_DOWNLOAD = 1
  10++8044              MIME_LINK     = 2
  11++8044              MIME_TEXT     = 3
  12++8044              MIME_IMAGE    = 6
  13++8044              MIME_MUSIC    = 5
  14++8044              MIME_INPUT    = 4
  15++8044              MIME_MOD      = 7
  16++8044
  17++8044              BORDER_TOP    = 9
  18++8044              BORDER_BOTTOM = 8
  19++8044                  ELSE
  20++8044 ~            MIME_DOWNLOAD = #19
  21++8044 ~            MIME_LINK = #1A
  22++8044 ~            MIME_TEXT = #10
  23++8044 ~            MIME_IMAGE = #01
  24++8044 ~            MIME_MUSIC = #0e
  25++8044 ~            MIME_INPUT = #b3
  26++8044 ~            MIME_MOD = #0d
  27++8044 ~
  28++8044 ~            BORDER_TOP = #b2
  29++8044 ~            BORDER_BOTTOM = #b1
  30++8044 ~
  31++8044                  ENDIF
  32++8044
  33++8044 0D 0A 09 00  sepparators db CR, LF, TAB, NULL, SPACE
  33++8048 20
  34++8049              sepparators_len = $ - sepparators
# file closed: utils/constants.asm
   3+ 8049                  include "strutils.asm"
# file opened: utils/strutils.asm
   1++8049              ; de - pointer
   2++8049              ; hl - count
   3++8049              strlen:
   4++8049 21 00 00         ld hl, 0
   5++804C              .loop
   6++804C 1A               ld a, (de)
   7++804D A7               and a
   7++804E 28 04          jr z, .exit
   8++8050 23               inc hl
   9++8051 13               inc de
  10++8052 18 F8            jr .loop
  11++8054              .exit
  12++8054 C9               ret
  13++8055
  14++8055                  module CompareBuff
  15++8055
  16++8055              ; Pushes A to buffer
  17++8055              push
  18++8055 F5               push af
  19++8056 06 20            ld b, 32
  19++8058 21 A1 80       ld hl, buffer + 1
  19++805B 11 A0 80       ld de, buffer
  20++805E              .loop
  21++805E 7E               ld a, (hl)
  21++805F 12             ld (de), a
  21++8060 23             inc hl
  21++8061 13             inc de
  21++8062 10 FA          djnz .loop
  22++8064 F1               pop af
  23++8065 21 BF 80         ld hl, buffer + 31
  23++8068 77             ld (hl), a
  24++8069 C9               ret
  25++806A
  26++806A              ; HL - Compare string(null terminated)
  27++806A              ; A - 0 NOT Found
  28++806A              ;     1 Found
  29++806A              search:
  30++806A 06 00            ld b, 0
  30++806C E5             push hl
  31++806D              .loop:
  32++806D 7E               ld a, (hl)
  32++806E 23             inc hl
  32++806F 04             inc b
  32++8070 A7             and a
  32++8071 C2 6D 80       jp nz, .loop
  33++8074 05               dec b
  33++8075 E1             pop hl
  33++8076 C5             push bc
  33++8077 E5             push hl
  34++8078 E1               pop hl
  35++8079 11 C0 80         ld de, buffer + 32
  36++807C              .sourceLoop
  37++807C 1B               dec de
  37++807D 10 FD          djnz .sourceLoop
  38++807F C1               pop bc
  39++8080              .compare
  40++8080 C5               push bc
  40++8081 F5             push af
  41++8082 1A               ld a, (de)
  41++8083 47             ld b, a
  42++8084 F1               pop af
  42++8085 7E             ld a, (hl)
  42++8086 B8             cp b
  42++8087 C1             pop bc
  42++8088 3E 00          ld a, 0
  42++808A C0             ret nz
  43++808B 13               inc de
  43++808C 23             inc hl
  44++808D 10 F1            djnz .compare
  45++808F 3E 01            ld a, 1
  46++8091 C9               ret
  47++8092
  48++8092              clear:
  49++8092 AF               xor a
  49++8093 21 A0 80       ld hl, buffer
  49++8096 11 A1 80       ld de, buffer + 1
  49++8099 01 20 00       ld bc, 32
  49++809C 77             ld (hl), a
  49++809D ED B0          ldir
  50++809F C9               ret
  51++80A0
  52++80A0 00 00 00...  buffer ds 32
  53++80C0
  54++80C0                  endmodule
# file closed: utils/strutils.asm
   4+ 80C0                  include "screen.asm"
# file opened: utils/screen.asm
   1++80C0                  IFNDEF LINE_LIMIT
   2++80C0              LINE_LIMIT = 60
   3++80C0                  ENDIF
   4++80C0              ; HL - string pointer
   5++80C0              print70Text:
   6++80C0 06 3C            ld b, LINE_LIMIT
   7++80C2              .loop
   8++80C2 7E               ld a, (hl)
   9++80C3 A7               and a
   9++80C4 C8             ret z
  10++80C5 FE 0D            cp 13
  10++80C7 C8             ret z
  11++80C8 FE 0A            cp 10
  11++80CA C8             ret z
  12++80CB C5               push bc
  13++80CC E5               push hl
  14++80CD CD 1C 80         call TextMode.putC
  15++80D0 E1               pop hl
  16++80D1 23               inc hl
  17++80D2 C1               pop bc
  18++80D3 05               dec b
  19++80D4 78               ld a, b
  19++80D5 A7             and a
  19++80D6 C8             ret z
  20++80D7 C3 C2 80         jp .loop
  21++80DA
  22++80DA              ; HL - string pointer
  23++80DA              print70Goph:
  24++80DA 06 3C            ld b, LINE_LIMIT
  25++80DC              .loop
  26++80DC 7E               ld a, (hl)
  26++80DD FE 09          cp 09
  26++80DF C8             ret z
  27++80E0 A7               and a
  27++80E1 C8             ret z
  28++80E2 C5               push bc
  29++80E3 E5               push hl
  30++80E4 CD 1C 80         call TextMode.putC
  31++80E7 E1               pop hl
  32++80E8 23               inc hl
  33++80E9 C1               pop bc
  34++80EA 05               dec b
  35++80EB 78               ld a, b
  35++80EC A7             and a
  35++80ED C8             ret z
  36++80EE C3 DC 80         jp .loop
# file closed: utils/screen.asm
# file closed: utils/index.asm
  17  80F1                  include "gopher/render/index.asm"
# file opened: gopher/render/index.asm
   1+ 80F1                  MODULE Render
   2+ 80F1              PER_PAGE = 19
   3+ 80F1              CURSOR_OFFSET = 3
   4+ 80F1                  include "row.asm"
# file opened: gopher/render/row.asm
   1++80F1              ; A - row number
   2++80F1              ; HL - pointer to row
   3++80F1              renderRow:
   4++80F1 C6 03            add CURSOR_OFFSET
   5++80F3 57 1E 00         ld d, a, e, 0
   5++80F6 CD 07 80       call TextMode.gotoXY
   6++80F9 7E               ld a, (hl)
   7++80FA E5               push hl
   8++80FB CD 06 81         call getIcon
   9++80FE CD 1C 80         call TextMode.putC
  10++8101 E1               pop hl
  11++8102 23               inc hl
  12++8103 C3 DA 80         jp print70Goph
  13++8106
  14++8106              ; A - gopher id char
  15++8106              getIcon:
  16++8106 FE 69            cp 'i'
  16++8108 CA 22 81       jp z, .info
  17++810B FE 39            cp '9'
  17++810D CA 25 81       jp z, .down
  18++8110 FE 31            cp '1'
  18++8112 CA A5 81       jp z, .page
  19++8115 FE 30            cp '0'
  19++8117 CA A8 81       jp z, .text
  20++811A FE 37            cp '7'
  20++811C CA AB 81       jp z, .input
  21++811F 3E 20            ld a, ' '
  22++8121 C9               ret
  23++8122              .info
  24++8122 3E 20            ld a, SPACE
  24++8124 C9             ret
  25++8125              .down
  26++8125 54 5D            ld de, hl
  27++8127 01 FF 00 3E      ld bc, #ff, a, TAB
  27++812B 09
  27++812C ED B1          cpir
  28++812E 78               ld a, b
  28++812F B1             or c
  28++8130 28 70          jr z, .downExit
  29++8132 D5               push de
  30++8133              .nameLoop
  31++8133 7E               ld a, (hl)
  31++8134 A7             and a
  31++8135 28 10          jr z, .check
  32++8137 FE 09            cp TAB
  32++8139 28 0C          jr z, .check
  33++813B FE 0D            cp CR
  33++813D 28 08          jr z, .check
  34++813F E5               push hl
  35++8140 CD 55 80         call CompareBuff.push
  36++8143 E1               pop hl
  37++8144 23               inc hl
  38++8145 18 EC            jr .nameLoop
  39++8147              .check
  40++8147 3A E7 81     	ld a,(saveMode+1);фикс обход открытия файлов, чтобы их скачать по кнопке Caps
  41++814A B7           	or a
  42++814B 20 54        	jr nz,.checkExit
  43++814D 21 BA 81         ld hl, scrExt1
  43++8150 CD 6A 80       call CompareBuff.search
  43++8153 A7             and a
  43++8154 20 58          jr nz, .image
  44++8156 21 BF 81         ld hl, scrExt2
  44++8159 CD 6A 80       call CompareBuff.search
  44++815C A7             and a
  44++815D 20 4F          jr nz, .image
  45++815F              	OS_GET_VTPL_SETUP
  45++815F 0E 18       >    ld c,#18
  45++8161 E7          >    rst #20
  46++8162 3E 03            ld a, 3
  46++8164
  47++8164 77           	ld (hl), a ; 0 bit - looping, 1 bit - pt2 file
  48++8165 21 CE 81         ld hl, pt2Ext1
  48++8168 CD 6A 80       call CompareBuff.search
  48++816B A7             and a
  48++816C 20 44          jr nz, .music
  49++816E 21 D3 81         ld hl, pt2Ext2
  49++8171 CD 6A 80       call CompareBuff.search
  49++8174 A7             and a
  49++8175 20 3B          jr nz, .music
  50++8177              	OS_GET_VTPL_SETUP
  50++8177 0E 18       >    ld c,#18
  50++8179 E7          >    rst #20
  51++817A 3E 01            ld a, 1
  51++817C
  52++817C 77           	ld (hl), a
  53++817D 21 C4 81         ld hl, pt3Ext1
  53++8180 CD 6A 80       call CompareBuff.search
  53++8183 A7             and a
  53++8184 20 2C          jr nz, .music
  54++8186 21 C9 81         ld hl, pt3Ext2
  54++8189 CD 6A 80       call CompareBuff.search
  54++818C A7             and a
  54++818D 20 23          jr nz, .music
  55++818F
  56++818F                  ; General Sound support
  57++818F                  ifdef GS
  58++818F 21 D8 81         ld hl, modExt1
  58++8192 CD 6A 80       call CompareBuff.search
  58++8195 A7             and a
  58++8196 20 1E          jr nz, .mod
  59++8198 21 DD 81         ld hl, modExt2
  59++819B CD 6A 80       call CompareBuff.search
  59++819E A7             and a
  59++819F 20 15          jr nz, .mod
  60++81A1                  endif
  61++81A1              .checkExit
  62++81A1 E1               pop hl
  63++81A2              .downExit
  64++81A2 3E 01            ld a, MIME_DOWNLOAD
  64++81A4 C9             ret
  65++81A5              .page
  66++81A5 3E 02            ld a, MIME_LINK
  66++81A7 C9             ret
  67++81A8              .text
  68++81A8 3E 03            ld a, MIME_TEXT
  68++81AA C9             ret
  69++81AB              .input
  70++81AB 3E 04            ld a, MIME_INPUT
  70++81AD C9             ret
  71++81AE              .image
  72++81AE E1               pop hl
  72++81AF 3E 06          ld a, MIME_IMAGE
  72++81B1 C9             ret
  73++81B2              .music
  74++81B2 E1               pop hl
  74++81B3 3E 05          ld a, MIME_MUSIC
  74++81B5 C9             ret
  75++81B6              .mod
  76++81B6 E1               pop hl
  76++81B7 3E 07          ld a, MIME_MOD
  76++81B9 C9             ret
  77++81BA
  78++81BA 2E 73 63 72  scrExt1 db ".scr", 0
  78++81BE 00
  79++81BF 2E 53 43 52  scrExt2 db ".SCR", 0
  79++81C3 00
  80++81C4
  81++81C4 2E 70 74 33  pt3Ext1 db ".pt3", 0
  81++81C8 00
  82++81C9 2E 50 54 33  pt3Ext2 db ".PT3", 0
  82++81CD 00
  83++81CE 2E 70 74 32  pt2Ext1 db ".pt2", 0
  83++81D2 00
  84++81D3 2E 50 54 32  pt2Ext2 db ".PT2", 0
  84++81D7 00
  85++81D8
  86++81D8 2E 6D 6F 64  modExt1 db ".mod", 0
  86++81DC 00
  87++81DD 2E 4D 4F 44  modExt2 db ".MOD", 0
  87++81E1 00
  88++81E2
  89++81E2              toggleSaveMode
  90++81E2 F5           			push af
  91++81E3 CD A4 86     			call Console.waitForKeyUp
  92++81E6 3E 00        saveMode	ld a,0 ; Флаг Open/Save files
  93++81E8 EE 01        			xor 1
  94++81EA 32 E7 81     			ld (saveMode+1),a
  95++81ED F1           			pop af
  96++81EE C9           			ret
# file closed: gopher/render/row.asm
   5+ 81EF                  include "buffer.asm"
# file opened: gopher/render/buffer.asm
   1++81EF              ; B - line count
   2++81EF              findLine:
   3++81EF 21 5F A3         ld hl, outputBuffer
   4++81F2              findLine2:
   5++81F2 AF               xor a
   5++81F3 B0             or b
   5++81F4 28 1D          jr z, .checkEmpty
   6++81F6              .loop
   7++81F6 7E               ld a, (hl)
   7++81F7 A7             and a
   7++81F8 28 1C          jr z, .nope
   8++81FA FE 0D            cp 13
   8++81FC 23             inc hl
   8++81FD 28 0C          jr z, .checkLF
   9++81FF FE 0A            cp 10
   9++8201 28 02          jr z, .nextCheck
  10++8203 18 F1            jr .loop
  11++8205              .nextCheck
  12++8205 A7               and a
  12++8206 28 0E          jr z, .nope
  13++8208 10 EC            djnz .loop
  14++820A C9               ret
  15++820B              .checkLF
  16++820B 7E               ld a, (hl)
  17++820C FE 0A            cp 10
  17++820E 20 F5          jr nz, .nextCheck
  18++8210 23               inc hl
  19++8211 18 F2            jr  .nextCheck
  20++8213              .checkEmpty
  21++8213 7E               ld a, (hl)
  21++8214 A7             and a
  21++8215 C0             ret nz
  22++8216              .nope
  23++8216 21 00 00         ld hl, 0
  23++8219 C9             ret
# file closed: gopher/render/buffer.asm
   6+ 821A                  include "ui.asm"
# file opened: gopher/render/ui.asm
   1++821A              prepareScreen:
   2++821A CD 03 80         call TextMode.cls
   3++821D 21 46 83         ld hl, header
   3++8220 CD 1E 80       call TextMode.printZ
   4++8223 21 4A 82         ld hl, toolbox
   4++8226 CD 1E 80       call TextMode.printZ
   5++8229 21 2C 9D         ld hl, hostName
   5++822C CD 1E 80       call TextMode.printZ
   6++822F 11 00 17         ld de, #1700
   6++8232 CD 07 80       call TextMode.gotoXY
   6++8235 21 56 82       ld hl, footer
   6++8238 CD 1E 80       call TextMode.printZ
   7++823B
   8++823B AF               xor a
   8++823C CD 16 80       call TextMode.highlightLine
   9++823F 3E 01            ld a, 1
   9++8241 CD 16 80       call TextMode.highlightLine
  10++8244 3E 17            ld a, #17
  10++8246 CD 16 80       call TextMode.highlightLine
  11++8249 C9               ret
  12++824A
  13++824A
  14++824A 20 5B 44 5D  toolbox db " [D]omain: ", 0
  14++824E 6F 6D 61 69
  14++8252 6E 3A 20 00
  15++8256 20 20 43 75  footer db "  Cursor - movement  [B]ack to prev. page  [H]ome page", 0
  15++825A 72 73 6F 72
  15++825E 20 2D 20 6D
  15++8262 6F 76 65 6D
  15++8266 65 6E 74 20
  15++826A 20 5B 42 5D
  15++826E 61 63 6B 20
  15++8272 74 6F 20 70
  15++8276 72 65 76 2E
  15++827A 20 70 61 67
  15++827E 65 20 20 5B
  15++8282 48 5D 6F 6D
  15++8286 65 20 70 61
  15++828A 67 65 00
  16++828D
  17++828D              inputHost:
  18++828D CD A4 86         call Console.waitForKeyUp
  19++8290              .loop
  20++8290 11 0B 01         ld de, #010B
  20++8293 CD 07 80       call TextMode.gotoXY
  20++8296 21 2C 9D       ld hl, hostName
  20++8299 CD 1E 80       call TextMode.printZ
  21++829C 3E 04            ld a, MIME_INPUT
  21++829E CD 1C 80       call TextMode.putC
  22++82A1 3E 20            ld a, ' '
  22++82A3 CD 1C 80       call TextMode.putC
  23++82A6              .wait
  24++82A6 CD AD 86         call Console.getC
  25++82A9 5F               ld e, a
  26++82AA FE 0C            cp Console.BACKSPACE
  26++82AC 28 17          jr z, .removeChar
  27++82AE FE 0D            cp CR
  27++82B0 CA D3 82       jp z, inputNavigate
  28++82B3 FE 20            cp 32
  28++82B5 38 EF          jr c, .wait
  29++82B7              .putC
  30++82B7 AF               xor a
  30++82B8 21 2C 9D 01    ld hl, hostName, bc, 48
  30++82BC 30 00
  30++82BE ED B1          cpir
  31++82C0 77               ld (hl), a
  31++82C1 2B             dec hl
  31++82C2 73             ld (hl), e
  32++82C3 18 CB            jr .loop
  33++82C5              .removeChar
  34++82C5 AF               xor a
  35++82C6 21 2C 9D 01      ld hl, hostName, bc, 48
  35++82CA 30 00
  35++82CC ED B1          cpir
  36++82CE 2B               dec hl
  36++82CF 2B             dec hl
  36++82D0 77             ld (hl), a
  37++82D1 18 BD            jr .loop
  38++82D3
  39++82D3              inputNavigate:
  40++82D3 21 2C 9D 11      ld hl, hostName, de, domain
  40++82D7 06 83
  41++82D9 7E               ld a,(hl)
  42++82DA A7               and a
  43++82DB CA D1 86         jp z, History.load
  44++82DE              .loop
  45++82DE 7E               ld a, (hl)
  45++82DF A7             and a
  45++82E0 28 05          jr z, .complete
  46++82E2 12               ld (de), a
  46++82E3 23 13          inc hl, de
  47++82E5 18 F7            jr .loop
  48++82E7              .complete
  49++82E7 3E 09            ld a, TAB
  49++82E9 12             ld (de), a
  49++82EA 13             inc de
  50++82EB 3E 37            ld a, '7'
  50++82ED 12             ld (de), a
  50++82EE 13             inc de
  51++82EF 3E 30            ld a, '0'
  51++82F1 12             ld (de), a
  51++82F2 13             inc de
  52++82F3 3E 0D            ld a, CR
  52++82F5 12             ld (de), a
  52++82F6 13             inc de
  53++82F7 3E 0A            ld a, LF
  53++82F9 12             ld (de), a
  53++82FA 13             inc de
  54++82FB 21 01 83         ld hl, navRow
  54++82FE C3 26 87       jp History.navigate
  55++8301
  56++8301 31 20 09 2F  navRow db "1 ", TAB, "/", TAB
  56++8305 09
  57++8306 6E 69 68 69  domain db "nihirash.net"
  57++830A 72 61 73 68
  57++830E 2E 6E 65 74
  58++8312 00 00 00...      ds 64 - ($ - domain)
  59++8346
  60++8346                  IFDEF MB03
  61++8346 ~            header db "      Moon Rabbit "
  62++8346 ~                   db VERSION_STRING
  63++8346 ~                   db " for MB03+  (c) 2021 Alexander Nihirash",13, 0
  64++8346                  ENDIF
  65++8346
  66++8346                  IFDEF UNO
  67++8346 ~            header db "      Moon Rabbit "
  68++8346 ~                   db VERSION_STRING
  69++8346 ~                   db " for ZX-Uno (c) 2021 Alexander Nihirash",13, 0
  70++8346                  ENDIF
  71++8346
  72++8346                  IFDEF AY
  73++8346 ~            header db "      Moon Rabbit "
  74++8346 ~                   db VERSION_STRING
  75++8346 ~                   db " for AYWIFI (c) 2021 Alexander Nihirash",13, 0
  76++8346                  ENDIF
  77++8346
  78++8346                  IFDEF ZW
  79++8346 20 20 20 20  header db "      Moon Rabbit "
  79++834A 20 20 4D 6F
  79++834E 6F 6E 20 52
  79++8352 61 62 62 69
  79++8356 74 20
  80++8358 31 2E 36            db "1.6"
  81++835B 20 66 6F 72         db " for ZX WiFi (c) 2021 Alexander Nihirash",13, 0
  81++835F 20 5A 58 20
  81++8363 57 69 46 69
  81++8367 20 28 63 29
  81++836B 20 32 30 32
  81++836F 31 20 41 6C
  81++8373 65 78 61 6E
  81++8377 64 65 72 20
  81++837B 4E 69 68 69
  81++837F 72 61 73 68
  81++8383 0D 00
  82++8385                  ENDIF
# file closed: gopher/render/ui.asm
   7+ 8385                  include "gopher-page.asm"
# file opened: gopher/render/gopher-page.asm
   1++8385              renderGopherScreen:
   2++8385 CD 1A 82         call Render.prepareScreen
   3++8388
   4++8388              	;поиск и печать первой нужной строки
   5++8388 3A 3A 8B         ld a, (page_offset)
   5++838B 47             ld b, a
   5++838C CD EF 81       call findLine ;поиск с начала буфера
   6++838F 7C               ld a, h
   6++8390 B5             or l
   6++8391 28 1F          jr z, .exit2
   7++8393 AF               xor a
   7++8394 E5             push hl
   7++8395 CD F1 80       call renderRow
   7++8398 E1             pop hl ;печать строки 0
   8++8399              	;теперь поиск продолжается
   9++8399
  10++8399 06 12            ld b, PER_PAGE-1 ;одну строку уже обработали
  11++839B              .loop
  12++839B C5               push bc
  13++839C 3E 13            ld a, PER_PAGE
  13++839E 90             sub b
  14++839F 5F               ld e, a
  14++83A0 06 01          ld b, 1
  14++83A2 CD F2 81       call findLine2 ;поиск одной следующей
  15++83A5 7C               ld a, h
  15++83A6 B5             or l
  15++83A7 28 06          jr z, .exit
  16++83A9 7B               ld a, e
  16++83AA E5             push hl
  16++83AB CD F1 80       call renderRow
  16++83AE E1             pop hl ;указатель hl надо сохранить
  17++83AF              .exit
  18++83AF C1               pop bc
  19++83B0 10 E9            djnz .loop
  20++83B2              .exit2
  21++83B2 CD 8C 84         call showCursor
  22++83B5 C9               ret
  23++83B6
  24++83B6              checkBorder:
  25++83B6 3A 3B 8B         ld a, (cursor_position)
  25++83B9 FE FF          cp #ff
  25++83BB CA B0 84       jp z, pageUp
  26++83BE 3A 3B 8B         ld a, (cursor_position)
  26++83C1 FE 13          cp PER_PAGE
  26++83C3 CA D3 84       jp z, pageDn
  27++83C6 CD 8C 84         call showCursor
  28++83C9 C3 CC 83         jp workLoop
  29++83CC
  30++83CC              workLoop:
  31++83CC 3A 81 85         ld a, (play_next)
  31++83CF A7             and a
  31++83D0 C2 45 84       jp nz, navigate
  32++83D3
  33++83D3                  ; dup 4
  34++83D3                  ; halt
  35++83D3                  ; edup
  36++83D3              .nothing
  37++83D3              	OS_WAIT
  37++83D3 DF          >	rst #18
  38++83D4 CD 4F A2     	call printRTC
  39++83D7 CD B6 86         call Console.peekC
  40++83DA FE FF            cp 255
  40++83DC 28 F5          jr z, .nothing
  41++83DE
  42++83DE FE 0A            cp Console.KEY_DN
  42++83E0 CA 9C 84       jp z, cursorDown
  43++83E3 FE 61            cp 'a'
  43++83E5 CA 9C 84       jp z, cursorDown
  44++83E8 FE 0B            cp Console.KEY_UP
  44++83EA CA A6 84       jp z, cursorUp
  45++83ED FE 71            cp 'q'
  45++83EF CA A6 84       jp z, cursorUp
  46++83F2 FE 08            cp Console.KEY_LT
  46++83F4 CA B0 84       jp z, pageUp
  47++83F7 FE 6F            cp 'o'
  47++83F9 CA B0 84       jp z, pageUp
  48++83FC FE 09            cp Console.KEY_RT
  48++83FE CA D3 84       jp z, pageDn
  49++8401 FE 70            cp 'p'
  49++8403 CA D3 84       jp z, pageDn
  50++8406
  51++8406 FE 68            cp 'h'
  51++8408 CA 23 87       jp z, History.home
  52++840B FE 48            cp 'H'
  52++840D CA 23 87       jp z, History.home
  53++8410
  54++8410 FE 62            cp 'b'
  54++8412 CA BA 86       jp z, History.back
  55++8415 FE 42            cp 'B'
  55++8417 CA BA 86       jp z, History.back
  56++841A FE 0C            cp Console.BACKSPACE
  56++841C CA BA 86       jp z, History.back
  57++841F
  58++841F FE 64            cp 'd'
  58++8421 CA 8D 82       jp z, inputHost
  59++8424 FE 44            cp 'D'
  59++8426 CA 8D 82       jp z, inputHost
  60++8429
  61++8429 FE 0D            cp CR
  61++842B CA 45 84       jp z, navigate
  62++842E
  63++842E                  ifdef GS
  64++842E FE 4D            cp 'M'
  64++8430 CC 53 A3       call z, GeneralSound.toggleModule
  65++8433 FE 6D            cp 'm'
  65++8435 CC 53 A3       call z, GeneralSound.toggleModule
  66++8438                  endif
  67++8438
  68++8438 FE 53        	cp 'S'
  68++843A CC E2 81       call z, toggleSaveMode
  69++843D FE 73        	cp 's'
  69++843F CC E2 81       call z, toggleSaveMode
  70++8442
  71++8442 C3 CC 83         jp workLoop
  72++8445
  73++8445              navigate:
  74++8445 CD A4 86         call Console.waitForKeyUp
  75++8448 AF               xor a
  75++8449 32 81 85       ld (play_next), a
  76++844C
  77++844C CD 94 84         call hideCursor
  78++844F 3A 3A 8B 47      ld a, (page_offset), b, a, a, (cursor_position)
  78++8453 3A 3B 8B
  78++8456 80             add b
  78++8457 47             ld b, a
  78++8458 CD EF 81       call Render.findLine
  79++845B 7E               ld a, (hl)
  80++845C FE 31            cp '1'
  80++845E CA 76 84       jp z, .load
  81++8461 FE 30            cp '0'
  81++8463 CA 76 84       jp z, .load
  82++8466 FE 39            cp '9'
  82++8468 CA 76 84       jp z, .load
  83++846B FE 37            cp '7'
  83++846D CA 7E 84       jp z, .input
  84++8470 CD 8C 84         call showCursor
  85++8473 C3 CC 83         jp workLoop
  86++8476              .load
  87++8476 E5               push hl
  88++8477 CD 06 81         call getIcon
  89++847A E1               pop hl
  90++847B C3 26 87         jp History.navigate
  91++847E              .input
  92++847E E5               push hl
  93++847F CD 82 85         call DialogBox.inputBox
  94++8482 E1               pop hl
  95++8483 3A D7 85         ld a, (DialogBox.inputBuffer)
  95++8486 A7             and a
  95++8487 CA D1 86       jp z, History.load
  96++848A 18 EA            jr .load
  97++848C
  98++848C              showCursor:
  99++848C 3A 3B 8B         ld a, (cursor_position)
  99++848F C6 03          add CURSOR_OFFSET
 100++8491 C3 16 80         jp TextMode.highlightLine
 101++8494
 102++8494              hideCursor:
 103++8494 3A 3B 8B         ld a, (cursor_position)
 103++8497 C6 03          add CURSOR_OFFSET
 104++8499 C3 10 80         jp TextMode.usualLine
 105++849C
 106++849C              cursorDown:
 107++849C CD 94 84         call hideCursor
 108++849F 21 3B 8B         ld hl, cursor_position
 109++84A2 34               inc (hl)
 110++84A3 C3 B6 83         jp checkBorder
 111++84A6
 112++84A6              cursorUp:
 113++84A6 CD 94 84         call hideCursor
 114++84A9 21 3B 8B         ld hl, cursor_position
 115++84AC 35               dec (hl)
 116++84AD C3 B6 83         jp checkBorder
 117++84B0
 118++84B0              pageUp:
 119++84B0 3A 3A 8B         ld a, (page_offset)
 119++84B3 A7             and a
 119++84B4 28 13          jr z, .skip
 120++84B6 3E 12            ld a, PER_PAGE - 1
 120++84B8 32 3B 8B       ld (cursor_position), a
 121++84BB 3A 3A 8B         ld a, (page_offset)
 121++84BE D6 13          sub PER_PAGE
 121++84C0 32 3A 8B       ld (page_offset), a
 122++84C3              .exit
 123++84C3 CD 85 83         call renderGopherScreen
 124++84C6 C3 CC 83         jp workLoop
 125++84C9              .skip
 126++84C9 AF               xor a
 126++84CA 32 3B 8B       ld (cursor_position), a
 126++84CD CD 85 83       call renderGopherScreen
 126++84D0 C3 CC 83       jp workLoop
 127++84D3
 128++84D3              pageDn:
 129++84D3 AF               xor a
 129++84D4 32 3B 8B       ld (cursor_position), a
 130++84D7 3A 3A 8B         ld a, (page_offset)
 130++84DA C6 13          add PER_PAGE
 130++84DC 32 3A 8B       ld (page_offset), a
 131++84DF 18 E2            jr pageUp.exit
# file closed: gopher/render/gopher-page.asm
   8+ 84E1                  include "plaintext.asm"
# file opened: gopher/render/plaintext.asm
   1++84E1              renderPlainTextScreen:
   2++84E1 CD 1A 82         call prepareScreen
   3++84E4
   4++84E4              	;поиск и печать первой нужной строки
   5++84E4 3A 3A 8B         ld a, (page_offset)
   5++84E7 47             ld b, a
   5++84E8 CD EF 81       call findLine ;поиск с начала буфера
   6++84EB 7C               ld a, h
   6++84EC B5             or l
   6++84ED 28 2D          jr z, .exit2
   7++84EF AF               xor a
   8++84F0 C6 03            add CURSOR_OFFSET
   8++84F2 57 1E 01       ld d, a, e, 1
   8++84F5 CD 07 80       call TextMode.gotoXY
   9++84F8 CD C0 80         call print70Text
  10++84FB              	;теперь поиск продолжается
  11++84FB
  12++84FB 06 12            ld b, PER_PAGE-1
  13++84FD              .loop
  14++84FD C5               push bc
  15++84FE 3E 13            ld a, PER_PAGE
  15++8500 90             sub b
  16++8501 5F               ld e, a
  16++8502 06 01          ld b, 1
  16++8504 CD F2 81       call Render.findLine2
  17++8507 7C               ld a, h
  17++8508 B5             or l
  17++8509 28 10          jr z, .exit
  18++850B 7B               ld a, e
  19++850C C6 03            add CURSOR_OFFSET
  19++850E 57 1E 01       ld d, a, e, 1
  19++8511 CD 07 80       call TextMode.gotoXY
  20++8514 CD C0 80         call print70Text
  21++8517 C1               pop bc
  22++8518 10 E3            djnz .loop
  23++851A C9               ret
  24++851B              .exit
  25++851B C1               pop bc
  26++851C              .exit2
  27++851C C9               ret
  28++851D
  29++851D              plainTextLoop:
  30++851D CD AD 86         call Console.getC
  31++8520
  32++8520 FE 0A            cp Console.KEY_DN
  32++8522 CA 63 85       jp z, textDown
  33++8525 FE 61            cp 'a'
  33++8527 CA 63 85       jp z, textDown
  34++852A
  35++852A FE 0B            cp Console.KEY_UP
  35++852C CA 71 85       jp z, textUp
  36++852F FE 71            cp 'q'
  36++8531 CA 71 85       jp z, textUp
  37++8534
  38++8534 FE 68            cp 'h'
  38++8536 CA 23 87       jp z, History.home
  39++8539 FE 48            cp 'H'
  39++853B CA 23 87       jp z, History.home
  40++853E
  41++853E FE 62            cp 'b'
  41++8540 CA BA 86       jp z, History.back
  42++8543 FE 42            cp 'B'
  42++8545 CA BA 86       jp z, History.back
  43++8548
  44++8548 FE 0C            cp Console.BACKSPACE
  44++854A CA BA 86       jp z, History.back
  45++854D
  46++854D                  ifdef GS
  47++854D FE 4D            cp 'M'
  47++854F CC 53 A3       call z, GeneralSound.toggleModule
  48++8552 FE 6D            cp 'm'
  48++8554 CC 53 A3       call z, GeneralSound.toggleModule
  49++8557                  endif
  50++8557
  51++8557 FE 53            cp 'S'
  51++8559 CC E2 81       call z, toggleSaveMode
  52++855C FE 73        	cp 's'
  52++855E CC E2 81       call z, toggleSaveMode
  53++8561
  54++8561 18 BA            jr plainTextLoop
  55++8563
  56++8563
  57++8563              textDown:
  58++8563 3A 3A 8B         ld a, (page_offset)
  58++8566 C6 13          add PER_PAGE
  58++8568 32 3A 8B       ld (page_offset), a
  59++856B CD E1 84         call renderPlainTextScreen
  60++856E C3 1D 85         jp plainTextLoop
  61++8571
  62++8571              textUp:
  63++8571 21 3A 8B         ld hl, page_offset
  64++8574 7E               ld a, (hl)
  64++8575 A7             and a
  64++8576 28 A5          jr z, plainTextLoop
  65++8578 D6 13            sub PER_PAGE
  65++857A 77             ld (hl), a
  66++857B CD E1 84         call renderPlainTextScreen
  67++857E C3 1D 85         jp plainTextLoop
# file closed: gopher/render/plaintext.asm
   9+ 8581
  10+ 8581 00           play_next       db  0
  11+ 8582              position        EQU historyBlock.position
  12+ 8582              cursor_position EQU position + 1
  13+ 8582              page_offset     EQU position
  14+ 8582                  ENDMODULE
  15+ 8582
  16+ 8582                  include "dialogbox.asm"
# file opened: gopher/render/dialogbox.asm
   1++8582                  module DialogBox
   2++8582
   3++8582              inputBox:
   4++8582 AF               xor a
   4++8583 32 D7 85       ld (inputBuffer), a
   5++8586              .noclear
   6++8586 CD 38 86         call drawBox
   7++8589              .loop
   8++8589 11 05 0B         ld de, #0B05
   8++858C CD 07 80       call TextMode.gotoXY
   9++858F 21 D7 85         ld hl, inputBuffer
   9++8592 CD 1E 80       call TextMode.printZ
  10++8595 3E 04            ld a, MIME_INPUT
  10++8597 CD 1C 80       call TextMode.putC
  10++859A 3E 20          ld a, ' '
  10++859C CD 1C 80       call TextMode.putC
  11++859F              .checkkey
  12++859F CD AD 86         call Console.getC
  13++85A2 FE 0C            cp Console.BACKSPACE
  13++85A4 28 16          jr z, .removeChar
  14++85A6 FE 0D            cp CR
  14++85A8 C8             ret z
  15++85A9 FE 20            cp SPACE
  15++85AB 38 F2          jr c, .checkkey
  16++85AD              .putC
  17++85AD 5F               ld e, a
  18++85AE AF               xor a
  18++85AF 21 D7 85 01    ld hl, inputBuffer, bc, #ff
  18++85B3 FF 00
  18++85B5 ED B1          cpir
  19++85B7 77               ld (hl), a
  19++85B8 2B             dec hl
  19++85B9 73             ld (hl), e
  20++85BA 18 CD            jr .loop
  21++85BC              .removeChar
  22++85BC AF               xor a
  23++85BD 21 D7 85 01      ld hl, inputBuffer, bc, #ff
  23++85C1 FF 00
  23++85C3 ED B1          cpir
  24++85C5 E5               push hl
  25++85C6 11 D8 85             ld de, inputBuffer + 1
  26++85C9 B7                   or a
  26++85CA ED 52          sbc hl, de
  27++85CC 7C                   ld a, h
  27++85CD B5             or l
  28++85CE E1               pop hl
  29++85CF 28 B8            jr z, .loop
  30++85D1 AF               xor a
  31++85D2 2B               dec hl
  31++85D3 2B             dec hl
  31++85D4 77             ld (hl), a
  32++85D5 18 B2            jr .loop
  33++85D7
  34++85D7 00 00 00...  inputBuffer ds 80
  35++8627
  36++8627              msgBox:
  37++8627 CD 30 86         call msgNoWait
  38++862A 06 96            ld b, 150
  39++862C              .loop
  40++862C                  OS_WAIT
  40++862C DF          >	rst #18
  41++862D 10 FD            djnz .loop
  42++862F C9               ret
  43++8630
  44++8630              msgNoWait:
  45++8630 E5               push hl
  46++8631 CD 38 86         call drawBox
  47++8634 E1               pop hl
  48++8635 C3 1E 80         jp TextMode.printZ
  49++8638
  50++8638              drawBox:
  51++8638 26 0A 3E 09      ld h, #0A, a, BORDER_TOP
  51++863C CD 0C 80       call TextMode.fillLine
  52++863F 26 0B 3E 20      ld h, #0B, a, ' '
  52++8643 CD 0C 80       call TextMode.fillLine
  53++8646 26 0C 3E 08      ld h, #0C, a, BORDER_BOTTOM
  53++864A CD 0C 80       call TextMode.fillLine
  54++864D
  55++864D                  IFNDEF TIMEX80
  56++864D 3E 0A            ld a, #0a
  56++864F CD 16 80       call TextMode.highlightLine
  57++8652 3E 0C            ld a, #0c
  57++8654 CD 16 80       call TextMode.highlightLine
  58++8657                  ENDIF
  59++8657
  60++8657 11 05 0B         ld de, #0B05
  60++865A CD 07 80       call TextMode.gotoXY
  61++865D C9               ret
  62++865E                  endmodule
  63++865E
# file closed: gopher/render/dialogbox.asm
# file closed: gopher/render/index.asm
  18  865E                  include "dos/index.asm"
# file opened: dos/index.asm
   1+ 865E                  IFDEF ESX
   2+ 865E ~                include "esxdos.asm"
   3+ 865E              	ENDIF
   4+ 865E                  IFDEF TRD
   5+ 865E ~                include "trdos.asm"
   6+ 865E              	ENDIF
   7+ 865E                  IFDEF ZSFAT
   8+ 865E                  include "zsfat.asm"
# file opened: dos/zsfat.asm
   1++865E              ;trdos driver (izzx)
   2++865E                  MODULE Dos
   3++865E              ; API methods
   4++865E              ESX_GETSETDRV = #89
   5++865E              ESX_FOPEN = #9A
   6++865E              ESX_FCLOSE = #9B
   7++865E              ESX_FSYNC = #9C
   8++865E              ESX_FREAD = #9D
   9++865E              ESX_FWRITE = #9E
  10++865E
  11++865E              ; File modes
  12++865E              FMODE_READ = #01
  13++865E              FMODE_WRITE = #06
  14++865E              FMODE_CREATE = #0E
  15++865E
  16++865E                  ; MACRO esxCall func
  17++865E                  ; rst #8 : db func
  18++865E                  ; ENDM
  19++865E
  20++865E              ;макросы модуля
  21++865E              ;
  22++865E              ;R8DOS			вызов функции R8DOS
  23++865E              ;R8FAT			вызов функции R8FAT
  24++865E              ;R8DOSc			вызов функции R8DOS
  25++865E              ;
  26++865E              ;------------------------------------------------------------------------------
  27++865E              ;вызов функции R8DOS
  28++865E              ;вх: =0 номер функции
  29++865E              ;
  30++865E              	; MACRO	R8DOS nFunc
  31++865E              	; ld	c,nFunc
  32++865E              	; rst	#08
  33++865E              	; db	#81
  34++865E              	; ENDM
  35++865E
  36++865E              ; ;------------------------------------------------------------------------------
  37++865E              ; ;вызов функции R8FAT
  38++865E              ; ;вх: =0 номер функции
  39++865E              ; ;
  40++865E              	; MACRO	R8FAT nFunc
  41++865E              	; ld	c,nFunc
  42++865E              	; rst	#08
  43++865E              	; db	#91
  44++865E              	; ENDM
  45++865E
  46++865E              ; ;------------------------------------------------------------------------------
  47++865E              ; ;вызов функции R8DOS
  48++865E              ; ;вх: c - номер функции
  49++865E              ; ;
  50++865E              	; MACRO	R8DOSc
  51++865E              	; rst	#08
  52++865E              	; db	#81
  53++865E              	; ENDM
  54++865E
  55++865E              ; ;------------------------------------------------------------------------------
  56++865E              ; ;вызов функции #02 (FileMan) R8CONF
  57++865E              ; ;вх: =#00 - номер функции файл менеджера
  58++865E              ; ;
  59++865E              	; MACRO	R8C02FM nFunct
  60++865E              	; ld	bc,#100*nFunct+#02
  61++865E              	; rst	#08
  62++865E              	; db	#8E
  63++865E              	; ENDM
  64++865E
  65++865E              ;==============================================================================
  66++865E              ; r8f00_DeinitFAT		equ #00
  67++865E              ; r8f01_InitFAT		equ #01
  68++865E              ; r8f04_FindPath		equ #04
  69++865E              ; r8f07_FileOpen		equ #07 ;открыть файл для последующих операций с ним
  70++865E              ; r8f09_FileWrite		equ #09	;запись данных из памяти в файл
  71++865E              ; r8f0E_CreateFileLFN	equ #0E ;создание файла с длинным именем в текущем каталоге
  72++865E              ; r8f0F_CreateFileSFN	equ #0F
  73++865E
  74++865E              ; r8d2D_FindPart		equ #2D
  75++865E              ; r8d2E_CngHDD		equ #2E
  76++865E
  77++865E
  78++865E              ;id = 0 файл не открыт
  79++865E              ;id = 1 файл для чтения trdos
  80++865E              ;id = 2 файл для записи trdos
  81++865E              ;id = 3 файл для записи тип TRD trdos
  82++865E              ;id = 4 файл для записи тип SCL trdos
  83++865E              ;id = 5 файл для чтения fat32 (пока не сделано)
  84++865E              ;id = 6 файл для записи fat32
  85++865E
  86++865E              ; HL - filename in ASCIIZ
  87++865E              loadBuffer:
  88++865E 06 01            ld b, Dos.FMODE_READ
  88++8660 CD 7A 86       call Dos.fopen
  89++8663 F5               push af
  90++8664 21 5F A3 01          ld hl, outputBuffer, bc, #ffff - outputBuffer
  90++8668 A0 5C
  90++866A CD 97 86       call Dos.fread
  91++866D 21 5F A3             ld hl, outputBuffer
  91++8670 09             add hl, bc
  91++8671 AF             xor a
  91++8672 77             ld (hl), a
  91++8673 23             inc hl
  91++8674 77             ld (hl), a
  92++8675 F1               pop af
  93++8676 CD 93 86         call Dos.fclose
  94++8679 C9               ret
  95++867A
  96++867A
  97++867A              ; Returns:
  98++867A              ;  A - current drive
  99++867A              ; getDefaultDrive: ;нигде не используется
 100++867A                  ; ld a, 0 : esxCall ESX_GETSETDRV
 101++867A                  ; ret
 102++867A
 103++867A
 104++867A
 105++867A              ; Opens file on default drive
 106++867A              ; B - File mode
 107++867A              ; HL - File name
 108++867A              ; Returns:
 109++867A              ;  A - file stream id
 110++867A              fopen:
 111++867A                  ; push bc : push hl
 112++867A                  ; call getDefaultDrive
 113++867A                  ; pop ix : pop bc
 114++867A                  ; esxCall ESX_FOPEN
 115++867A                  ; ret
 116++867A 78           	ld a,b
 117++867B FE 01        	cp FMODE_READ ;если режим открытие файла
 118++867D 28 06        	jr z,fopen_r
 119++867F FE 0E        	cp FMODE_CREATE
 120++8681 28 08        	jr z,fopen_c ;если режим создание файла
 121++8683 18 04        	jr fopen_err ;иначе выход
 122++8685
 123++8685              fopen_r	;открытие существующего файла на чтение (id=1)
 124++8685
 125++8685              	;call format_name ;
 126++8685
 127++8685              	OS_FILE_OPEN
 127++8685 0E 21       >    ld c,#21
 127++8687 E7          >    rst #20
 128++8688 C9           	ret
 129++8689              	; ld a,(#5D19) ;номер дисковода по умолчанию
 130++8689              	; ld 	(prev_drive),a ;запомним
 131++8689              			;call format_name ;
 132++8689              			; ld      c,#13 ;move file info to syst var
 133++8689                          ; call    call3d13
 134++8689                          ; ld      c,#0a ;find file
 135++8689                          ; call    call3d13
 136++8689                          ; ld      a,c
 137++8689              			; cp 		#ff
 138++8689              			; jr 		z,fopen_err ;если не нашли файла
 139++8689                          ; ld      c,#08 ;read file title
 140++8689                          ; call    call3d13
 141++8689                          ; ;ld      hl,loadadr ;куда
 142++8689                          ; ld      de,(#5ceb) ;начало файла сектор дорожка
 143++8689                          ; ld      (f_r_cur_trk),de
 144++8689
 145++8689                          ; ld      a,(#5cea)
 146++8689                          ; ld      (f_r_len_sec),a ;длина в секторах
 147++8689                          ; ;or      a
 148++8689                          ; ;ret     z    ;выход если пустой
 149++8689
 150++8689              			; ld de,(#5CE8) ; длина файла или программной части для BASIC
 151++8689              			; ld      (f_r_len),de
 152++8689
 153++8689                          ; ; ld      de,(fcurtrk) ;текущие сектор дорожка
 154++8689                          ; ; ld      (#5cf4),de ;восстановим
 155++8689              			; xor a
 156++8689              			; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 157++8689              			; ld 		a,1
 158++8689              			; ld (f_r_flag),a ;флаг что файл для чтения открыт
 159++8689              			; ;id канала будет 1
 160++8689              	;ret
 161++8689
 162++8689              fopen_err
 163++8689              	; ld a,1
 164++8689              	; ld (com_file_err_flag),a
 165++8689              	; xor a ;если никакой файл не открыли, то id = 0
 166++8689 37           	scf ;флаг ошибки
 167++868A C9           	ret
 168++868B
 169++868B
 170++868B              fopen_c	;создание нового файла (id=2-4,6)
 171++868B              	; ld a,(#5D19) ;номер дисковода по умолчанию
 172++868B              	; ld 	(prev_drive),a ;запомним
 173++868B
 174++868B              	;call format_name ;
 175++868B              	OS_FILE_OPEN ;если есть, откроем
 175++868B 0E 21       >    ld c,#21
 175++868D E7          >    rst #20
 176++868E D0           	ret nc
 177++868F
 178++868F              	OS_FILE_CREATE ;или создадим
 178++868F 0E 22       >    ld c,#22
 178++8691 E7          >    rst #20
 179++8692 C9           	ret
 180++8693
 181++8693              	; call select_drive
 182++8693              	; cp "y"
 183++8693              	; jr nz,fopen_err
 184++8693
 185++8693              	; ld a,(curr_drive)
 186++8693              	; cp 4
 187++8693              	; jp nc,fopen_c_fat ;если выбран FAT
 188++8693
 189++8693              	; ;выясним, не образ ли это для разворачивания
 190++8693                  ; ld hl, trdExt1 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 191++8693                  ; ld hl, trdExt2 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 192++8693              	; ld hl, sclExt1 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 193++8693                  ; ld hl, sclExt2 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 194++8693
 195++8693
 196++8693              	; ;создание произвольного файла (id=2)
 197++8693              	; call cat_buf_cls
 198++8693
 199++8693              	; ld hl,cat_buf ;считаем каталог диска
 200++8693              	; ld de,0
 201++8693                  ; ld      bc,#0905 ;
 202++8693                  ; call    call3d13
 203++8693
 204++8693              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 205++8693              	; cp 128
 206++8693              	; jp c,fopen_c2 ;если уже максимум
 207++8693                  ; ld hl, file_err
 208++8693                  ; call DialogBox.msgBox ;предуреждение
 209++8693              	; jr fopen_err
 210++8693
 211++8693              ; fopen_c2
 212++8693              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 213++8693              	; ld a,h
 214++8693              	; or l
 215++8693              	; jr nz,fopen_c3 ;если ещё есть место
 216++8693                  ; ld hl, file_err
 217++8693                  ; call DialogBox.msgBox ;предуреждение
 218++8693              	; jr fopen_err
 219++8693
 220++8693              ; fopen_c3
 221++8693              	; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 222++8693                  ; ld   (#5cf4),de ;отсюда будем писать файл
 223++8693
 224++8693              	; xor a
 225++8693              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 226++8693              	; ld (sec_shift),a ;переменная
 227++8693              	; ld hl,0
 228++8693              	; ld (f_w_len+0),hl
 229++8693              	; ld (f_w_len+2),hl
 230++8693              	; ld a,2 ;id канала
 231++8693              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 232++8693              	; ret
 233++8693
 234++8693
 235++8693              ; cat_buf_cls ;очистка буфера каталога
 236++8693              	; ld hl,cat_buf ;очистить место для каталога дискеты
 237++8693              	; ld de,cat_buf+1
 238++8693              	; ld (hl),0
 239++8693              	; ld bc,9*256-1
 240++8693              	; ldir
 241++8693              	; ret
 242++8693
 243++8693
 244++8693
 245++8693              ; fopen_c_trd	;открытие файла для разворачивания образа trd (id=3)
 246++8693              	; call select_drive
 247++8693              	; cp "y"
 248++8693              	; jp nz,fopen_err
 249++8693
 250++8693              	; ld      de,0 ;начало сектор дорожка
 251++8693                  ; ld      (#5cf4),de
 252++8693
 253++8693              	; xor a
 254++8693              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 255++8693              	; ld (sec_shift),a ;переменная
 256++8693              	; ld hl,0
 257++8693              	; ld (f_w_len+0),hl
 258++8693              	; ld (f_w_len+2),hl
 259++8693              	; ld a,3 ;id канала
 260++8693              	; ld (f_w_flag),a ;флаг что trd для записи открыт
 261++8693              	; ret
 262++8693
 263++8693
 264++8693
 265++8693              ; fopen_c_scl	;открытие файла для разворачивания образа scl (id=4)
 266++8693              	; call select_drive
 267++8693              	; cp "y"
 268++8693              	; jp nz,fopen_err
 269++8693
 270++8693              	; ld      de,0 ;начало сектор дорожка
 271++8693                  ; ld      (#5cf4),de
 272++8693
 273++8693              	; call cat_buf_cls ;почистить место
 274++8693
 275++8693              	; call scl_parse ;запуск цикла сборки образа
 276++8693
 277++8693              	; xor a
 278++8693              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 279++8693              	; ld (sec_shift),a ;переменная
 280++8693              	; ;ld (scl_que),a
 281++8693              	; ld hl,0
 282++8693              	; ld (f_w_len+0),hl
 283++8693              	; ld (f_w_len+2),hl
 284++8693              	; ld a,4 ;id канала
 285++8693              	; ld (f_w_flag),a ;флаг что scl для записи открыт
 286++8693              	; ret
 287++8693
 288++8693
 289++8693
 290++8693
 291++8693              ; fopen_c_fat	;создание файла FAT (id=6)
 292++8693
 293++8693              ; ;переинициализация FAT раздела
 294++8693              	; R8FAT	r8f00_DeinitFAT
 295++8693              	; jp 		c,fopen_err
 296++8693
 297++8693              	; ld a,(curr_drive)
 298++8693              	; ld bc,typeDrive-4
 299++8693              	; ld l,a
 300++8693              	; ld h,0
 301++8693              	; add hl,bc
 302++8693              	; ld a,(hl) ;получили код раздела из списка
 303++8693              	; rlca
 304++8693              	; rlca
 305++8693              	; rlca
 306++8693              	; rlca
 307++8693              	; and %11110000
 308++8693                  ; ;         ld      a,%0000????
 309++8693                                     ; ; ││└┴─── номер раздела
 310++8693                                     ; ; │└───── master/slave для Hdd
 311++8693                                     ; ; └────── SD/Hdd
 312++8693              	; R8FAT	r8f01_InitFAT
 313++8693                  ; jp      c,fopen_err
 314++8693
 315++8693              ; ;поиск пути в разделе
 316++8693              	; ld	hl,ActPathFAT		;путь к каталогу Download
 317++8693              	; ld	de,fcb
 318++8693              	; xor	a
 319++8693              	; dec	a
 320++8693              	; R8FAT	r8f04_FindPath
 321++8693                  ; ;jp      c,fopen_err ;если не нашли, файл будет в корне
 322++8693
 323++8693              	; ld	hl,(temp_hl)		;строка с именем
 324++8693              	; ld	de,fcb
 325++8693              	; R8FAT r8f07_FileOpen
 326++8693              	; jp 	nc,fopen_c_fat2 ;если файл есть, откроем
 327++8693
 328++8693              ; ;создание файла, если нет
 329++8693              	; ld	hl,(temp_hl)		;строка с именем
 330++8693              	; xor	a
 331++8693              	; ld	(fcb+#14+0),a
 332++8693              	; ld	(fcb+#14+1),a
 333++8693              	; ld	(fcb+#14+2),a	;установим размер
 334++8693              	; ld	(fcb+#14+3),a
 335++8693              	; ld	de,fcb
 336++8693              	; R8FAT	r8f0E_CreateFileLFN	;создание файла
 337++8693              	; jp 	c,fopen_err
 338++8693
 339++8693              ; fopen_c_fat2
 340++8693
 341++8693              	; ld hl,0
 342++8693              	; ld (f_w_len+0),hl
 343++8693              	; ld (f_w_len+2),hl
 344++8693              	; xor a
 345++8693              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 346++8693              	; ld a,6 ;id канала
 347++8693              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 348++8693              	; ret
 349++8693
 350++8693
 351++8693
 352++8693
 353++8693
 354++8693              ; select_drive	;запрос номера дисковода
 355++8693              	; ld a,(hdd_init_flag) ;если в первый раз
 356++8693              	; or a
 357++8693              	; jr nz,select_drive2
 358++8693              	; ld a,(#5D19) ;номер дисковода по умолчанию
 359++8693              	; ld (curr_drive),a
 360++8693              	; call GetNumPart ;узнаем какая буква последняя, сколько разделов ФАТ
 361++8693              	; add "D"
 362++8693              	; ld (write_ima_e),a	;выбор до этой буквы
 363++8693              	; sub "D"
 364++8693              	; inc a
 365++8693              	; add "d"
 366++8693              	; ld (next_lett),a ;эта буква первая свободная
 367++8693              	; ld a,1
 368++8693              	; ld (hdd_init_flag),a
 369++8693              ; select_drive2
 370++8693              	; ld a,(curr_drive) ;номер дисковода по умолчанию
 371++8693              	; add a,"A"
 372++8693              	; ld (write_ima_d),a ;подставим букву в запросе
 373++8693                  ; ld hl, write_ima
 374++8693                  ; call DialogBox.msgNoWait ;текст запроса
 375++8693              ; select_drive_wait
 376++8693              	; ;halt
 377++8693              	; call Console.getC
 378++8693              	; cp 255
 379++8693              	; JR Z,select_drive_wait	;ждём любую клавишу
 380++8693              	; cp "y"
 381++8693              	; jr z,select_drive_ex
 382++8693              	; cp "n"
 383++8693              	; ret z
 384++8693              	; cp "a" ;от буквы A
 385++8693              	; jr c,select_drive_wait
 386++8693              	; ld hl,next_lett
 387++8693              	; cp (hl) ;до первой свободной буквы
 388++8693              	; jr nc,select_drive_wait
 389++8693              	; sub "a"
 390++8693              	; ld (curr_drive),a ;новый номер диска
 391++8693              	; jr select_drive2 ;обновить строку
 392++8693              ; select_drive_ex ;выход
 393++8693              	; ld a,(curr_drive)
 394++8693              	; cp 4 ;начиная с буквы E идёт HDD
 395++8693              	; jr nc,select_drive3
 396++8693                  ; ld      (#5d19) ,a ;если дискета, настроим trdos
 397++8693                  ; ld      c,1
 398++8693                  ; call    call3d13
 399++8693                  ; ld      c,#18
 400++8693                  ; call    call3d13
 401++8693              ; select_drive3
 402++8693              	; ld a,"y"
 403++8693              	; ret
 404++8693
 405++8693
 406++8693              ; ; restore_drive ;восстановить дисковод по умолчанию
 407++8693              	; ; ld 	a,(prev_drive)
 408++8693                  ; ; ld      (#5d19) ,a
 409++8693                  ; ; ld      c,1
 410++8693                  ; ; call    call3d13
 411++8693                  ; ; ld      c,#18
 412++8693                  ; ; call    call3d13
 413++8693              	; ; ret
 414++8693
 415++8693
 416++8693              ; call3d13 ;фикс для GMX
 417++8693              	; ifndef ZSGMX
 418++8693                  ; jp    #3d13
 419++8693              	; endif
 420++8693
 421++8693              	; ; ifdef ZSGMX
 422++8693                  ; ; call    #3d13
 423++8693              	; ; exx
 424++8693              	; ; call TextMode.gmxscron
 425++8693              	; ; exx
 426++8693              	; ; endif
 427++8693              	; ret
 428++8693
 429++8693
 430++8693
 431++8693              ; A - file stream id
 432++8693              fclose:
 433++8693              	OS_FILE_CLOSE
 433++8693 0E 25       >    ld c,#25
 433++8695 E7          >    rst #20
 434++8696 C9           	ret
 435++8697
 436++8697                  ; ;esxCall ESX_FCLOSE
 437++8697              	; ; push af
 438++8697              	; ; pop af
 439++8697              	; cp 2 ;если обычный файл
 440++8697              	; jp nz,fclose_scl
 441++8697
 442++8697              	; ;дописать остаток файла
 443++8697              	; ld a,(write_end_flag) ;нужно записывать остаток?
 444++8697              	; or a
 445++8697              	; jr nz,fclose_f ;не нужно
 446++8697
 447++8697              	; ld hl,sec_buf
 448++8697              	; ld bc,#0106
 449++8697              	; ld de,(#5cf4)
 450++8697              	; call call3d13
 451++8697
 452++8697              	; ld a,"0" ;номер части файла
 453++8697              	; ld (file_num),a
 454++8697
 455++8697              ; fclose_f ;поправить каталог
 456++8697              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 457++8697              	; ld hl,(f_w_len+0)
 458++8697              	; or h
 459++8697              	; or l
 460++8697              	; jp z,fclose_ex ;выход если длина 0
 461++8697
 462++8697              	; ;проверки на заполнение
 463++8697              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 464++8697              	; cp 128
 465++8697              	; jp nc,fclose_ex ;если уже максимум
 466++8697              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 467++8697              	; ld a,h
 468++8697              	; or l
 469++8697              	; jp z,fclose_ex ;если места нет
 470++8697
 471++8697              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 472++8697              	; or a
 473++8697              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 474++8697              	; ld a,(f_w_len+1)
 475++8697              	; cp 255
 476++8697              	; jr nz,fclose_f1
 477++8697              	; ld a,(f_w_len+0)
 478++8697              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 479++8697              ; fclose_f1
 480++8697              	; ;файл не превышает максимальный размер для trdos
 481++8697              	; ld de,(f_w_len+0)
 482++8697              	; ld hl,f_name+11 ;длина файла
 483++8697              	; ld (hl),e
 484++8697              	; inc hl
 485++8697              	; ld (hl),d
 486++8697              	; inc hl
 487++8697              	; ld a,(f_w_len+1) ;длина секторов
 488++8697              	; ld (hl),a
 489++8697              	; ld a,(f_w_len+0) ;длина младший
 490++8697              	; or a
 491++8697              	; jr z,fclose_f2
 492++8697              	; inc (hl) ;коррекция секторов
 493++8697              ; fclose_f2
 494++8697              	; call fclose_f_one ;записать информацию
 495++8697              	; jp fclose_ex ;готово
 496++8697
 497++8697              ; fclose_f_multi ;файл большой, будет несколько записей в каталоге
 498++8697              	; ld a,(file_num)
 499++8697              	; ld (f_name+7),a ;в конце имени номер
 500++8697
 501++8697              	; ld hl,f_name+11 ;длина файла
 502++8697              	; ld (hl),0
 503++8697              	; inc hl
 504++8697              	; ld (hl),#ff ;65280
 505++8697              	; inc hl
 506++8697              	; ;длина секторов
 507++8697              	; ld (hl),#ff
 508++8697              	; call fclose_f_one ;записать информацию
 509++8697
 510++8697              	; ;вычесть длину записанного
 511++8697              	; ld hl,(f_w_len+1) ;старший и средний байт
 512++8697              	; ld bc,255
 513++8697              	; and a
 514++8697              	; sbc hl,bc ;вычесть 255 секторов
 515++8697              	; ld (f_w_len+1),hl
 516++8697
 517++8697              	; ld a,(file_num)
 518++8697              	; inc a
 519++8697              	; ld (file_num),a
 520++8697              	; ld (f_name+7),a ;в конце имени номер
 521++8697
 522++8697              	; jr fclose_f ;сначала
 523++8697
 524++8697
 525++8697              ; fclose_f_one ;запись об одном файле
 526++8697              			; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 527++8697              			; ld l,a ;узнать в каком секторе будет запись о файле
 528++8697              			; ld h,0
 529++8697              			; add hl,hl ;*2
 530++8697              			; add hl,hl ;*4
 531++8697              			; add hl,hl ;*8
 532++8697              			; add hl,hl ;*16
 533++8697              			; ld a,h ;запомнить номер сетора в каталоге
 534++8697              			; ld (sec_cat),a
 535++8697              			; ld bc,cat_buf
 536++8697              			; add hl,bc ;здесь будет запись о новом файле
 537++8697              			; ex de,hl
 538++8697
 539++8697              			; ld hl,f_name ;запись о файле
 540++8697              			; ld bc,16
 541++8697              			; ldir ;скопировать
 542++8697              			; ex de,hl
 543++8697              			; dec hl
 544++8697              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка назначения
 545++8697              			; ld (hl),d ;дорожка
 546++8697              			; dec hl
 547++8697              			; ld (hl),e ;сектор
 548++8697
 549++8697              			; ld l,0 ;записать сектор целиком по ровному адресу
 550++8697              			; ld d,0
 551++8697              			; ld a,(sec_cat)
 552++8697              			; ld e,a ;номер сектора
 553++8697              			; ld bc,#0106 ;1 сектор записать
 554++8697              			; call call3d13
 555++8697
 556++8697              			; ;служебный сектор
 557++8697              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 558++8697              			; ld a,(f_name+13) ;размер файла в секторах
 559++8697              			; ld b,a
 560++8697              			; call calc_next_pos2
 561++8697              			; ld (cat_buf+8*256+#e1),de
 562++8697
 563++8697              			; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 564++8697              			; ld a,(f_name+13) ;размер файла в секторах
 565++8697              			; ld c,a
 566++8697              			; ld b,0
 567++8697              			; and a
 568++8697              			; sbc hl,bc
 569++8697              			; jr nc,fclose_f_one2
 570++8697              			; ld hl,0 ;если было отрицательное
 571++8697              ; fclose_f_one2
 572++8697              			; ld (cat_buf+8*256+#e5),hl
 573++8697
 574++8697              			; ld hl,cat_buf+8*256+#e4 ; общее количество файлов
 575++8697              			; inc (hl)
 576++8697
 577++8697              			; ld hl,cat_buf+8*256
 578++8697              			; ld de,#0008
 579++8697              			; ld bc,#0106 ;1 сектор записать
 580++8697              			; call call3d13
 581++8697              			; ret
 582++8697
 583++8697
 584++8697              ; fclose_scl
 585++8697              	; cp 4 ;если scl
 586++8697              	; jr nz,fclose_ex
 587++8697              	; ld hl,sec_buf ;
 588++8697              	; ld b,1
 589++8697              	; call scl_write_buf ;допишем остаток scl, если есть
 590++8697
 591++8697              ; fclose_ex
 592++8697              	; xor a ;закрываем все файлы
 593++8697              	; ld (f_r_flag),a
 594++8697              	; ld (f_w_flag),a
 595++8697
 596++8697              	; ld a,(com_file_err_flag) ;была ли ошибка
 597++8697              	; or a
 598++8697              	; ret z
 599++8697              	; ld a,2 ;если была
 600++8697              	; out (254),a ;бордюр красный
 601++8697                  ; ld hl, com_file_err ;общая ошибка
 602++8697                  ; call DialogBox.msgBox ;предуреждение
 603++8697              	; xor a ;
 604++8697              	; out (254),a
 605++8697              	; ;call restore_drive ;вернуть диск, какой был
 606++8697                  ; ret
 607++8697
 608++8697
 609++8697
 610++8697
 611++8697              ; A - file stream id
 612++8697              ; BC - length
 613++8697              ; HL - buffer
 614++8697              ; Returns
 615++8697              ;  BC - length(how much was actually read)
 616++8697              fread: ;(id=1)
 617++8697 59           	ld e,c ;сохранить длину
 618++8698 50           	ld d,b
 619++8699              	OS_FILE_READ
 619++8699 0E 23       >    ld c,#23
 619++869B E7          >    rst #20
 620++869C C9           	ret
 621++869D
 622++869D                  ; push hl : pop ix
 623++869D                  ; esxCall ESX_FREAD
 624++869D              	; push af
 625++869D              	; ld a,4
 626++869D              	; out (254),a
 627++869D              	; xor a
 628++869D              	; out (254),a
 629++869D              	; pop af
 630++869D
 631++869D              	; cp 1 ;id = 1?
 632++869D              	; jr nz,fread_no_chek ;выход если номер потока не = 1
 633++869D              	; ld a,(f_r_flag)
 634++869D              	; or a
 635++869D              	; jr nz,fread_chek ;файл уже открыт?
 636++869D              ; fread_no_chek ;выход с ошибкой
 637++869D              	; xor a
 638++869D              	; scf ;флаг ошибки
 639++869D              	; ld bc,0 ;ничего мы не считали
 640++869D              	; ret
 641++869D
 642++869D              ; fread_chek
 643++869D              	; ld bc,(f_r_len_sec-1) ;загружаем файл целиком, не смотря на то, сколько байт было запрошено
 644++869D                  ; ld      c,5 ;read читаем целыми секторами
 645++869D              	; ld de,(f_r_cur_trk)
 646++869D                  ; call    call3d13
 647++869D              	; ld bc,(f_r_len) ;возвратим сколько считали байт (длину файла)
 648++869D              	; xor a ;флаги сбросим
 649++869D                  ; ret
 650++869D
 651++869D              ; A - file stream id
 652++869D              ; BC - length
 653++869D              ; HL - buffer
 654++869D              ; Returns:
 655++869D              ;   BC - actually written bytes
 656++869D              fwrite: ;
 657++869D 59           	ld e,c ;сохранить длину
 658++869E 50           	ld d,b
 659++869F              	OS_FILE_WRITE
 659++869F 0E 24       >    ld c,#24
 659++86A1 E7          >    rst #20
 660++86A2 C9           	ret
 661++86A3
 662++86A3                  ; push hl : pop ix
 663++86A3                  ; esxCall ESX_FWRITE
 664++86A3
 665++86A3              	; push af
 666++86A3              	; ld a,2
 667++86A3              	; out (254),a
 668++86A3
 669++86A3              	; xor a
 670++86A3              	; out (254),a
 671++86A3              	; pop af
 672++86A3
 673++86A3              	; cp 2 ;id = 2?
 674++86A3              	; jr z,fwrite_chek ;проверка id потока
 675++86A3              	; cp 3 ;id = 3?
 676++86A3              	; jr z,fwrite_chek_trd ;проверка id потока
 677++86A3              	; cp 4 ;id = 4?
 678++86A3              	; jp z,fwrite_chek_scl ;проверка id потока
 679++86A3              	; cp 6 ;id = 6?
 680++86A3              	; jp z,fwrite_chek_fat ;проверка id потока
 681++86A3
 682++86A3
 683++86A3              ; fwrite_no_chek ;выход с ошибкой
 684++86A3              	; ld a,1
 685++86A3              	; ld (com_file_err_flag),a
 686++86A3              	; xor a
 687++86A3              	; scf ;флаг ошибки
 688++86A3              	; ld bc,0 ;ничего мы не записали
 689++86A3              	; ret
 690++86A3
 691++86A3              ; fwrite_chek ;запись произвольного типа файла (id=2)
 692++86A3
 693++86A3              	; ;не отличается от записи trd, пишется входящий поток на диск, отличия при открытии и закрытии файла
 694++86A3
 695++86A3
 696++86A3
 697++86A3
 698++86A3
 699++86A3              ; fwrite_chek_trd ;запись trd файла (разворачивание образа, id=3)
 700++86A3              	; ; ld a,2
 701++86A3              	; ; out (254),a
 702++86A3
 703++86A3              	; ; xor a
 704++86A3              	; ; out (254),a
 705++86A3              	; ld a,(f_w_flag)
 706++86A3              	; or a
 707++86A3              	; jr z,fwrite_no_chek ;файл уже открыт?
 708++86A3              	; ld (temp_bc),bc ;длина
 709++86A3              	; ld (temp_hl),hl ;адрес данных
 710++86A3              	; ld a,b
 711++86A3              	; or c
 712++86A3              	; jr z,fwrite_no_chek ; если длина 0, то выход
 713++86A3
 714++86A3              	; ;защита от переполнения диска
 715++86A3              	; ld de,(#5cf4)
 716++86A3              	; ld a,d
 717++86A3              	; cp #a0 ;последняя дорожка 160
 718++86A3              	; jr nc,fwrite_no_chek
 719++86A3
 720++86A3              	; xor a
 721++86A3              	; ld (sec_part),a ;обнулить переменные
 722++86A3              	; ld (sec_shift2),a
 723++86A3              	; ld (sec_shift2+1),a
 724++86A3              	; ld (sec_shift_flag),a
 725++86A3              	; ld (write_end_flag),a ;
 726++86A3
 727++86A3
 728++86A3              	; ld a,(sec_shift)
 729++86A3              	; or a
 730++86A3              	; jr z,fwrite_trd3 ;если смещения нет, то первую часть пропустим
 731++86A3
 732++86A3
 733++86A3              	; ld c,a
 734++86A3              	; ld b,0
 735++86A3              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 736++86A3              	; add hl,bc
 737++86A3
 738++86A3              	; ld a,1
 739++86A3              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 740++86A3
 741++86A3              	; ld a,h
 742++86A3              	; or a
 743++86A3              	; jr nz,fwrite_trd4
 744++86A3              	; ld a,1
 745++86A3              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 746++86A3
 747++86A3              ; fwrite_trd4
 748++86A3              	; ld hl,sec_buf ;буфер последнего сектора
 749++86A3              	; add hl,bc ;на этой точке остановились
 750++86A3              	; ex de,hl
 751++86A3              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 752++86A3              	; ; ld a,c
 753++86A3              	; ; or a
 754++86A3              	; ; jr nz,fwrite_trd2
 755++86A3              	; ; inc b ;коррекция
 756++86A3              ; ; fwrite_trd2
 757++86A3              	; ; ld c,a
 758++86A3              	; xor a
 759++86A3              	; sub c
 760++86A3              	; ld c,a ;сколько осталось перенести до заполнения сектора
 761++86A3              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 762++86A3              	; ldir
 763++86A3
 764++86A3              	; ld a,(sec_shift_flag)
 765++86A3              	; or a
 766++86A3              	; jr nz,fwrite_trd3 ;если сектор ещё не заполнен писать не будем
 767++86A3
 768++86A3              	; ld hl,sec_buf
 769++86A3              	; ld de,(#5cf4)
 770++86A3              	; ;ld (f_w_cur_trk),de	;запомним позицию
 771++86A3                  ; ld      bc,#0106 ;пишем 1 сектор из буфера
 772++86A3                  ; call    call3d13
 773++86A3              	; ld a,c
 774++86A3              	; cp 255
 775++86A3              	; jp z,fwrite_no_chek ;выход если ошибка
 776++86A3
 777++86A3              	; xor a
 778++86A3              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 779++86A3              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 780++86A3              	; ; ld (#5cf4),de
 781++86A3              	; ; ld b,1 ;на сектор вперёд
 782++86A3              	; ; ld de,(f_w_cur_trk)
 783++86A3              	; ; call calc_next_pos
 784++86A3              	; ; ld (f_w_cur_trk),de
 785++86A3
 786++86A3              ; fwrite_trd3
 787++86A3              	; ld hl,(temp_hl) ;запишем остаток данных
 788++86A3              	; ;ld a,(sec_shift)
 789++86A3              	; ;ld c,a
 790++86A3              	; ;ld b,0
 791++86A3              	; ld bc,(sec_shift2)
 792++86A3              	; add hl,bc ;с этой точки пишем
 793++86A3              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 794++86A3
 795++86A3              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 796++86A3              	; and a
 797++86A3              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 798++86A3              	; ld c,l
 799++86A3              	; ld b,h
 800++86A3              	; jr nc,fwrite_trd5
 801++86A3              	; ld b,0 ;коррекция если вышел минус
 802++86A3              ; fwrite_trd5
 803++86A3              	; ld hl,(temp_hl)
 804++86A3              	; add hl,bc
 805++86A3
 806++86A3              	; ld de,outputBuffer
 807++86A3              	; and a
 808++86A3              	; sbc hl,de
 809++86A3
 810++86A3              	; ld a,l
 811++86A3              	; ld (sec_shift),a ;смещение на следующий раз
 812++86A3              	; ;ld hl,(temp_hl)
 813++86A3
 814++86A3
 815++86A3              	; ; or a
 816++86A3              	; ; jr z,fwrite_trd1
 817++86A3              	; ; inc b  ;коррекция количества секторов
 818++86A3
 819++86A3              	; ld a,b ;нужна проверка на количество секторов!!!
 820++86A3              	; ld (sec_part),a ;запомним сколько секторов во второй части
 821++86A3
 822++86A3              	; ;ld a,b
 823++86A3              	; or a
 824++86A3              	; jr z,fwrite_trd1 ;если размер данных меньше сектора, то пропустим запись
 825++86A3
 826++86A3              	; ld hl,(temp_hl2)
 827++86A3              	; ;push bc
 828++86A3              	; ld de,(#5cf4)
 829++86A3                  ; ld      c,6 ;пишем целыми секторами
 830++86A3                  ; call    call3d13
 831++86A3              	; ld a,c
 832++86A3              	; ;pop bc
 833++86A3              	; cp 255
 834++86A3              	; jp z,fwrite_no_chek ;выход если ошибка
 835++86A3              	; ; ld de,(f_w_cur_trk)
 836++86A3              	; ; call calc_next_pos
 837++86A3              	; ; ld (f_w_cur_trk),de
 838++86A3
 839++86A3              	; xor a
 840++86A3              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 841++86A3
 842++86A3              ; fwrite_trd1
 843++86A3              	; ld a,(write_end_flag) ;нужно записывать остаток?
 844++86A3              	; or a
 845++86A3              	; jr nz,fwrite_trd_ex ;не нужно
 846++86A3
 847++86A3              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
 848++86A3              	; ld a,(sec_part)
 849++86A3              	; ld b,a
 850++86A3              	; ld c,0
 851++86A3              	; add hl,bc
 852++86A3              	; ld de,sec_buf
 853++86A3              	; ld bc,256
 854++86A3              	; ldir
 855++86A3              ; ;fwrite_trd2
 856++86A3
 857++86A3
 858++86A3              ; fwrite_trd_ex
 859++86A3              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 860++86A3              	; ;посчитаем общую длину записанного
 861++86A3              	; ld hl,(f_w_len)
 862++86A3              	; add hl,bc
 863++86A3              	; ld (f_w_len),hl
 864++86A3              	; jr nc,fwrite_trd_ex1
 865++86A3              	; ld hl,(f_w_len+2)
 866++86A3              	; inc hl
 867++86A3              	; ld (f_w_len+2),hl
 868++86A3
 869++86A3              ; fwrite_trd_ex1
 870++86A3              	; xor a ;флаги сбросим
 871++86A3                  ; ret
 872++86A3
 873++86A3
 874++86A3
 875++86A3
 876++86A3
 877++86A3              ; ;------------------scl----------------------
 878++86A3              ; fwrite_chek_scl ;запись scl файла (разворачивание образа, id=4)
 879++86A3              	; ; ld a,2
 880++86A3              	; ; out (254),a
 881++86A3
 882++86A3              	; ; xor a
 883++86A3              	; ; out (254),a
 884++86A3              	; ld a,(f_w_flag)
 885++86A3              	; or a
 886++86A3              	; jp z,fwrite_no_chek ;файл уже открыт?
 887++86A3              	; ld (temp_bc),bc ;длина
 888++86A3              	; ld (temp_hl),hl ;адрес данных
 889++86A3              	; ld a,b
 890++86A3              	; or c
 891++86A3              	; jp z,fwrite_no_chek ; если длина 0, то выход
 892++86A3
 893++86A3              	; ; ld a,b
 894++86A3              	; ; or a
 895++86A3              	; ; jr nz,testt1
 896++86A3              	; ; nop
 897++86A3
 898++86A3              ; ; testt1
 899++86A3
 900++86A3              	; xor a
 901++86A3              	; ld (sec_part),a ;обнулить переменные
 902++86A3              	; ld (sec_shift2),a
 903++86A3              	; ld (sec_shift2+1),a
 904++86A3              	; ld (sec_shift_flag),a
 905++86A3              	; ld (write_end_flag),a ;
 906++86A3
 907++86A3
 908++86A3              	; ld a,(sec_shift)
 909++86A3              	; or a
 910++86A3              	; jr z,fwrite_scl3 ;если смещения нет, то первую часть пропустим
 911++86A3
 912++86A3
 913++86A3              	; ld c,a
 914++86A3              	; ld b,0
 915++86A3              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 916++86A3              	; add hl,bc
 917++86A3
 918++86A3              	; ld a,1
 919++86A3              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 920++86A3
 921++86A3              	; ld a,h
 922++86A3              	; or a
 923++86A3              	; jr nz,fwrite_scl4
 924++86A3              	; ld a,1
 925++86A3              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 926++86A3
 927++86A3              ; fwrite_scl4
 928++86A3              	; ld hl,sec_buf ;буфер последнего сектора
 929++86A3              	; add hl,bc ;на этой точке остановились
 930++86A3              	; ex de,hl
 931++86A3              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 932++86A3              	; ; ld a,c
 933++86A3              	; ; or a
 934++86A3              	; ; jr nz,fwrite_scl2
 935++86A3              	; ; inc b ;коррекция
 936++86A3              ; ; fwrite_scl2
 937++86A3              	; ; ld c,a
 938++86A3              	; xor a
 939++86A3              	; sub c
 940++86A3              	; ld c,a ;сколько осталось перенести до заполнения сектора
 941++86A3              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 942++86A3              	; ldir
 943++86A3
 944++86A3              	; ld a,(sec_shift_flag)
 945++86A3              	; or a
 946++86A3              	; jr nz,fwrite_scl3 ;если сектор ещё не заполнен писать не будем
 947++86A3
 948++86A3              	; ld hl,sec_buf
 949++86A3              	; ;ld de,(#5cf4)
 950++86A3              	; ;ld (f_w_cur_trk),de	;запомним позицию
 951++86A3                  ; ld      b,#01 ;пишем 1 сектор из буфера
 952++86A3                  ; call    scl_write_buf
 953++86A3              	; ; ld a,c
 954++86A3              	; ; cp 255
 955++86A3              	; ; jp z,fwrite_no_chek ;выход если ошибка
 956++86A3
 957++86A3              	; xor a
 958++86A3              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 959++86A3              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 960++86A3              	; ; ld (#5cf4),de
 961++86A3              	; ; ld b,1 ;на сектор вперёд
 962++86A3              	; ; ld de,(f_w_cur_trk)
 963++86A3              	; ; call calc_next_pos
 964++86A3              	; ; ld (f_w_cur_trk),de
 965++86A3
 966++86A3              ; fwrite_scl3
 967++86A3              	; ld hl,(temp_hl) ;запишем остаток данных
 968++86A3              	; ;ld a,(sec_shift)
 969++86A3              	; ;ld c,a
 970++86A3              	; ;ld b,0
 971++86A3              	; ld bc,(sec_shift2)
 972++86A3              	; add hl,bc ;с этой точки пишем
 973++86A3              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 974++86A3
 975++86A3              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 976++86A3              	; and a
 977++86A3              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 978++86A3              	; ld c,l
 979++86A3              	; ld b,h
 980++86A3              	; jr nc,fwrite_scl5
 981++86A3              	; ld b,0 ;коррекция если вышел минус
 982++86A3              ; fwrite_scl5
 983++86A3              	; ld hl,(temp_hl)
 984++86A3              	; add hl,bc
 985++86A3
 986++86A3              	; ld de,outputBuffer
 987++86A3              	; and a
 988++86A3              	; sbc hl,de
 989++86A3
 990++86A3              	; ld a,l
 991++86A3              	; ld (sec_shift),a ;смещение на следующий раз
 992++86A3              	; ;ld hl,(temp_hl)
 993++86A3
 994++86A3
 995++86A3              	; ; or a
 996++86A3              	; ; jr z,fwrite_scl1
 997++86A3              	; ; inc b  ;коррекция количества секторов
 998++86A3
 999++86A3              	; ld a,b ;нужна проверка на количество секторов!!!
1000++86A3              	; ld (sec_part),a ;запомним сколько секторов во второй части
1001++86A3
1002++86A3              	; ;ld a,b
1003++86A3              	; or a
1004++86A3              	; jr z,fwrite_scl1 ;если размер данных меньше сектора, то пропустим запись
1005++86A3
1006++86A3              	; ld hl,(temp_hl2)
1007++86A3              	; ;push bc
1008++86A3              	; ;ld de,(#5cf4)
1009++86A3                  ; ;ld      c,6 ;пишем целыми секторами
1010++86A3                  ; call    scl_write_buf
1011++86A3              	; ;ld a,c
1012++86A3              	; ;pop bc
1013++86A3              	; ; cp 255
1014++86A3              	; ; jp z,fwrite_no_chek ;выход если ошибка
1015++86A3              	; ; ld de,(f_w_cur_trk)
1016++86A3              	; ; call calc_next_pos
1017++86A3              	; ; ld (f_w_cur_trk),de
1018++86A3
1019++86A3              	; xor a
1020++86A3              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
1021++86A3
1022++86A3              ; fwrite_scl1
1023++86A3              	; ld a,(write_end_flag) ;нужно записывать остаток?
1024++86A3              	; or a
1025++86A3              	; jr nz,fwrite_scl_ex ;не нужно
1026++86A3
1027++86A3              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
1028++86A3              	; ld a,(sec_part)
1029++86A3              	; ld b,a
1030++86A3              	; ld c,0
1031++86A3              	; add hl,bc
1032++86A3              	; ld de,sec_buf
1033++86A3              	; ld bc,256
1034++86A3              	; ldir
1035++86A3              ; ;fwrite_scl2
1036++86A3
1037++86A3
1038++86A3              ; fwrite_scl_ex
1039++86A3              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1040++86A3              	; ;посчитаем общую длину записанного
1041++86A3              	; ld hl,(f_w_len)
1042++86A3              	; add hl,bc
1043++86A3              	; ld (f_w_len),hl
1044++86A3              	; jr nc,fwrite_scl_ex1
1045++86A3              	; ld hl,(f_w_len+2)
1046++86A3              	; inc hl
1047++86A3              	; ld (f_w_len+2),hl
1048++86A3
1049++86A3              ; fwrite_scl_ex1
1050++86A3              	; xor a ;флаги сбросим
1051++86A3                  ; ret
1052++86A3
1053++86A3
1054++86A3
1055++86A3
1056++86A3
1057++86A3
1058++86A3              ; scl_write_buf ;заполнение промежуточного буфера
1059++86A3              	; push bc ;сколько пакетов указано в b
1060++86A3              	; ld de,scl_buf ;перенесём сектор во временный буфер
1061++86A3              	; ld bc,256
1062++86A3              	; ldir
1063++86A3              	; ld (scl_temp_hl2),hl ;сохраним адрес данных
1064++86A3              	; ld a,(scl_que) ;проверим флаг что нужны данные
1065++86A3              	; or a
1066++86A3              	; jr z,scl_write_buf_ret ;не будем вызывать парсер если не нужны
1067++86A3              	; ld hl,scl_write_buf_ret ;адрес возврата
1068++86A3              	; push hl
1069++86A3              	; ld hl,(scl_parse_ret_adr) ;адрес для продолжения основного цикла сборки
1070++86A3              	; jp (hl) ;отдадим пакет 256 байт парсеру
1071++86A3              ; scl_write_buf_ret
1072++86A3              	; ld hl,(scl_temp_hl2)
1073++86A3              	; pop bc
1074++86A3              	; djnz scl_write_buf
1075++86A3
1076++86A3              	; ret
1077++86A3
1078++86A3
1079++86A3
1080++86A3              ; scl_parse ;разбор образа scl в trd, основной цикл
1081++86A3              	; ;получить первый сектор
1082++86A3              ; ;запрос порции данных по 256 байт
1083++86A3              	; ld (scl_temp_hl),hl
1084++86A3              	; ld (scl_temp_de),de
1085++86A3              	; ld (scl_temp_bc),bc
1086++86A3              	; ld a,1
1087++86A3              	; ld (scl_que),a ;включим флаг что нужны данные
1088++86A3              	; ld hl,scl_parse_ret ;сохраним адрес возврата
1089++86A3              	; ld (scl_parse_ret_adr),hl
1090++86A3              	; ret ;вернёмся для ожидания данных
1091++86A3              ; scl_parse_ret
1092++86A3              	; xor a
1093++86A3              	; ld (scl_que),a
1094++86A3              	; ld hl,(scl_temp_hl)
1095++86A3              	; ld de,(scl_temp_de)
1096++86A3              	; ld bc,(scl_temp_bc)
1097++86A3
1098++86A3              	; ld de,scl_buf ;проверка метки образа
1099++86A3              	; ld hl,scl_sign
1100++86A3              	; ld b,8
1101++86A3              ; scl_parse_chk
1102++86A3              	; ld a,(de)
1103++86A3              	; cp (hl)
1104++86A3              	; jr nz,scl_parse_chk_no
1105++86A3              	; inc hl
1106++86A3              	; inc de
1107++86A3              	; djnz scl_parse_chk
1108++86A3              	; jr scl_parse_chk_ok
1109++86A3              ; scl_parse_chk_no ;если не совпало, значит плохой образ
1110++86A3                  ; ld hl, scl_err
1111++86A3                  ; call DialogBox.msgBox ;предуреждение
1112++86A3              	; xor a
1113++86A3              	; ld (scl_que),a ;выключим флаг что нужны данные
1114++86A3              	; ld a,4 ;закроем файл
1115++86A3              	; call fclose
1116++86A3              	; ret
1117++86A3              ; scl_parse_chk_ok ;сигнатура правильная
1118++86A3
1119++86A3              ; ;формирование каталога
1120++86A3              	; ld a,(scl_buf+8)
1121++86A3              	; ld (scl_files),a ;всего файлов
1122++86A3              	; ld (scl_cat_cycl),a ;цикл
1123++86A3              	; ld hl,scl_buf+9 ;адрес первого заголовка
1124++86A3              	; ld de,cat_buf ;адрес формируемого каталога trd
1125++86A3              ; scl_parse_cat2
1126++86A3              	; ld b,14 ;14 байт одна запись
1127++86A3              ; scl_parse_cat
1128++86A3              	; ld a,(hl)
1129++86A3              	; ld (de),a
1130++86A3              	; inc de
1131++86A3              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1132++86A3              	; jr nz,scl_parse_cat1
1133++86A3              	; ;тут пора запросить следующий сектор
1134++86A3              ; ;запрос порции данных по 256 байт
1135++86A3              	; ld (scl_temp_hl),hl
1136++86A3              	; ld (scl_temp_de),de
1137++86A3              	; ld (scl_temp_bc),bc
1138++86A3              	; ld a,1
1139++86A3              	; ld (scl_que),a ;включим флаг что нужны данные
1140++86A3              	; ld hl,scl_parse_ret1 ;сохраним адрес возврата
1141++86A3              	; ld (scl_parse_ret_adr),hl
1142++86A3              	; ret ;вернёмся для ожидания данных
1143++86A3              ; scl_parse_ret1
1144++86A3              	; xor a
1145++86A3              	; ld (scl_que),a
1146++86A3              	; ld hl,(scl_temp_hl)
1147++86A3              	; ld de,(scl_temp_de)
1148++86A3              	; ld bc,(scl_temp_bc)
1149++86A3
1150++86A3              ; scl_parse_cat1
1151++86A3              	; djnz scl_parse_cat
1152++86A3              	; inc de
1153++86A3              	; inc de
1154++86A3              	; ld a,(scl_cat_cycl)
1155++86A3              	; dec a
1156++86A3              	; ld (scl_cat_cycl),a
1157++86A3              	; jr nz,scl_parse_cat2
1158++86A3
1159++86A3              	; ld (scl_temp_hl),hl ;запомнить где остановились
1160++86A3
1161++86A3              ; ;подсчёт секторов и дорожек
1162++86A3              	; push ix
1163++86A3              	; ld a,(scl_files)
1164++86A3              	; ld de,#0100 ;данные с первой дорожки
1165++86A3              	; ld ix,cat_buf
1166++86A3              	; ld (ix+14),e
1167++86A3              	; ld (ix+15),d
1168++86A3              	; ld hl,0 ;общее количество секторов
1169++86A3              ; scl_cacl
1170++86A3              	; ld (scl_cat_cycl),a ;цикл
1171++86A3              	; ld a,(ix+13) ;длина файла в секторах
1172++86A3              	; ld c,a
1173++86A3              	; ld b,0
1174++86A3              	; add hl,bc ;секторов
1175++86A3
1176++86A3              	; ld bc,16
1177++86A3              	; add ix,bc
1178++86A3              	; ld b,a
1179++86A3              	; call calc_next_pos
1180++86A3              	; ld a,(scl_cat_cycl)
1181++86A3              	; cp 1
1182++86A3              	; jr z,scl_cacl2 ;в последний раз пропусим
1183++86A3              	; ld (ix+14),e
1184++86A3              	; ld (ix+15),d
1185++86A3              ; scl_cacl2
1186++86A3              	; dec a
1187++86A3              	; jr nz,scl_cacl
1188++86A3              	; ;теперь узнаем первый свободный сектор
1189++86A3              	; ld a,(ix+13) ;длина файла в секторах
1190++86A3              	; ld c,a
1191++86A3              	; ld b,0
1192++86A3              	; add hl,bc
1193++86A3              	; ; ld b,a
1194++86A3              	; ; call calc_next_pos
1195++86A3              	; ld (cat_buf+8*256+#e1),de ;Первый свободный сектор и дорожка на дискете
1196++86A3              	; ld de,16*159
1197++86A3              	; ex de,hl
1198++86A3              	; and a
1199++86A3              	; sbc hl,de
1200++86A3              	; ld (cat_buf+8*256+#e5),hl ;Число свободных секторов на диске
1201++86A3              	; pop ix
1202++86A3
1203++86A3
1204++86A3
1205++86A3              ; ;запись содержимого файлов
1206++86A3              	; ld a,(scl_files) ;всего файлов
1207++86A3              	; ld (scl_cat_cycl),a ;цикл
1208++86A3              	; ld hl,cat_buf+13 ;адрес размер секторов файла
1209++86A3              	; ld (cat_cur_adr),hl
1210++86A3
1211++86A3              	; ld hl,#0100 ;начиная с первой дорожки
1212++86A3              	; ld (#5cf4),hl
1213++86A3              ; scl_parse_file2
1214++86A3              	; ld hl,(scl_temp_hl) ;адрес данных
1215++86A3              	; ld de,(cat_cur_adr) ;адрес сектор дорожка файла
1216++86A3              	; ;dec de
1217++86A3              	; ld a,(de) ;количество секторов, цикл
1218++86A3              	; ld c,a
1219++86A3              ; scl_parse_file3
1220++86A3              	; ld de,scl_buf2 ;адрес ещё одного буфера
1221++86A3              	; ld b,0 ;256 байт один сектор, цикл
1222++86A3              ; scl_parse_file
1223++86A3              	; ld a,(hl)
1224++86A3              	; ld (de),a
1225++86A3              	; inc de
1226++86A3              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1227++86A3              	; jr nz,scl_parse_file1
1228++86A3              	; ;тут пора запросить следующий сектор
1229++86A3              ; ;запрос порции данных по 256 байт
1230++86A3              	; ld (scl_temp_hl),hl
1231++86A3              	; ld (scl_temp_de),de
1232++86A3              	; ld (scl_temp_bc),bc
1233++86A3              	; ld a,1
1234++86A3              	; ld (scl_que),a ;включим флаг что нужны данные
1235++86A3              	; ld hl,scl_parse_ret2 ;сохраним адрес возврата
1236++86A3              	; ld (scl_parse_ret_adr),hl
1237++86A3              	; ret ;вернёмся для ожидания данных
1238++86A3              ; scl_parse_ret2
1239++86A3              	; xor a
1240++86A3              	; ld (scl_que),a
1241++86A3              	; ld hl,(scl_temp_hl)
1242++86A3              	; ld de,(scl_temp_de)
1243++86A3              	; ld bc,(scl_temp_bc)
1244++86A3
1245++86A3              ; scl_parse_file1
1246++86A3              	; djnz scl_parse_file
1247++86A3              	; ld (scl_temp_hl),hl
1248++86A3              	; ld (scl_temp_bc),bc
1249++86A3
1250++86A3              	; ld hl,scl_buf2 ;;запишем один сектор
1251++86A3              	; ld  de,(#5cf4)
1252++86A3                  ; ld      bc,#0106 ;
1253++86A3                  ; call    call3d13
1254++86A3              	; ; ld a,c
1255++86A3              	; ; cp 255
1256++86A3              	; ; jp z,fwrite_no_chek ;выход если ошибка
1257++86A3              	; ld hl,(scl_temp_hl)
1258++86A3              	; ld bc,(scl_temp_bc)
1259++86A3
1260++86A3              	; dec c
1261++86A3              	; jr nz,scl_parse_file3
1262++86A3
1263++86A3              	; ld hl,(cat_cur_adr) ;адрес сектор дорожка файла
1264++86A3              	; ; ld e,(hl)
1265++86A3              	; ; inc hl
1266++86A3              	; ; ld d,(hl)
1267++86A3              	; ld bc,16
1268++86A3              	; add hl,bc ;на следующий файл
1269++86A3              	; ld (cat_cur_adr),hl
1270++86A3
1271++86A3
1272++86A3              	; ld a,(scl_cat_cycl)
1273++86A3              	; dec a
1274++86A3              	; ld (scl_cat_cycl),a
1275++86A3              	; jr nz,scl_parse_file2	;на следующий файл
1276++86A3
1277++86A3
1278++86A3
1279++86A3              ; ;формирование системного сектора №9 (8)
1280++86A3              	; ;
1281++86A3              	; ;ld (cat_buf+8*256+#e1),a ;// #E1 Первый свободный сектор на дискете
1282++86A3              	; ;
1283++86A3              	; ;ld (cat_buf+8*256+#e2),a ;// #E2 Первый свободный трек
1284++86A3              	; ld a,#16
1285++86A3              	; ld (cat_buf+8*256+#e3),a ;// #E3 16 80 дорожек, 2 стороны
1286++86A3              	; ld a,(scl_files)
1287++86A3              	; ld (cat_buf+8*256+#e4),a ;// #E4 Общее количество файлов записанных на диск
1288++86A3              	; ;
1289++86A3              	; ;ld (cat_buf+8*256+#e5),a ;// #Е5,Е6 Число свободных секторов на диске
1290++86A3              	; ;ld (cat_buf+8*256+#e6),a
1291++86A3              	; ld a,#10
1292++86A3              	; ld (cat_buf+8*256+#e7),a ;// #E7 Код  #10,определяющий принадлежность к TR-DOS
1293++86A3
1294++86A3              	; ld hl,f_name ;запишем имя диска, взяв для этого имя файла
1295++86A3              	; ld de,cat_buf+8*256+#f5 ;// #F5-#FC Имя диска в ASCII формате
1296++86A3              	; ld bc,8
1297++86A3              	; ldir
1298++86A3
1299++86A3              	; ld hl,cat_buf ;запишем каталог на диск
1300++86A3              	; ld de,0
1301++86A3                  ; ld      bc,#0906 ;
1302++86A3                  ; call    call3d13
1303++86A3              	; ; ld a,c
1304++86A3              	; ; cp 255
1305++86A3              	; ; jp z,fwrite_no_chek ;выход если ошибка
1306++86A3              	; ret
1307++86A3
1308++86A3
1309++86A3              ; ;-----------scl end --------------------
1310++86A3
1311++86A3
1312++86A3
1313++86A3              ; ;---------------------------------------
1314++86A3              ; fwrite_chek_fat ;запись файла fat
1315++86A3              	; ld (temp_bc),bc ;длина
1316++86A3              	; ld a,c ;младший байт длины
1317++86A3              	; ld	de,fcb
1318++86A3              	; R8FAT r8f09_FileWrite	;записать в файл
1319++86A3              	; jp 	c,fwrite_no_chek
1320++86A3
1321++86A3              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1322++86A3              	; ;посчитаем общую длину записанного
1323++86A3              	; ld hl,(f_w_len)
1324++86A3              	; add hl,bc
1325++86A3              	; ld (f_w_len),hl
1326++86A3              	; jr nc,fwrite_fat_ex1
1327++86A3              	; ld hl,(f_w_len+2)
1328++86A3              	; inc hl
1329++86A3              	; ld (f_w_len+2),hl
1330++86A3              ; fwrite_fat_ex1
1331++86A3              	; xor a ;флаги сбросим
1332++86A3              	; ret
1333++86A3              ;---------------------------------------
1334++86A3
1335++86A3
1336++86A3
1337++86A3              ; A - file stream id
1338++86A3              ; fsync:
1339++86A3              ;     esxCall ESX_FSYNC
1340++86A3                  ; ret
1341++86A3
1342++86A3
1343++86A3              ; ; HL - name (name.ext)
1344++86A3              ; ; Returns:
1345++86A3              ; ; HL - name (name    e)
1346++86A3              ; format_name ;подгоняет имя файла под стандарт trdos (8+1)
1347++86A3
1348++86A3              	; ;сначала попробуем убрать из пути подпапку, если она есть
1349++86A3              	; ld (temp_hl),hl ;сохраним адрес исходного имени
1350++86A3              	; ld b,#00 ;не больше 255 символов
1351++86A3              ; format_name5
1352++86A3              	; ld a,(hl)
1353++86A3              	; cp "/" ;если есть подпапка
1354++86A3              	; jr z,format_name_path_yep
1355++86A3              	; ld a,(hl)
1356++86A3              	; cp "." ;если ещё не дошли до расширения
1357++86A3              	; jr nz,format_name6
1358++86A3              	; ld hl,(temp_hl) ;если дошли до расширения, то путей нет, вернёмся на начало имени
1359++86A3              	; jr format_name_7 ;на выход
1360++86A3              ; format_name6
1361++86A3              	; inc hl
1362++86A3              	; djnz format_name5
1363++86A3
1364++86A3              ; format_name_path_yep ;нашли
1365++86A3              	; inc hl ;пропустим знак "/"
1366++86A3
1367++86A3              ; format_name_7
1368++86A3
1369++86A3              	; push hl ;очистим место для нового имени
1370++86A3              	; ld hl,f_name
1371++86A3              	; ld de,f_name+1
1372++86A3              	; ld (hl)," "
1373++86A3              	; ld bc,8+1
1374++86A3              	; ldir
1375++86A3              	; ld (hl),0
1376++86A3              	; ld bc,16-8-1-1
1377++86A3              	; ldir
1378++86A3              	; pop hl
1379++86A3
1380++86A3              	; ld bc,#09ff ;длина имени 9 символов
1381++86A3              	; ld de,f_name ;куда
1382++86A3              ; format_name2
1383++86A3              	; ld a,(hl)
1384++86A3              	; cp "."
1385++86A3              	; jr nz,format_name1
1386++86A3              	; ld de,f_name+8
1387++86A3              	; inc hl
1388++86A3              	; ldi ; и в конце расширение 3 буквы
1389++86A3              	; ldi
1390++86A3              	; ldi
1391++86A3              	; ;ex de,hl ;сохраним адрес исходного расширения
1392++86A3              	; jr format_name_e
1393++86A3              ; format_name1
1394++86A3              	; ldi
1395++86A3              	; djnz format_name2
1396++86A3
1397++86A3              	; ;если имя длинное, пропустим лишнее до расширения
1398++86A3              	; ld b,#00 ;не больше 255 символов
1399++86A3              ; format_name3
1400++86A3              	; ld a,(hl)
1401++86A3              	; cp "."
1402++86A3              	; jr nz,format_name4
1403++86A3              	; ld de,f_name+8
1404++86A3              	; inc hl
1405++86A3              	; ldi ; и в конце расширение 3 буквы
1406++86A3              	; ldi
1407++86A3              	; ldi
1408++86A3              	; ;ex de,hl ;сохраним адрес исходного расширения
1409++86A3              	; jr format_name_e
1410++86A3              ; format_name4
1411++86A3              	; inc hl
1412++86A3              	; djnz format_name3
1413++86A3
1414++86A3              ; format_name_e ;выход
1415++86A3              	; ld hl,f_name ;вернём результат
1416++86A3              	; ret
1417++86A3
1418++86A3              ; ; DE - trk/sec
1419++86A3              ; ; B - sectors step
1420++86A3              ; ; Returns:
1421++86A3              ; ; DE - trk/sec
1422++86A3              ; calc_next_pos		;вперёд на N секторов
1423++86A3              			; ;ld b,4
1424++86A3              			; ;ld  de,(#5ceb)
1425++86A3              ; calc_next_pos2
1426++86A3              			; inc e
1427++86A3              			; ld a,e
1428++86A3              			; cp 16
1429++86A3              			; jr c,calc_next_pos1
1430++86A3              			; inc d
1431++86A3              			; ld e,0
1432++86A3              ; calc_next_pos1
1433++86A3              			; ;ld (#5ceb),de
1434++86A3              			; djnz calc_next_pos2
1435++86A3              			; ret
1436++86A3
1437++86A3
1438++86A3              ; ;testt db "123.trd"
1439++86A3              ; write_ima db "Select disk "
1440++86A3              ; write_ima_d db "A: (A-" ;текущая буква
1441++86A3              ; write_ima_e	db "D). " ;последняя буква
1442++86A3              		; db "All data may be lost! Press Y or N.",0
1443++86A3              ; ;prev_drive db 0 ;предыдущий номер дисковода
1444++86A3              ; curr_drive db 0 ;текущий диск
1445++86A3
1446++86A3              ; trdExt1 db ".trd", 0
1447++86A3              ; trdExt2 db ".TRD", 0
1448++86A3
1449++86A3              ; sclExt1 db ".scl", 0
1450++86A3              ; sclExt2 db ".SCL", 0
1451++86A3
1452++86A3              ;f_name ds 16 ;имя файла
1453++86A3              ; f_r_cur_trk dw 	 0 ;текущие сектор-дорожка файла на чтение
1454++86A3              ; f_r_len_sec db 0 ;длина файла на чтение в секторах
1455++86A3              ; f_r_len dw 0;длина файла в байтах
1456++86A3              ; f_r_flag db 0 ;флаг что открыт файл на чтение
1457++86A3
1458++86A3              ; f_w_cur_trk dw 	 0 ;текущие сектор-дорожка файла на запись
1459++86A3              ; f_w_len_sec db 0 ;длина файла на запись в секторах
1460++86A3              ; f_w_flag db 0 ;флаг что открыт файл на запись
1461++86A3              ; f_w_len ds 4 ;длина записанных данных
1462++86A3              ; write_end_flag db 0 ;флаг что нужно записать остаток
1463++86A3
1464++86A3              ; temp_bc dw 0 ;хранение регистра
1465++86A3              ;temp_hl dw 0 ;хранение регистра
1466++86A3              ; temp_hl2 dw 0 ;хранение регистра
1467++86A3
1468++86A3              ; sec_shift db 0 ;указатель на каком байте остановлена запись
1469++86A3              ; sec_shift2 db 0 ;указатель на каком байте остановлена запись (остаток)
1470++86A3              ; sec_part db 0 ;сколько секторов во второй порции для записи
1471++86A3              ; sec_shift_flag db 0 ;флаг что буфер сектора не заполнен
1472++86A3
1473++86A3              ; ;секция scl
1474++86A3              ; scl_sign db "SINCLAIR" ;метка
1475++86A3              ; scl_que db 0 ;флаг запроса порции данных
1476++86A3              ; scl_err db "SCL image error!",0
1477++86A3              ; scl_parse_ret_adr dw 0; адрес возврата в цикл
1478++86A3              ; scl_cat_cycl db 0 ;переменная цикла
1479++86A3              ; scl_files db 0 ;всего файлов
1480++86A3              ; scl_temp_hl dw 0;;хранение регистра
1481++86A3              ; scl_temp_hl2 dw 0;
1482++86A3              ; scl_temp_de dw 0;
1483++86A3              ; scl_temp_bc dw 0;
1484++86A3              ; cat_cur_adr dw 0;
1485++86A3              ; ;scl end
1486++86A3
1487++86A3              ; ;секция сохранения любого файла
1488++86A3              ; file_err db "Not enough space!",0
1489++86A3              ; sec_cat db 0 ;сектор каталога
1490++86A3              ; file_num db "0" ;номер части для больших файлов
1491++86A3
1492++86A3              	; ;по адресу #4000 шрифт
1493++86A3              ; cat_buf equ #4800 ;буфер для кататога диска 9*256
1494++86A3              ; sec_buf equ cat_buf + 9*256 ;буфер сектора для записи 256
1495++86A3              ; scl_buf equ sec_buf + 512 ;промежуточный буфер 256
1496++86A3              ; scl_buf2 equ scl_buf + 512 ;промежуточный буфер 256
1497++86A3              ; ;общая ошибка с файлами
1498++86A3              ; com_file_err db "File error!",0
1499++86A3              ; com_file_err_flag db 0 ;общая ошибка
1500++86A3
1501++86A3
1502++86A3
1503++86A3
1504++86A3              ; ;Раздел SMUC и SD ------------------------------------
1505++86A3
1506++86A3
1507++86A3              ; ;список доступных разделов на винчестерах
1508++86A3              ; ;7,=0/1 тип раздела MFS/FAT
1509++86A3              ; ;6,=1 раздел есть
1510++86A3              ; ;3,=0/1 Hdd/SD card
1511++86A3              ; ;2,=0/1 для HDD master/slave
1512++86A3              ; ;0..1,=?? номер раздела
1513++86A3              ; ;
1514++86A3              ; typeDrive	ds 3*4+1
1515++86A3              ; ;typeDriveFAT	ds 3*4+1 ;список всех разделов FAT
1516++86A3              ; numDrives db 0 ;количество устройств
1517++86A3              ; ;numDrivesFAT db 0 ;количество устройств FAT
1518++86A3              ; next_lett db 0 ;следующая свободная буква диска
1519++86A3
1520++86A3              ; ;подсчет количества доступных разделов на всех устройствах
1521++86A3              ; ;вых: hl,a - количество устройств
1522++86A3              ; ;     typeDrives - сформированная таблица
1523++86A3              ; ;     cy=1 не обнаружено ни одного устройства
1524++86A3              ; ;
1525++86A3              ; GetNumPart
1526++86A3              ; ;
1527++86A3              	; push	de
1528++86A3              	; push	bc
1529++86A3              	; ld	hl,typeDrive
1530++86A3              	; push	hl
1531++86A3              	; xor	a
1532++86A3              	; call	proc_01			;HDD master
1533++86A3              	; ld	a,#01
1534++86A3              	; call	proc_01			;HDD slave
1535++86A3              	; ld	a,#02
1536++86A3              	; call	proc_01			;SD card
1537++86A3              	; pop	de
1538++86A3              	; or	a
1539++86A3              	; sbc	hl,de			;количество разделов на HDD
1540++86A3              	; IFDEF	useTRD
1541++86A3              	 ; ld	a,l
1542++86A3              	 ; add	a,#04
1543++86A3              	 ; ld	l,a
1544++86A3              	; ELSE
1545++86A3              	 ; ld	a,l
1546++86A3              	; ENDIF
1547++86A3              	; pop	bc
1548++86A3              	; pop	de
1549++86A3              	; ld	(numDrives),a
1550++86A3              	; cp	1
1551++86A3              	; ret
1552++86A3
1553++86A3              ; ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1554++86A3              ; ;формирование таблицы с доступными разделами на винчестере
1555++86A3              ; ;вх:  a =#00 выбрать master
1556++86A3              ; ;       =#01 выбрать slave
1557++86A3              ; ;       =#02 выбрать SD card
1558++86A3              ; ;     hl - адрес в таблице разделов typeDrives
1559++86A3              ; ;вых: hl - новый адрес в таблице разделов typeDrives
1560++86A3              ; ;
1561++86A3              ; proc_01	ld	c,a
1562++86A3              	; push	hl
1563++86A3              	; push	bc
1564++86A3              	; R8DOS	r8d2E_CngHDD
1565++86A3              	; jr	c,goto001		;на текущем канале нет винчестера
1566++86A3              	; R8DOS	r8d2D_FindPart
1567++86A3              ; goto001	pop	bc
1568++86A3              	; pop	hl
1569++86A3              	; ret	c			;на текущем винчестере нет разделов
1570++86A3              	; ld	b,a
1571++86A3              	; ld	a,c
1572++86A3              	; add	a,a
1573++86A3              	; add	a,a
1574++86A3              	; ld	c,a			;номер винчестера и первого раздела
1575++86A3              	; ld	a,b
1576++86A3              	; ld	b,#04
1577++86A3              ; loop001	ld	(hl),#00
1578++86A3              	; rra
1579++86A3              	; jr	nc,goto002		;нет раздела
1580++86A3              	; IFDEF	useMFS
1581++86A3              	 ; ld	(hl),c
1582++86A3              	 ; set	6,(hl)			;=%01???hpp MFS
1583++86A3              	 ; rra
1584++86A3              	 ; jr	nc,goto003		;это MFS
1585++86A3              	 ; set	7,(hl)			;=%11???hpp это FAT
1586++86A3              	; ELSE
1587++86A3              	 ; rra
1588++86A3              	 ; jr	nc,goto004		;это MFS
1589++86A3              	 ; ld	(hl),c
1590++86A3              	 ; set	6,(hl)			;раздел есть
1591++86A3              	 ; set	7,(hl)			;=%11???hpp это FAT
1592++86A3              	; ENDIF
1593++86A3              ; goto003	inc	hl
1594++86A3              	; rla
1595++86A3              ; goto002	rra
1596++86A3              ; goto004	inc	c
1597++86A3              	; djnz	loop001
1598++86A3              	; ret
1599++86A3
1600++86A3
1601++86A3
1602++86A3              ; hdd_init_flag: db 0 ;флаг инициализации
1603++86A3              ; ;fcb_tmp ds 32 ;буфер fcb временно
1604++86A3              ; ActPathFAT db "\\Download",0 ;папка для сохранений
1605++86A3              ; fcb ds 32	;буфер fcb
1606++86A3              	; nop
1607++86A3              ; ;конец секции SMUC и SD ----------------------------
1608++86A3
1609++86A3
1610++86A3
1611++86A3                  ENDMODULE
# file closed: dos/zsfat.asm
   9+ 86A3              	ENDIF
  10+ 86A3                  include "console.asm"
# file opened: dos/console.asm
   1++86A3                  module Console
   2++86A3              KEY_UP = 11
   3++86A3              KEY_DN = 10
   4++86A3              KEY_LT = 8
   5++86A3              KEY_RT = 9
   6++86A3              BACKSPACE = 12
   7++86A3 00           keyCode db 0
   8++86A4
   9++86A4              ;BASIC_KEY = #5C08
  10++86A4
  11++86A4              waitForKeyUp:
  12++86A4              	OS_WAIT
  12++86A4 DF          >	rst #18
  13++86A5              	OS_GET_CHAR
  13++86A5 0E 10       >    ld c,#10
  13++86A7 E7          >    rst #20
  14++86A8 FE FF           cp 255
  15++86AA 20 F8           jr nz, waitForKeyUp
  16++86AC
  17++86AC                 ; ld (BASIC_KEY), a
  18++86AC C9              ret
  19++86AD
  20++86AD              getC:
  21++86AD              	OS_WAIT
  21++86AD DF          >	rst #18
  22++86AE              	OS_GET_CHAR
  22++86AE 0E 10       >    ld c,#10
  22++86B0 E7          >    rst #20
  23++86B1                 ;ld a,(BASIC_KEY)
  24++86B1                 ;and a : jr z, getC
  25++86B1 FE FF           cp 255
  26++86B3 28 F8           jr z, getC
  27++86B5                 ;ld b,a
  28++86B5                 ;xor a : ld (BASIC_KEY), a
  29++86B5                 ;ld a, b
  30++86B5 C9              ret
  31++86B6
  32++86B6              peekC:
  33++86B6              	OS_GET_CHAR
  33++86B6 0E 10       >    ld c,#10
  33++86B8 E7          >    rst #20
  34++86B9                  ;xor a: ld (BASIC_KEY),a
  35++86B9                  ;call inkey
  36++86B9 C9               ret
  37++86BA
  38++86BA              ; inkey:
  39++86BA                 ; ld de,0
  40++86BA                 ; ld bc,$fefe
  41++86BA                 ; in a,(c)
  42++86BA                 ; or $e1
  43++86BA                 ; cp $ff
  44++86BA                 ; jr nz, .keyhitA
  45++86BA
  46++86BA                 ; ld e,5
  47++86BA                 ; ld b,$fd
  48++86BA                 ; in a,(c)
  49++86BA                 ; or $e0
  50++86BA                 ; cp $ff
  51++86BA                 ; jr nz, .keyhitA
  52++86BA
  53++86BA                 ; ld e,10
  54++86BA                 ; ld b,$fb
  55++86BA                 ; in a,(c)
  56++86BA                 ; or $e0
  57++86BA                 ; cp $ff
  58++86BA                 ; jr nz, .keyhitA
  59++86BA
  60++86BA                 ; ld e,15
  61++86BA                 ; ld b,$f7
  62++86BA                 ; in a,(c)
  63++86BA                 ; or $e0
  64++86BA                 ; cp $ff
  65++86BA                 ; jr nz, .keyhitA
  66++86BA
  67++86BA                 ; ld e,20
  68++86BA                 ; ld b,$ef
  69++86BA                 ; in a,(c)
  70++86BA                 ; or $e0
  71++86BA                 ; cp $ff
  72++86BA                 ; jr nz, .keyhitA
  73++86BA
  74++86BA                 ; ld e,25
  75++86BA                 ; ld b,$df
  76++86BA                 ; in a,(c)
  77++86BA                 ; or $e0
  78++86BA                 ; cp $ff
  79++86BA                 ; jr nz, .keyhitA
  80++86BA
  81++86BA                 ; ld e,30
  82++86BA                 ; ld b,$bf
  83++86BA                 ; in a,(c)
  84++86BA                 ; or $e0
  85++86BA                 ; cp $ff
  86++86BA                 ; jr nz, .keyhitA
  87++86BA
  88++86BA                 ; ld e,35
  89++86BA                 ; ld b,$7f
  90++86BA                 ; in a,(c)
  91++86BA                 ; or $e2
  92++86BA                 ; cp $ff
  93++86BA                 ; ld c,a
  94++86BA                 ; jr nz, .keyhitB
  95++86BA
  96++86BA              ; .nokey
  97++86BA                 ; xor a
  98++86BA                 ; ret
  99++86BA
 100++86BA              ; .keyhitA
 101++86BA
 102++86BA                 ; ld c,a
 103++86BA
 104++86BA                 ; ld a,b
 105++86BA                 ; cpl
 106++86BA                 ; or $81
 107++86BA                 ; in a,($fe)
 108++86BA                 ; or $e0
 109++86BA                 ; cp $ff
 110++86BA                 ; jr nz, .nokey
 111++86BA
 112++86BA                 ; ld a,$7f
 113++86BA                 ; in a,($fe)
 114++86BA                 ; or $e2
 115++86BA                 ; cp $ff
 116++86BA                 ; jr nz, .nokey
 117++86BA
 118++86BA              ; .keyhitB
 119++86BA
 120++86BA                 ; ld b,0
 121++86BA                 ; ld hl,.rowtbl-$e0
 122++86BA                 ; add hl,bc
 123++86BA                 ; ld a,(hl)
 124++86BA                 ; cp 5
 125++86BA                 ; jr nc, .nokey
 126++86BA                 ; add a,e
 127++86BA                 ; ld e,a
 128++86BA
 129++86BA                 ; ld hl,.table
 130++86BA                 ; add hl,de
 131++86BA
 132++86BA                 ; ld a,$fe
 133++86BA                 ; in a,($fe)
 134++86BA                 ; and $01
 135++86BA                 ; jr nz, .nocaps
 136++86BA                 ; ld e,40
 137++86BA                 ; add hl,de
 138++86BA
 139++86BA              ; .nocaps
 140++86BA
 141++86BA                 ; ld a,$7f
 142++86BA                 ; in a,($fe)
 143++86BA                 ; and $02
 144++86BA                 ; jr nz, .nosym
 145++86BA                 ; ld e,80
 146++86BA                 ; add hl,de
 147++86BA
 148++86BA              ; .nosym
 149++86BA
 150++86BA                 ; ld a,(hl)
 151++86BA                 ; ret
 152++86BA
 153++86BA              ; .rowtbl
 154++86BA                 ; defb 255,255,255,255,255,255,255
 155++86BA                 ; defb 255,255,255,255,255,255,255,255
 156++86BA                 ; defb 4,255,255,255,255,255,255
 157++86BA                 ; defb 255,3,255,255,255,2,255,1
 158++86BA                 ; defb 0,255
 159++86BA
 160++86BA              ; .table
 161++86BA                 ; db 0,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
 162++86BA                 ; db 'a','s','d','f','g'      ; A, S, D, F, G
 163++86BA                 ; db 'q','w','e','r','t'      ; Q, W, E, R, T
 164++86BA                 ; db '1','2','3','4','5'      ; 1, 2, 3, 4, 5
 165++86BA                 ; db '0','9','8','7','6'      ; 0, 9, 8, 7, 6
 166++86BA                 ; db 'p','o','i','u','y'      ; P, O, I, U, Y
 167++86BA                 ; db 13,'l','k','j','h'       ; ENTER, L, K, J, H
 168++86BA                 ; db ' ',0,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B
 169++86BA
 170++86BA                 ; ; the following are CAPS SHIFTed
 171++86BA
 172++86BA                 ; db 0,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
 173++86BA                 ; db 'A','S','D','F','G'      ; A, S, D, F, G
 174++86BA                 ; db 'Q','W','E','R','T'      ; Q, W, E, R, T
 175++86BA                 ; db 7,6,128,129,8            ; 1, 2, 3, 4, 5
 176++86BA                 ; db 12,0,9,11,10             ; 0, 9, 8, 7, 6
 177++86BA                 ; db 'P','O','I','U','Y'      ; P, O, I, U, Y
 178++86BA                 ; db 13,'L','K','J','H'       ; ENTER, L, K, J, H
 179++86BA                 ; db ' ',0,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B
 180++86BA
 181++86BA                 ; ; the following are SYM SHIFTed
 182++86BA
 183++86BA                 ; db 0,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
 184++86BA                 ; db '~','|',92,'{','}'       ; A, S, D, F, G
 185++86BA                 ; db 131,132,133,'<','>'      ; Q, W, E, R, T
 186++86BA                 ; db '!','@','#','$','%'      ; 1, 2, 3, 4, 5
 187++86BA                 ; db '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
 188++86BA                 ; db 34,';',130,']','['       ; P, O, I, U, Y
 189++86BA                 ; db 13,'=','+','-','^'       ; ENTER, L, K, J, H
 190++86BA                 ; db ' ',0,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B
 191++86BA
 192++86BA                 ; ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)
 193++86BA
 194++86BA                 ; db 0,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
 195++86BA                 ; db 1,19,4,6,7               ; A, S, D, F, G
 196++86BA                 ; db 17,23,5,18,20            ; Q, W, E, R, T
 197++86BA                 ; db 27,28,29,30,31           ; 1, 2, 3, 4, 5
 198++86BA                 ; db 127,0,134,'`',135      ; 0, 9, 8, 7, 6
 199++86BA                 ; db 16,15,9,21,25            ; P, O, I, U, Y
 200++86BA                 ; db 13,12,11,10,8            ; ENTER, L, K, J, H
 201++86BA                 ; db ' ',0,13,14,2          ; SPACE, SYM SHIFT, M, N, B
 202++86BA
 203++86BA                  endmodule
# file closed: dos/console.asm
# file closed: dos/index.asm
  19  86BA                  include "gopher/engine/history/index.asm"
# file opened: gopher/engine/history/index.asm
   1+ 86BA                  include "controler.asm"
# file opened: gopher/engine/history/controler.asm
   1++86BA                  module History
   2++86BA              back:
   3++86BA 3A F3 87         ld a, (depth)
   3++86BD FE 01          cp 1
   3++86BF CA D1 86       jp z, load
   4++86C2 21 3C 8B 11      ld hl, historyBlock + HistoryRecord, de, historyBlock, bc, (total - 1) * HistoryRecord
   4++86C6 F4 87 01 20
   4++86CA 0D
   4++86CB ED B0          ldir ; Move history up
   5++86CD 21 F3 87         ld hl, depth
   5++86D0 35             dec (hl)
   6++86D1              ; Loads current resource
   7++86D1              load:
   8++86D1 21 EE 86         ld hl, .msg
   8++86D4 CD 30 86       call DialogBox.msgNoWait
   9++86D7 AF               xor a
   9++86D8 21 5F A3 11    ld hl, outputBuffer, de, outputBuffer + 1
   9++86DC 60 A3
  10++86DE 01 9F 5C         ld bc, #ffff - outputBuffer - 1
  11++86E1 77               ld (hl), a
  12++86E2 ED B0            ldir
  13++86E4
  14++86E4 3A F4 87         ld a, (historyBlock.isFile)
  14++86E7 A7             and a
  14++86E8 C2 BC 9D       jp nz, Fetcher.fetchFromFS
  15++86EB C3 6C 9D         jp Fetcher.fetchFromNet
  16++86EE
  17++86EE 4C 6F 61 64  .msg db "Loading resource! Please wait! It will be here soon!", 0
  17++86F2 69 6E 67 20
  17++86F6 72 65 73 6F
  17++86FA 75 72 63 65
  17++86FE 21 20 50 6C
  17++8702 65 61 73 65
  17++8706 20 77 61 69
  17++870A 74 21 20 49
  17++870E 74 20 77 69
  17++8712 6C 6C 20 62
  17++8716 65 20 68 65
  17++871A 72 65 20 73
  17++871E 6F 6F 6E 21
  17++8722 00
  18++8723
  19++8723              home:
  20++8723 21 D4 87         ld hl, homePage
  21++8726              ; HL - gopher row
  22++8726              navigate:
  23++8726 54 5D            ld de, hl
  24++8728 CD E5 9B         call UrlEncoder.isValidGopherRow
  25++872B 30 A4            jr nc, load ; Not valid - reload last
  26++872D 62 6B            ld hl, de
  27++872F E5               push hl
  28++8730
  29++8730 E5               push hl
  30++8731 21 5B 98 11      ld hl, HistoryEnd - HistoryRecord, de, HistoryEnd, bc,  HistoryRecord * total
  30++8735 A3 9B 01 68
  30++8739 10
  30++873A ED B8          lddr
  31++873C
  32++873C ED 5B 3A 8B      ld de, (Render.position), (historyBlock.position + HistoryRecord), de
  32++8740 ED 53 82 8E
  33++8744                  ; Clean up struct
  34++8744 AF               xor a
  34++8745 21 F4 87 11    ld hl, historyBlock, de, historyBlock + 1, bc, historyBlockSize - 1, (hl), a
  34++8749 F5 87 01 47
  34++874D 03 77
  34++874F ED B0          ldir
  35++8751 E1               pop hl
  36++8752
  37++8752                  ; Fill record
  38++8752 54 5D            ld de, hl
  39++8754 CD A4 9B         call UrlEncoder.isFile
  40++8757 EB               ex hl, de
  41++8758 11 F4 87         ld de, historyBlock
  42++875B 12               ld (de), a
  42++875C 13             inc de
  43++875D 7E               ld a, (hl)
  43++875E E5 D5          push hl, de
  43++8760 CD 06 81       call Render.getIcon
  43++8763 D1 E1          pop de, hl
  44++8765 12               ld (de), a
  44++8766 13             inc de
  45++8767 3E 09 01 FF      ld a, 9, bc, #fff
  45++876B 0F
  45++876C ED B1          cpir
  46++876E              .locatorCopy
  47++876E 7E               ld a, (hl)
  47++876F FE 09          cp 9
  47++8771 28 05          jr z, 1f
  48++8773 12               ld (de), a
  48++8774 23 13          inc hl, de
  49++8776 18 F6            jr .locatorCopy
  50++8778              1
  51++8778 23               inc hl
  51++8779 AF             xor a
  51++877A 12             ld (de), a
  52++877B 11 F5 89         ld de, historyBlock.host
  53++877E              .hostCopy
  54++877E 7E               ld a, (hl)
  54++877F FE 09          cp 9
  54++8781 28 05          jr z, 1f
  55++8783 12               ld (de), a
  55++8784 23 13          inc hl, de
  56++8786 18 F6            jr .hostCopy
  57++8788              1
  58++8788 23               inc hl
  58++8789 AF             xor a
  58++878A 12             ld (de), a
  59++878B 11 35 8A         ld de, historyBlock.port
  60++878E              .portCopy
  61++878E 7E               ld a, (hl)
  62++878F FE 09            cp 9
  62++8791 28 11          jr z, 1f
  63++8793 FE 0D            cp 13
  63++8795 28 0D          jr z, 1f
  64++8797 FE 0A            cp 10
  64++8799 28 09          jr z, 1f
  65++879B FE 00            cp 0
  65++879D 28 05          jr z, 1f
  66++879F 12               ld (de), a
  66++87A0 23 13          inc hl, de
  67++87A2 18 EA            jr .portCopy
  68++87A4 AF           1   xor a
  68++87A5 12             ld (de), a
  69++87A6 21 D7 85 11      ld hl, DialogBox.inputBuffer, de, historyBlock.search, bc, #ff
  69++87AA 3B 8A 01 FF
  69++87AE 00
  69++87AF ED B0          ldir
  70++87B1 11 00 00 ED      ld de, 0, (historyBlock.position), de
  70++87B5 53 3A 8B
  71++87B8 E1               pop hl
  72++87B9 3A F3 87         ld a, (depth)
  72++87BC FE 05          cp total
  72++87BE 30 04          jr nc, 1f
  73++87C0 3C               inc a
  73++87C1 32 F3 87       ld (depth), a
  74++87C4              1
  75++87C4 3A F5 87         ld a,(historyBlock.mediaType)
  75++87C7 FE 01          cp MIME_DOWNLOAD
  75++87C9 CA B9 9E       jp z, Gopher.download
  76++87CC
  77++87CC                  ifdef GS
  78++87CC FE 07            cp MIME_MOD
  78++87CE CA 5B 9E       jp z, Gopher.loadMod
  79++87D1                  endif
  80++87D1
  81++87D1 C3 D1 86         jp load
  82++87D4
  83++87D4              homePage:
  84++87D4 31 48 6F 6D      db "1Home", TAB, "data/index.gph"
  84++87D8 65 09 64 61
  84++87DC 74 61 2F 69
  84++87E0 6E 64 65 78
  84++87E4 2E 67 70 68
  85++87E8 09 66 69 6C      db TAB, "file", TAB, "70", CR, LF, 0
  85++87EC 65 09 37 30
  85++87F0 0D 0A 00
  86++87F3                  endmodule
# file closed: gopher/engine/history/controler.asm
   2+ 87F3                  include "model.asm"
# file opened: gopher/engine/history/model.asm
   1++87F3              total   equ 5
   2++87F3 00           depth   db 0
   3++87F4
   4++87F4              historyBlock:
   5++87F4 00           .isFile    db  0
   6++87F5 00           .mediaType db  0
   7++87F6 00 00 00...  .locator   ds  #1ff
   8++89F5 00 00 00...  .host      ds  64
   9++8A35 00 00 00...  .port      ds  6
  10++8A3B 00 00 00...  .search    ds  #ff
  11++8B3A 00 00        .position  dw  #00
  12++8B3C
  13++8B3C              historyBlockSize = $ - historyBlock
  14++8B3C
  15++8B3C              HistoryRecord EQU $ - historyBlock
  16++8B3C                  dup total
  17++8B3C 00 00 00... >    ds HistoryRecord
  17++8E84 00 00 00... >    ds HistoryRecord
  17++91CC 00 00 00... >    ds HistoryRecord
  17++9514 00 00 00... >    ds HistoryRecord
  17++985C 00 00 00... >    ds HistoryRecord
  18++9860                  edup
  19++9BA4              HistoryEnd equ $ - 1
# file closed: gopher/engine/history/model.asm
# file closed: gopher/engine/history/index.asm
  20  9BA4                  include "gopher/engine/urlencoder.asm"
# file opened: gopher/engine/urlencoder.asm
   1+ 9BA4                  MODULE UrlEncoder
   2+ 9BA4              ; HL - pointer to line in gopher page
   3+ 9BA4              ; C - flag set when it's file
   4+ 9BA4              isFile:
   5+ 9BA4              .findServerLoop
   6+ 9BA4 7E               ld a, (hl)
   6+ 9BA5 A7             and a
   6+ 9BA6 28 3B          jr z, .notFile
   6+ 9BA8 23             inc hl
   7+ 9BA9 FE 0D            cp 13
   7+ 9BAB 28 36          jr z, .notFile
   8+ 9BAD FE 09            cp 9
   8+ 9BAF 28 02          jr z, .skipPath
   9+ 9BB1 18 F1            jr .findServerLoop
  10+ 9BB3              .skipPath
  11+ 9BB3 7E               ld a, (hl)
  11+ 9BB4 A7             and a
  11+ 9BB5 28 2C          jr z, .notFile
  11+ 9BB7 23             inc hl
  12+ 9BB8 FE 0D            cp 13
  12+ 9BBA 28 27          jr z, .notFile
  13+ 9BBC FE 09            cp 9
  13+ 9BBE 28 02          jr z, .compareServer
  14+ 9BC0 18 F1            jr .skipPath
  15+ 9BC2              .compareServer
  16+ 9BC2 7E               ld a, (hl)
  16+ 9BC3 FE 66          cp "f"
  16+ 9BC5 20 1C          jr nz, .notFile
  16+ 9BC7 23             inc hl
  17+ 9BC8 7E               ld a, (hl)
  17+ 9BC9 FE 69          cp "i"
  17+ 9BCB 20 16          jr nz, .notFile
  17+ 9BCD 23             inc hl
  18+ 9BCE 7E               ld a, (hl)
  18+ 9BCF FE 6C          cp "l"
  18+ 9BD1 20 10          jr nz, .notFile
  18+ 9BD3 23             inc hl
  19+ 9BD4 7E               ld a, (hl)
  19+ 9BD5 FE 65          cp "e"
  19+ 9BD7 20 0A          jr nz, .notFile
  19+ 9BD9 23             inc hl
  20+ 9BDA 7E               ld a, (hl)
  20+ 9BDB FE 09          cp 9
  20+ 9BDD 20 04          jr nz, .notFile
  20+ 9BDF 23             inc hl
  21+ 9BE0 3E 01            ld a, 1
  22+ 9BE2 C9               ret
  23+ 9BE3              .notFile
  24+ 9BE3 AF               xor a
  25+ 9BE4 C9               ret
  26+ 9BE5
  27+ 9BE5              ; Is enough fields to encode
  28+ 9BE5              ; HL - pointer to line in gopher page
  29+ 9BE5              ; C - flag set when there is enough fields
  30+ 9BE5              isValidGopherRow:
  31+ 9BE5 7E               ld a, (hl)
  31+ 9BE6 A7             and a
  31+ 9BE7 28 FA          jr z, isFile.notFile
  31+ 9BE9 23             inc hl
  32+ 9BEA FE 0D            cp 13
  32+ 9BEC 28 F5          jr z, isFile.notFile
  33+ 9BEE FE 09            cp 9
  33+ 9BF0 28 02          jr z, .skipPath
  34+ 9BF2 18 F1            jr isValidGopherRow
  35+ 9BF4              .skipPath
  36+ 9BF4 7E               ld a, (hl)
  36+ 9BF5 A7             and a
  36+ 9BF6 28 EB          jr z, isFile.notFile
  36+ 9BF8 23             inc hl
  37+ 9BF9 FE 0D            cp 13
  37+ 9BFB 28 E6          jr z, isFile.notFile
  38+ 9BFD FE 09            cp 9
  38+ 9BFF 28 02          jr z, .skipHost
  39+ 9C01 18 F1            jr .skipPath
  40+ 9C03              .skipHost
  41+ 9C03 7E               ld a, (hl)
  41+ 9C04 A7             and a
  41+ 9C05 28 DC          jr z, isFile.notFile
  41+ 9C07 23             inc hl
  42+ 9C08 FE 0D            cp 13
  42+ 9C0A 28 D7          jr z, isFile.notFile
  43+ 9C0C FE 09            cp 9
  43+ 9C0E 28 02           jr z, .isValid
  44+ 9C10 18 F1            jr .skipHost
  45+ 9C12              .isValid:
  46+ 9C12 37               scf
  47+ 9C13 C9               ret
  48+ 9C14
  49+ 9C14              extractPath:
  50+ 9C14 21 F6 87 11      ld hl, historyBlock.locator, de, nameBuffer, bc, #ff
  50+ 9C18 2C 9C 01 FF
  50+ 9C1C 00
  50+ 9C1D ED B0          ldir
  51+ 9C1F C9               ret
  52+ 9C20
  53+ 9C20              extractHostName:
  54+ 9C20 21 F5 89 11      ld hl, historyBlock.host, de, hostName, bc, 64
  54+ 9C24 2C 9D 01 40
  54+ 9C28 00
  54+ 9C29 ED B0          ldir
  55+ 9C2B C9               ret
  56+ 9C2C
  57+ 9C2C                  ENDMODULE
  58+ 9C2C
  59+ 9C2C 00 00 00...  nameBuffer ds #ff, 0
  60+ 9D2B
  61+ 9D2B 00                    db 0
  62+ 9D2C 00 00 00...  hostName ds 64
# file closed: gopher/engine/urlencoder.asm
  21  9D6C                  include "gopher/engine/fetcher.asm"
# file opened: gopher/engine/fetcher.asm
   1+ 9D6C                  MODULE Fetcher
   2+ 9D6C
   3+ 9D6C              fetchFromNet:
   4+ 9D6C CD 33 9E         call Gopher.makeRequest
   4+ 9D6F 38 06          jr c, .error
   5+ 9D71 CD 4B 9E         call Gopher.loadBuffer
   6+ 9D74 C3 C8 9D         jp MediaProcessor.processResource
   7+ 9D77              .error
   8+ 9D77              	OS_ESP_CLOSE ;закрыть соединение, если было
   8+ 9D77 0E 0C       >    ld c,#0c
   8+ 9D79 E7          >    rst #20
   9+ 9D7A 21 83 9D         ld hl, .err
   9+ 9D7D CD 27 86       call DialogBox.msgBox
  10+ 9D80 C3 BA 86         jp History.back
  11+ 9D83
  12+ 9D83 44 6F 63 75  .err db "Document fetch error! Check your connection or hostname!", 0
  12+ 9D87 6D 65 6E 74
  12+ 9D8B 20 66 65 74
  12+ 9D8F 63 68 20 65
  12+ 9D93 72 72 6F 72
  12+ 9D97 21 20 43 68
  12+ 9D9B 65 63 6B 20
  12+ 9D9F 79 6F 75 72
  12+ 9DA3 20 63 6F 6E
  12+ 9DA7 6E 65 63 74
  12+ 9DAB 69 6F 6E 20
  12+ 9DAF 6F 72 20 68
  12+ 9DB3 6F 73 74 6E
  12+ 9DB7 61 6D 65 21
  12+ 9DBB 00
  13+ 9DBC
  14+ 9DBC
  15+ 9DBC              fetchFromFS:
  16+ 9DBC CD 14 9C         call UrlEncoder.extractPath
  17+ 9DBF              loadFile
  18+ 9DBF 21 2C 9C         ld hl, nameBuffer
  19+ 9DC2 CD 5E 86         call Dos.loadBuffer
  20+ 9DC5 C3 C8 9D         jp MediaProcessor.processResource
  21+ 9DC8                  ENDMODULE
# file closed: gopher/engine/fetcher.asm
  22  9DC8                  include "gopher/engine/media-processor.asm"
# file opened: gopher/engine/media-processor.asm
   1+ 9DC8                  MODULE MediaProcessor
   2+ 9DC8              processResource:
   3+ 9DC8 CD 20 9C         call UrlEncoder.extractHostName
   4+ 9DCB 3A F5 87         ld a, (historyBlock.mediaType)
   5+ 9DCE FE 05            cp MIME_MUSIC
   5+ 9DD0 28 17          jr z, processPT
   6+ 9DD2 FE 02            cp MIME_LINK
   6+ 9DD4 28 1F          jr z, processPage
   7+ 9DD6 FE 04            cp MIME_INPUT
   7+ 9DD8 28 1B          jr z, processPage
   8+ 9DDA FE 06            cp MIME_IMAGE
   8+ 9DDC CA 1F A2       jp z, ScreenViewer.display
   9+ 9DDF              	ifdef GS
  10+ 9DDF FE 07            cp MIME_MOD
  10+ 9DE1 28 0C          jr z, processMOD
  11+ 9DE3              	endif
  12+ 9DE3              ; Fallback to plain text
  13+ 9DE3              processText:
  14+ 9DE3 CD E1 84         call Render.renderPlainTextScreen
  15+ 9DE6 C3 1D 85         jp   Render.plainTextLoop
  16+ 9DE9
  17+ 9DE9              processPT:
  18+ 9DE9 CD 8A A1         call VortexProcessor.play
  19+ 9DEC C3 BA 86         jp History.back
  20+ 9DEF
  21+ 9DEF                  ifdef GS
  22+ 9DEF              processMOD:
  23+ 9DEF CD DE A1         call ModProcessor.play
  24+ 9DF2 C3 BA 86         jp History.back
  25+ 9DF5              	endif
  26+ 9DF5
  27+ 9DF5              processPage:
  28+ 9DF5 3A 81 85         ld a, (Render.play_next)
  28+ 9DF8 A7             and a
  28+ 9DF9 20 06          jr nz, .playNext
  29+ 9DFB CD 85 83         call Render.renderGopherScreen
  30+ 9DFE C3 CC 83         jp   Render.workLoop
  31+ 9E01              .playNext
  32+ 9E01 21 3B 8B         ld hl, Render.cursor_position
  33+ 9E04 34               inc (hl)
  34+ 9E05 C3 B6 83         jp Render.checkBorder
  35+ 9E08
  36+ 9E08
  37+ 9E08                  ENDMODULE
# file closed: gopher/engine/media-processor.asm
  23  9E08                  include "gopher/gopher.asm"
# file opened: gopher/gopher.asm
   1+ 9E08                  module Gopher
   2+ 9E08              extractRequest:
   3+ 9E08 21 F6 87         ld hl, historyBlock.locator
   4+ 9E0B 11 8B 9F         ld de, requestbuffer
   5+ 9E0E              .loop
   6+ 9E0E 7E               ld a, (hl)
   7+ 9E0F 12               ld (de), a
   8+ 9E10 23               inc hl
   9+ 9E11 13               inc de
  10+ 9E12 FE 00            cp 0
  11+ 9E14 28 02            jr z, .search
  12+ 9E16 18 F6            jr .loop
  13+ 9E18              .search
  14+ 9E18 1B               dec de
  15+ 9E19 3A F5 87         ld a, (historyBlock.mediaType)
  16+ 9E1C FE 04            cp MIME_INPUT
  17+ 9E1E 20 10            jr nz, .exit
  18+ 9E20 21 3B 8A         ld hl, historyBlock.search
  19+ 9E23 3E 09            ld a, TAB
  20+ 9E25 12               ld (de), a
  21+ 9E26 13               inc de
  22+ 9E27              .searchCopy
  23+ 9E27 7E               ld a, (hl)
  24+ 9E28 A7               and a
  24+ 9E29 28 05          jr z, .exit
  25+ 9E2B 12               ld (de), a
  26+ 9E2C 23               inc hl
  26+ 9E2D 13             inc de
  27+ 9E2E 18 F7            jr .searchCopy
  28+ 9E30              .exit
  29+ 9E30 AF               xor a
  30+ 9E31 12               ld (de), a
  31+ 9E32 C9               ret
  32+ 9E33
  33+ 9E33
  34+ 9E33              makeRequest:
  35+ 9E33 CD 08 9E         call extractRequest
  36+ 9E36
  37+ 9E36 21 F5 89         ld hl, historyBlock.host
  38+ 9E39 11 35 8A         ld de, historyBlock.port
  39+ 9E3C CD 5F A2         call Wifi.openTCP
  40+ 9E3F D8               ret c
  41+ 9E40
  42+ 9E40 21 8B 9F         ld hl, requestbuffer
  43+ 9E43 CD 89 A2         call Wifi.tcpSendZ
  44+ 9E46 AF               xor a
  44+ 9E47 32 5E A2       ld (Wifi.closed), a
  45+ 9E4A C9               ret
  46+ 9E4B
  47+ 9E4B
  48+ 9E4B              loadBuffer:
  49+ 9E4B 21 5F A3         ld hl, outputBuffer
  50+ 9E4E 22 5C A2         ld (Wifi.buffer_pointer), hl
  51+ 9E51              .loop
  52+ 9E51 CD A7 A2         call Wifi.getPacket
  53+ 9E54 3A 5E A2         ld a, (Wifi.closed)
  53+ 9E57 A7             and a
  53+ 9E58 C0             ret nz
  54+ 9E59                  ;call Wifi.continue
  55+ 9E59 18 F6            jr .loop
  56+ 9E5B
  57+ 9E5B                  ifdef GS
  58+ 9E5B              loadMod:
  59+ 9E5B AF               xor a
  59+ 9E5C CD FC A2       call GeneralSound.init
  60+ 9E5F 21 99 9E         ld hl, .progress
  60+ 9E62 CD 30 86       call DialogBox.msgNoWait
  61+ 9E65 CD 33 9E         call makeRequest
  61+ 9E68 DA 77 9D       jp c, Fetcher.fetchFromNet.error
  62+ 9E6B CD 09 A3         call GeneralSound.loadModule
  63+ 9E6E              .loop
  64+ 9E6E 21 5F A3 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
  64+ 9E72 5C A2
  65+ 9E74 CD A7 A2         call Wifi.getPacket
  66+ 9E77 3A 5E A2         ld a, (Wifi.closed)
  66+ 9E7A A7             and a
  66+ 9E7B 20 16          jr nz, .exit
  67+ 9E7D 21 5F A3 ED      ld hl, outputBuffer, bc, (Wifi.bytes_avail)
  67+ 9E81 4B 5A A2
  68+ 9E84              .loadLoop
  69+ 9E84 78               ld a, b
  69+ 9E85 B1             or c
  69+ 9E86 A7             and a
  69+ 9E87 28 08          jr z, .nextFrame
  70+ 9E89 7E               ld a, (hl)
  70+ 9E8A CD 1C A3       call GeneralSound.sendByte
  71+ 9E8D 0B               dec bc
  72+ 9E8E 23               inc hl
  73+ 9E8F 18 F3            jr .loadLoop
  74+ 9E91              .nextFrame
  75+ 9E91                  ;call Wifi.continue
  76+ 9E91 18 DB            jr .loop
  77+ 9E93              .exit
  78+ 9E93 CD 24 A3         call GeneralSound.finishLoadingModule
  79+ 9E96                  ;jp History.back
  80+ 9E96 C3 C8 9D     	jp MediaProcessor.processResource
  81+ 9E99 4D 4F 44 20  .progress db "MOD downloading directly to GS!", 0
  81+ 9E9D 64 6F 77 6E
  81+ 9EA1 6C 6F 61 64
  81+ 9EA5 69 6E 67 20
  81+ 9EA9 64 69 72 65
  81+ 9EAD 63 74 6C 79
  81+ 9EB1 20 74 6F 20
  81+ 9EB5 47 53 21 00
  82+ 9EB9                  endif
  83+ 9EB9
  84+ 9EB9
  85+ 9EB9              download:
  86+ 9EB9
  87+ 9EB9 11 F6 87         ld de, historyBlock.locator
  88+ 9EBC 62 6B            ld hl, de
  89+ 9EBE              .findFileName
  90+ 9EBE 1A               ld a, (de)
  90+ 9EBF 13             inc de
  91+ 9EC0 FE 2F            cp '/'
  91+ 9EC2 20 02          jr nz, .skip
  92+ 9EC4 62 6B            ld hl, de
  93+ 9EC6              .skip
  94+ 9EC6 A7               and a
  94+ 9EC7 20 F5          jr nz, .findFileName
  95+ 9EC9              .copy
  96+ 9EC9                  ;; HL - filename pointer
  97+ 9EC9 11 D7 85         ld de, DialogBox.inputBuffer
  98+ 9ECC              .copyFileName
  99+ 9ECC 7E               ld a, (hl)
  99+ 9ECD A7             and a
  99+ 9ECE 28 05          jr z, .finishCopy
 100+ 9ED0
 101+ 9ED0 12               ld (de), a
 101+ 9ED1 23 13          inc hl, de
 102+ 9ED3 18 F7            jr .copyFileName
 103+ 9ED5              .finishCopy
 104+ 9ED5 12               ld (de), a
 105+ 9ED6 CD 86 85         call DialogBox.inputBox.noclear
 106+ 9ED9 3A D7 85         ld a, (DialogBox.inputBuffer)
 106+ 9EDC A7             and a
 106+ 9EDD CA BA 86       jp z, History.back
 107+ 9EE0
 108+ 9EE0 CD 33 9E         call makeRequest
 108+ 9EE3 DA 77 9D       jp c, Fetcher.fetchFromNet.error
 109+ 9EE6
 110+ 9EE6 06 0E 21 D7      ld b, Dos.FMODE_CREATE, hl, DialogBox.inputBuffer
 110+ 9EEA 85
 111+ 9EEB CD 7A 86         call Dos.fopen
 112+ 9EEE 32 89 9F         ld (.fp), a
 113+ 9EF1
 114+ 9EF1 21 64 9F         ld hl, .progress
 114+ 9EF4 CD 30 86       call DialogBox.msgNoWait
 115+ 9EF7              .loop
 116+ 9EF7 21 5F A3 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
 116+ 9EFB 5C A2
 117+ 9EFD CD A7 A2         call Wifi.getPacket
 118+ 9F00 3A 5E A2         ld a, (Wifi.closed)
 118+ 9F03 A7             and a
 118+ 9F04 20 0F          jr nz, .exit
 119+ 9F06
 120+ 9F06 3A 89 9F 21      ld a, (.fp), hl, outputBuffer, bc, (Wifi.bytes_avail)
 120+ 9F0A 5F A3 ED 4B
 120+ 9F0E 5A A2
 121+ 9F10 CD 9D 86         call Dos.fwrite
 122+ 9F13
 123+ 9F13                  ;call Wifi.continue
 124+ 9F13 18 E2            jr .loop
 125+ 9F15              .exit
 126+ 9F15 3A 89 9F         ld a, (.fp)
 127+ 9F18 CD 93 86         call Dos.fclose
 128+ 9F1B C3 BA 86         jp History.back
 129+ 9F1E              ;.error
 130+ 9F1E 3A 89 9F         ld a, (.fp)
 131+ 9F21 CD 93 86         call Dos.fclose
 132+ 9F24
 133+ 9F24 21 2D 9F         ld hl, .err
 134+ 9F27 CD 27 86         call DialogBox.msgBox
 135+ 9F2A C3 BA 86         jp History.back
 136+ 9F2D 4F 70 65 72  .err db "Operation failed! Sorry! Check filename or disk space!",0
 136+ 9F31 61 74 69 6F
 136+ 9F35 6E 20 66 61
 136+ 9F39 69 6C 65 64
 136+ 9F3D 21 20 53 6F
 136+ 9F41 72 72 79 21
 136+ 9F45 20 43 68 65
 136+ 9F49 63 6B 20 66
 136+ 9F4D 69 6C 65 6E
 136+ 9F51 61 6D 65 20
 136+ 9F55 6F 72 20 64
 136+ 9F59 69 73 6B 20
 136+ 9F5D 73 70 61 63
 136+ 9F61 65 21 00
 137+ 9F64 44 6F 77 6E  .progress db "Downloading in progress! Wait a bit!", 0
 137+ 9F68 6C 6F 61 64
 137+ 9F6C 69 6E 67 20
 137+ 9F70 69 6E 20 70
 137+ 9F74 72 6F 67 72
 137+ 9F78 65 73 73 21
 137+ 9F7C 20 57 61 69
 137+ 9F80 74 20 61 20
 137+ 9F84 62 69 74 21
 137+ 9F88 00
 138+ 9F89 00           .fp db 0
 139+ 9F8A
 140+ 9F8A 00           socket db 0
 141+ 9F8B
 142+ 9F8B 00 00 00...  requestbuffer ds #1ff
 143+ A18A                  endmodule
 144+ A18A
# file closed: gopher/gopher.asm
  24  A18A                  include "player/vortex-processor.asm"
# file opened: player/vortex-processor.asm
   1+ A18A                  MODULE VortexProcessor
   2+ A18A              play:
   3+ A18A CD A4 86         call Console.waitForKeyUp
   4+ A18D
   5+ A18D 21 C9 A1         ld hl, message
   5+ A190 CD 30 86       call DialogBox.msgNoWait
   6+ A193
   7+ A193 21 5F A3         ld hl, outputBuffer
   7+ A196                OS_VTPL_INIT
   7+ A196 0E 15       >    ld c,#15
   7+ A198 E7          >    rst #20
   8+ A199
   9+ A199
  10+ A199 3E 01 32 81      ld a, 1, (Render.play_next), a
  10+ A19D 85
  11+ A19E                  ifdef GS
  12+ A19E CD 40 A3         call GeneralSound.stopModule
  13+ A1A1                  endif
  14+ A1A1              	OS_VTPL_PLAY
  14+ A1A1 0E 16       >    ld c,#16
  14+ A1A3 E7          >    rst #20
  15+ A1A4              .loop
  16+ A1A4                  OS_WAIT
  16+ A1A4 DF          >	rst #18
  16+ A1A5               ; di : call VTPL.PLAY : ei
  17+ A1A5              	OS_GET_CHAR
  17+ A1A5 0E 10       >    ld c,#10
  17+ A1A7 E7          >    rst #20
  18+ A1A8 FE 20        	cp " " ;останов по пробелу
  19+ A1AA CA C3 A1     	jp z, .stopKey
  20+ A1AD CD 4F A2     	call printRTC
  21+ A1B0              	OS_GET_VTPL_SETUP
  21+ A1B0 0E 18       >    ld c,#18
  21+ A1B2 E7          >    rst #20
  22+ A1B3 7E               ld a, (hl)
  22+ A1B4
  23+ A1B4 17           	rla
  23+ A1B5 30 ED          jr nc, .loop
  24+ A1B7 3E 01 32 81      ld a, 1, (Render.play_next), a
  24+ A1BB 85
  25+ A1BC              .stop
  26+ A1BC              	OS_VTPL_MUTE
  26+ A1BC 0E 17       >    ld c,#17
  26+ A1BE E7          >    rst #20
  27+ A1BF
  28+ A1BF                  IFDEF AY
  29+ A1BF ~                call restoreAyState
  30+ A1BF                  ENDIF
  31+ A1BF
  32+ A1BF CD A4 86         call Console.waitForKeyUp
  33+ A1C2 C9               ret
  34+ A1C3              .stopKey
  35+ A1C3 AF               xor a
  35+ A1C4 32 81 85       ld (Render.play_next), a
  36+ A1C7 18 F3            jr .stop
  37+ A1C9
  38+ A1C9                  IFDEF AY
  39+ A1C9 ~            restoreAyState:
  40+ A1C9 ~                ld a, #07
  41+ A1C9 ~                ld bc, #fffd
  42+ A1C9 ~                out (c), a
  43+ A1C9 ~                ld a, #fc
  44+ A1C9 ~                ld b, #bf
  45+ A1C9 ~                out (c), a ; Enable read mode
  46+ A1C9 ~
  47+ A1C9 ~                ld a, #0e
  48+ A1C9 ~                ld bc, #fffd
  49+ A1C9 ~                out (c), a
  50+ A1C9 ~                ret
  51+ A1C9                  ENDIF
  52+ A1C9
  53+ A1C9 50 72 65 73  message db "Press key to stop...", 0
  53+ A1CD 73 20 6B 65
  53+ A1D1 79 20 74 6F
  53+ A1D5 20 73 74 6F
  53+ A1D9 70 2E 2E 2E
  53+ A1DD 00
  54+ A1DE                  ENDMODULE
  55+ A1DE                  ;include "player.asm"
  56+ A1DE
# file closed: player/vortex-processor.asm
  25  A1DE                  include "player/mod-processor.asm"
# file opened: player/mod-processor.asm
   1+ A1DE                  MODULE ModProcessor
   2+ A1DE                  ifdef GS
   3+ A1DE
   4+ A1DE                  macro _WaitCommand2
   5+ A1DE ~            .wait
   6+ A1DE ~                in a, (CMD)
   7+ A1DE ~                rrca
   8+ A1DE ~                jr c, .wait
   9+ A1DE                  endm
  10+ A1DE
  11+ A1DE                  macro _SendCommand2 nn
  12+ A1DE ~                ld a, nn
  12+ A1DE ~              out (CMD), a
  13+ A1DE                  endm
  14+ A1DE
  15+ A1DE              play:
  16+ A1DE CD A4 86         call Console.waitForKeyUp
  17+ A1E1
  18+ A1E1 21 8B 9F         ld hl, Gopher.requestbuffer
  18+ A1E4 CD 30 86       call DialogBox.msgNoWait
  19+ A1E7
  20+ A1E7                  ;ld a, 1, (Render.play_next), a
  21+ A1E7 AF           	xor a
  22+ A1E8 32 1E A2     	ld (last_song_position),a
  23+ A1EB
  24+ A1EB              .loop
  25+ A1EB                  OS_WAIT
  25+ A1EB DF          >	rst #18
  25+ A1EC
  26+ A1EC                  OS_GET_CHAR
  26+ A1EC 0E 10       >    ld c,#10
  26+ A1EE E7          >    rst #20
  27+ A1EF FE 20        	cp " " ;пробел
  28+ A1F1 CA 18 A2     	jp z, .stopKey
  29+ A1F4 CD 4F A2     	call printRTC
  30+ A1F7                  ;проверка что MOD начал играть сначала
  31+ A1F7                  _SendCommand2 CMD_GET_SONG_POSITION
  31+ A1F7 3E 60       >    ld a, CMD_GET_SONG_POSITION
  31+ A1F9 D3 BB       >  out (CMD), a
  32+ A1FB                  _WaitCommand2
  32+ A1FB             >.wait
  32+ A1FB DB BB       >    in a, (CMD)
  32+ A1FD 0F          >    rrca
  32+ A1FE 38 FB       >    jr c, .wait
  33+ A200 3A 1E A2     	ld a,(last_song_position) ;предыдущая позиция
  34+ A203 4F           	ld c,a
  35+ A204 DB B3        	in a,(DATA) ;текущая позиция
  36+ A206 32 1E A2     	ld (last_song_position),a
  37+ A209 B9           	cp c
  38+ A20A 30 DF        	jr nc, .loop ;если не меньше, продолжаем играть
  39+ A20C 3E 01 32 81      ld a, 1, (Render.play_next), a ;флаг что надо будет играть следующий файл
  39+ A210 85
  40+ A211              .stop
  41+ A211 CD 40 A3         call GeneralSound.stopModule
  42+ A214
  43+ A214 CD A4 86         call Console.waitForKeyUp
  44+ A217 C9               ret
  45+ A218              .stopKey
  46+ A218 AF               xor a
  46+ A219 32 81 85       ld (Render.play_next), a ;флаг что не надо играть следующий файл
  47+ A21C 18 F3            jr .stop
  48+ A21E
  49+ A21E
  50+ A21E              ;message db "Press key to stop...", 0
  51+ A21E
  52+ A21E
  53+ A21E              CMD_GET_SONG_POSITION     = #60
  54+ A21E 00           last_song_position db 0
  55+ A21F
  56+ A21F              ;; Control ports
  57+ A21F              CMD  = 187
  58+ A21F              DATA = 179
  59+ A21F
  60+ A21F                  endif
  61+ A21F                  ENDMODULE
  62+ A21F
  63+ A21F
# file closed: player/mod-processor.asm
  26  A21F                  include "screen/screen.asm"
# file opened: screen/screen.asm
   1+ A21F                  module ScreenViewer
   2+ A21F              display:
   3+ A21F CD A4 86         call Console.waitForKeyUp
   4+ A222                  ;ld a, 7 : call Memory.setPage
   5+ A222                  ;ld hl, outputBuffer+6912, de, #c000+6912, bc, 6912 : lddr
   6+ A222              	OS_GET_MAIN_PAGES
   6+ A222 0E 1E       >    ld c,#1e
   6+ A224 E7          >    rst #20
   7+ A225 78           	ld a,b ; страница с буфером
   8+ A226 06 07        	ld b,7 ;страница назначения
   9+ A228 21 5F A3     	ld hl,outputBuffer
  10+ A22B 11 00 C0     	ld de,#c000
  11+ A22E DD 21 00 1B  	ld ix,6912
  12+ A232              	OS_RAM_COPY
  12+ A232 0E 19       >    ld c,#19
  12+ A234 E7          >    rst #20
  13+ A235                  ;call TextMode.disable
  14+ A235              display_wait
  15+ A235 3E 07        	ld a,7
  16+ A237              	OS_SET_SCREEN ;включить экран
  16+ A237 0E 1D       >    ld c,#1d
  16+ A239 E7          >    rst #20
  17+ A23A 30 03        	jr nc,.wait
  18+ A23C              	OS_WAIT
  18+ A23C DF          >	rst #18
  19+ A23D 18 F6        	jr display_wait
  20+ A23F              .wait
  21+ A23F              	OS_WAIT
  21+ A23F DF          >	rst #18
  22+ A240              	OS_GET_CHAR
  22+ A240 0E 10       >    ld c,#10
  22+ A242 E7          >    rst #20
  23+ A243 FE FF        	cp 255
  24+ A245 28 F8        	jr z, .wait
  25+ A247 3E 00        	ld a,0 ;текстовый
  26+ A249              	OS_SET_SCREEN
  26+ A249 0E 1D       >    ld c,#1d
  26+ A24B E7          >    rst #20
  27+ A24C                  ;call TextMode.cls
  28+ A24C C3 BA 86         jp History.back
  29+ A24F
  30+ A24F                  endmodule
# file closed: screen/screen.asm
  27  A24F                  include "screen/rtc.asm"
# file opened: screen/rtc.asm
   1+ A24F              printRTC
   2+ A24F              	ifndef SMUCRTC
   3+ A24F C9           	ret
   4+ A250              	endif
   5+ A250              	ifdef SMUCRTC
   6+ A250 ~            	;печать текущего времени
   7+ A250 ~            	call Clock.readTime
   8+ A250 ~            	jr nc,read_time_ok
   9+ A250 ~            	; ld hl,mes_no_RTC
  10+ A250 ~            	; call print_mes
  11+ A250 ~            	; scf
  12+ A250 ~            	ret ;выход
  13+ A250 ~            read_time_ok
  14+ A250 ~            	push bc
  15+ A250 ~            	ld l,e ;часы
  16+ A250 ~            	ld h,0
  17+ A250 ~            	call toDecimal
  18+ A250 ~            	ld de,00 ;координаты
  19+ A250 ~            	call TextMode.gotoXY
  20+ A250 ~            	ld hl,decimalS+3
  21+ A250 ~            	call TextMode.printZ
  22+ A250 ~            	ld a,":"
  23+ A250 ~            	call TextMode.putC
  24+ A250 ~            	pop bc
  25+ A250 ~            	ld l,b ;минуты
  26+ A250 ~            	ld h,0
  27+ A250 ~            	call toDecimal
  28+ A250 ~            	ld hl,decimalS+3
  29+ A250 ~            	call TextMode.printZ
  30+ A250 ~            	; ld a,":"
  31+ A250 ~            	; call TextMode.putC
  32+ A250 ~            	; ld l,c ;секунды
  33+ A250 ~            	; ld h,0
  34+ A250 ~            	; call toDecimal
  35+ A250 ~            	; ld hl,decimalS+3
  36+ A250 ~            	; call TextMode.printZ
  37+ A250 ~            	; or a ;нет ошибки
  38+ A250 ~            	ret
  39+ A250 ~
  40+ A250 ~
  41+ A250 ~            toDecimal		;конвертирует 2 байта в 5 десятичных цифр
  42+ A250 ~            				;на входе в HL число
  43+ A250 ~            			ld de,10000 ;десятки тысяч
  44+ A250 ~            			ld a,255
  45+ A250 ~            toDecimal10k
  46+ A250 ~            			and a
  47+ A250 ~            			sbc hl,de
  48+ A250 ~            			inc a
  49+ A250 ~            			jr nc,toDecimal10k
  50+ A250 ~            			add hl,de
  51+ A250 ~            			add a,48
  52+ A250 ~            			ld (decimalS),a
  53+ A250 ~            			ld de,1000 ;тысячи
  54+ A250 ~            			ld a,255
  55+ A250 ~            toDecimal1k
  56+ A250 ~            			and a
  57+ A250 ~            			sbc hl,de
  58+ A250 ~            			inc a
  59+ A250 ~            			jr nc,toDecimal1k
  60+ A250 ~            			add hl,de
  61+ A250 ~            			add a,48
  62+ A250 ~            			ld (decimalS+1),a
  63+ A250 ~            			ld de,100 ;сотни
  64+ A250 ~            			ld a,255
  65+ A250 ~            toDecimal01k
  66+ A250 ~            			and a
  67+ A250 ~            			sbc hl,de
  68+ A250 ~            			inc a
  69+ A250 ~            			jr nc,toDecimal01k
  70+ A250 ~            			add hl,de
  71+ A250 ~            			add a,48
  72+ A250 ~            			ld (decimalS+2),a
  73+ A250 ~            			ld de,10 ;десятки
  74+ A250 ~            			ld a,255
  75+ A250 ~            toDecimal001k
  76+ A250 ~            			and a
  77+ A250 ~            			sbc hl,de
  78+ A250 ~            			inc a
  79+ A250 ~            			jr nc,toDecimal001k
  80+ A250 ~            			add hl,de
  81+ A250 ~            			add a,48
  82+ A250 ~            			ld (decimalS+3),a
  83+ A250 ~            			ld de,1 ;единицы
  84+ A250 ~            			ld a,255
  85+ A250 ~            toDecimal0001k
  86+ A250 ~            			and a
  87+ A250 ~            			sbc hl,de
  88+ A250 ~            			inc a
  89+ A250 ~            			jr nc,toDecimal0001k
  90+ A250 ~            			add hl,de
  91+ A250 ~            			add a,48
  92+ A250 ~            			ld (decimalS+4),a
  93+ A250 ~
  94+ A250 ~            			ret
  95+ A250 ~
  96+ A250 ~            decimalS	ds 6 ;десятичные цифры
  97+ A250 ~
  98+ A250              	endif
# file closed: screen/rtc.asm
  28  A250                  include "drivers/index.asm"
# file opened: drivers/index.asm
   1+ A250                  IFDEF UNO
   2+ A250 ~                include "uno-uart.asm"
   3+ A250                  ENDIF
   4+ A250
   5+ A250                  IFDEF MB03
   6+ A250 ~                include "mb03-uart.asm"
   7+ A250                  ENDIF
   8+ A250
   9+ A250                  IFDEF AY
  10+ A250 ~                include "ay-uart.asm"
  11+ A250                  ENDIF
  12+ A250
  13+ A250                  IFDEF ZW
  14+ A250                  include "zx-wifi.asm"
# file opened: drivers/zx-wifi.asm
   1++A250              ; ; This driver works with 16c550 uart that's support AFE
   2++A250                  ; module Uart
   3++A250              ; ; Make init shorter and readable:-)
   4++A250                  ; macro outp port, value
   5++A250              	; ld b, port
   6++A250              	; ld c, #EF
   7++A250                  ; ld a, value
   8++A250                  ; out (c), a
   9++A250                  ; endm
  10++A250
  11++A250              ; ; Internal port constants
  12++A250              ; RBR_THR = #F8
  13++A250              ; IER     = RBR_THR + 1
  14++A250              ; IIR_FCR = RBR_THR + 2
  15++A250              ; LCR     = RBR_THR + 3
  16++A250              ; MCR     = RBR_THR + 4
  17++A250              ; LSR     = RBR_THR + 5
  18++A250              ; MSR     = RBR_THR + 6
  19++A250              ; SR      = RBR_THR + 7
  20++A250
  21++A250              ; init:
  22++A250                  ; outp MCR,     #0d  // Assert RTS
  23++A250                  ; outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  24++A250                  ; outp LCR,     #83  // 8n1, DLAB=1
  25++A250                  ; outp RBR_THR, #01  // 115200 (divider 1)
  26++A250                  ; outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  27++A250
  28++A250                  ; outp LCR,     #03 // 8n1, DLAB=0
  29++A250                  ; outp IER,     #00 // Disable int
  30++A250                  ; outp MCR,     #2f // Enable AFE
  31++A250                  ; ret
  32++A250
  33++A250              ; ;retry_rec_count_max equ %00011111 ;ждать столько прерываний
  34++A250
  35++A250              ; ; Flag C <- Data available
  36++A250              ; ; isAvailable:
  37++A250                  ; ; ld a, LSR
  38++A250                  ; ; in a, (#EF)
  39++A250                  ; ; rrca
  40++A250                  ; ; ret
  41++A250
  42++A250              ; ; Non-blocking read
  43++A250              ; ; Flag C <- is byte was readen
  44++A250              ; ; A <- byte
  45++A250              ; ; read1:
  46++A250                  ; ; ld a, LSR
  47++A250                  ; ; in a, (#EF)
  48++A250                  ; ; rrca
  49++A250                  ; ; ret nc
  50++A250                  ; ; ld a, RBR_THR
  51++A250                  ; ; in a, (#EF)
  52++A250                  ; ; scf
  53++A250                  ; ; ret
  54++A250
  55++A250              ; ; Tries read byte with timeout
  56++A250              ; ; Flag C <- is byte read
  57++A250              ; ; A <- byte
  58++A250              ; read:
  59++A250              	; ;xor a ;4
  60++A250              	; ;ld (#5C78),a ;обнулить счётчик ожидания ;13
  61++A250              ; .wait
  62++A250                  ; ld a, LSR
  63++A250                  ; in a, (#EF)
  64++A250                  ; rrca
  65++A250              	; jr nc, .wait
  66++A250                  ; ld a, RBR_THR
  67++A250                  ; in a, (#EF)
  68++A250              	; ret
  69++A250              ; ; .readW
  70++A250              	; ; OS_GETTIMER
  71++A250              	; ; ld a,e
  72++A250              	; ; and retry_rec_count_max
  73++A250              	; ; ;ld a,(#5C78)
  74++A250              	; ; ;cp retry_rec_count_max
  75++A250              	; ; jr nz, .wait ;ещё попытка
  76++A250              	; ; xor a ;выключим флаг переноса если время вышло
  77++A250              	; ; ret
  78++A250
  79++A250
  80++A250
  81++A250
  82++A250              ; ; Blocking read
  83++A250              ; ; A <- Byte
  84++A250              ; ; readB:
  85++A250                  ; ; ld a, LSR
  86++A250                  ; ; in a, (#EF)
  87++A250                  ; ; rrca
  88++A250                  ; ; jr nc, readB
  89++A250              	; ; ld a, RBR_THR
  90++A250                  ; ; in a, (#EF)
  91++A250                  ; ; ret
  92++A250
  93++A250              ; ; A -> byte to send
  94++A250              ; write:
  95++A250                  ; push af
  96++A250              ; .wait
  97++A250              	; ld a, LSR
  98++A250                  ; in a, (#EF)
  99++A250                  ; and #20
 100++A250                  ; jr z, .wait
 101++A250                  ; pop af
 102++A250              	; ld b, RBR_THR
 103++A250              	; ld c, #EF
 104++A250                  ; out (c), a
 105++A250                  ; ret
 106++A250
 107++A250                  ; endmodule
# file closed: drivers/zx-wifi.asm
  15+ A250                  ENDIF
  16+ A250
  17+ A250                  IFDEF SMUCRTC
  18+ A250 ~                include "smuc-rtc.asm"
  19+ A250                  ENDIF
  20+ A250
  21+ A250                  include "utils.asm"
# file opened: drivers/utils.asm
   1++A250              ; ;;; Macroses!!!!
   2++A250                  ; MACRO EspSend Text
   3++A250                  ; ld hl, .txtB
   4++A250                  ; ld e, (.txtE - .txtB)
   5++A250                  ; call espSend
   6++A250                  ; jr .txtE
   7++A250              ; .txtB
   8++A250                  ; db Text
   9++A250              ; .txtE
  10++A250                  ; ENDM
  11++A250
  12++A250                  ; MACRO EspCmd Text
  13++A250                  ; ld hl, .txtB
  14++A250                  ; ld e, (.txtE - .txtB)
  15++A250                  ; call espSend
  16++A250                  ; jr .txtE
  17++A250              ; .txtB
  18++A250                  ; db Text
  19++A250                  ; db 13, 10
  20++A250              ; .txtE
  21++A250                  ; ENDM
  22++A250
  23++A250                  ; MACRO EspCmdOkErr text
  24++A250                  ; EspCmd text
  25++A250                  ; call checkOkErr
  26++A250                  ; ENDM
  27++A250
  28++A250              ; IN DE - string pointer
  29++A250              ; OUT HL - string len
  30++A250              strLen:
  31++A250 21 00 00         ld hl, 0
  32++A253              .loop
  33++A253 1A               ld a, (de)
  33++A254 A7             and a
  33++A255 C8             ret z
  34++A256 13 23            inc de, hl
  35++A258 18 F9            jr .loop
# file closed: drivers/utils.asm
  22+ A25A                  include "wifi.asm"
# file opened: drivers/wifi.asm
   1++A25A                  MODULE Wifi
   2++A25A 00 00        bytes_avail dw 0
   3++A25C 00 00        buffer_pointer dw 0
   4++A25E 01           closed db 1
   5++A25F              ;link_id db 0;
   6++A25F              wait_count equ 5*50 ; ожидание в кадрах
   7++A25F              buffer_top equ #fa;ограничение буфера сверху #ffff - 1500
   8++A25F              ; ; Initialize Wifi chip to work
   9++A25F              ;init:
  10++A25F              	;ld hl,uartGetID : call TextMode.printZ
  11++A25F              ; init1:
  12++A25F              	; halt
  13++A25F              	; xor a ;CY=0
  14++A25F              	; OS_ESP_LINK_ID ;получить номер соединения
  15++A25F              	; jr c,init1:
  16++A25F              	; ld (link_id),a
  17++A25F              	;ret
  18++A25F                  ; ; ld hl, .uartIniting : call TextMode.printZ
  19++A25F                  ; ; call Uart.init
  20++A25F                  ; ld hl, .chipIniting : call TextMode.printZ
  21++A25F                  ; EspCmdOkErr "ATE0"
  22++A25F                  ; jr c, .initError
  23++A25F
  24++A25F                  ; EspCmdOkErr "AT+CIPSERVER=0"
  25++A25F                  ; EspCmdOkErr "AT+CIPCLOSE" ; Close if there some connection was. Don't care about result
  26++A25F                  ; EspCmdOkErr "AT+CIPMUX=0" ; Single connection mode
  27++A25F                  ; jr c, .initError
  28++A25F
  29++A25F                  ; EspCmdOkErr "AT+CIPDINFO=0" ; Disable additional info
  30++A25F                  ; jr c, .initError
  31++A25F
  32++A25F                  ; ld hl, .doneInit : call TextMode.printZ
  33++A25F
  34++A25F                  ; or a
  35++A25F                  ; ret
  36++A25F              ; .initError
  37++A25F                  ; ld hl, .errMsg : call DialogBox.msgBox
  38++A25F                  ; scf
  39++A25F                  ; ret
  40++A25F              ; .errMsg db "WiFi chip init failed!",0
  41++A25F              ;.uartIniting db "Uart initing...",13,0
  42++A25F              ;uartGetID db "Get link ID...",13,0
  43++A25F              ; .chipIniting db "Chip initing...",13,0
  44++A25F              ; .doneInit    db "Done!",0
  45++A25F                  ; IFNDEF PROXY
  46++A25F              ; ; HL - host pointer in gopher row
  47++A25F              ; ; DE - port pointer in gopher row
  48++A25F              openTCP:
  49++A25F              	;ld a,(link_id)
  50++A25F              	OS_ESP_CLOSE ;если уже пытались раньше, то закрыть
  50++A25F 0E 0C       >    ld c,#0c
  50++A261 E7          >    rst #20
  51++A262
  52++A262 06 FA        	ld b,wait_count ; пробуем открыть
  53++A264              openTCP_wait1
  54++A264              	OS_WAIT
  54++A264 DF          >	rst #18
  55++A265 C5           	push bc
  56++A266 AF           	xor a ;TCP
  57++A267              	OS_ESP_OPEN
  57++A267 0E 0D       >    ld c,#0d
  57++A269 E7          >    rst #20
  58++A26A C1           	pop bc
  59++A26B 30 03        	jr nc,openTCP_wait1_ok
  60++A26D 10 F5        	djnz openTCP_wait1
  61++A26F C9           	ret ;не удалось, наверное очередь
  62++A270              openTCP_wait1_ok
  63++A270
  64++A270              	;или подождём открытия
  65++A270 06 FA        	ld b,wait_count ;
  66++A272              openTCP_wait
  67++A272              	OS_WAIT
  67++A272 DF          >	rst #18
  68++A273 DD 7E 02     	ld a,(ix+2) ;флаг
  69++A276 07           	rlca
  70++A277 D8           	ret c ;если ошибка (=255)
  71++A278 B7           	or a
  72++A279 20 04        	jr nz,openTCP_wait_skip
  73++A27B 10 F5        	djnz openTCP_wait
  74++A27D 37           	scf
  75++A27E C9           	ret
  76++A27F              openTCP_wait_skip
  77++A27F DD 7E 02     	ld a,(ix+2) ;флаг
  78++A282 EE 01        	xor 1
  79++A284 32 5E A2     	ld (closed), a
  80++A287 B7           	or a ;успешно
  81++A288 C9           	ret
  82++A289
  83++A289
  84++A289
  85++A289                  ; push de
  86++A289                  ; push hl
  87++A289                  ; EspCmdOkErr "AT+CIPCLOSE" ; Don't care about result. Just close if it didn't happens before
  88++A289                  ; EspSend 'AT+CIPSTART="TCP","'
  89++A289                  ; pop hl
  90++A289                  ; call espSendT
  91++A289                  ; EspSend '",'
  92++A289                  ; pop hl
  93++A289                  ; call espSendT
  94++A289                  ; ld a, 13 : call Uart.write
  95++A289                  ; ld a, 10 : call Uart.write
  96++A289                  ; xor a : ld (closed), a
  97++A289                  ; jp checkOkErr
  98++A289
  99++A289              ; continue:
 100++A289                  ; ret
 101++A289                  ; ENDIF
 102++A289
 103++A289
 104++A289
 105++A289              ; checkOkErr:
 106++A289                  ; call Uart.read
 107++A289                  ; cp 'O' : jr z, .okStart ; OK
 108++A289                  ; cp 'E' : jr z, .errStart ; ERROR
 109++A289                  ; cp 'F' : jr z, .failStart ; FAIL
 110++A289                  ; jr checkOkErr
 111++A289              ; .okStart
 112++A289                  ; call Uart.read : cp 'K' : jr nz, checkOkErr
 113++A289                  ; call Uart.read : cp 13  : jr nz, checkOkErr
 114++A289                  ; call .flushToLF
 115++A289                  ; or a
 116++A289                  ; ret
 117++A289              ; .errStart
 118++A289                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 119++A289                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 120++A289                  ; call Uart.read : cp 'O' : jr nz, checkOkErr
 121++A289                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 122++A289                  ; call .flushToLF
 123++A289                  ; scf
 124++A289                  ; ret
 125++A289              ; .failStart
 126++A289                  ; call Uart.read : cp 'A' : jr nz, checkOkErr
 127++A289                  ; call Uart.read : cp 'I' : jr nz, checkOkErr
 128++A289                  ; call Uart.read : cp 'L' : jr nz, checkOkErr
 129++A289                  ; call .flushToLF
 130++A289                  ; scf
 131++A289                  ; ret
 132++A289              ; .flushToLF
 133++A289                  ; call Uart.read
 134++A289                  ; cp 10 : jr nz, .flushToLF
 135++A289                  ; ret
 136++A289
 137++A289              ; ; Send buffer to UART
 138++A289              ; ; HL - buff
 139++A289              ; ; E - count
 140++A289              ; espSend:
 141++A289                  ; ld a, (hl) : call Uart.write
 142++A289                  ; inc hl
 143++A289                  ; dec e
 144++A289                  ; jr nz, espSend
 145++A289                  ; ret
 146++A289
 147++A289              ; ; HL - string that ends with one of the terminator(CR/LF/TAB/NULL)
 148++A289              ; espSendT:
 149++A289                  ; ld a, (hl)
 150++A289
 151++A289                  ; and a : ret z
 152++A289                  ; cp 9 : ret z
 153++A289                  ; cp 13 : ret z
 154++A289                  ; cp 10 : ret z
 155++A289
 156++A289                  ; call Uart.write
 157++A289                  ; inc hl
 158++A289                  ; jr espSendT
 159++A289
 160++A289              ; ; HL - stringZ to send
 161++A289              ; ; Adds CR LF
 162++A289              tcpSendZ:
 163++A289 E5           	push hl
 164++A28A EB           	ex de,hl
 165++A28B CD 50 A2     	call strLen ;узнать длину
 166++A28E EB           	ex de,hl
 167++A28F E1           	pop hl ;буфер
 168++A290 E5           	push hl
 169++A291 19           	add hl,de ;добавить в конце 13 и 10
 170++A292 36 0D        	ld (hl),13
 171++A294 23           	inc hl
 172++A295 36 0A        	ld (hl),10
 173++A297 E1           	pop hl
 174++A298 13           	inc de ;увеличить длину
 175++A299 13           	inc de
 176++A29A
 177++A29A              	;call Wifi.tcpSendZ ;послать запрос
 178++A29A              	;ld a,(link_id)
 179++A29A              	OS_ESP_SEND
 179++A29A 0E 0E       >    ld c,#0e
 179++A29C E7          >    rst #20
 180++A29D              	;ret c ;сразу не удалось (может, очередь)
 181++A29D              	;ждём когда запрос пройдёт
 182++A29D              	;ld b,wait_count ;
 183++A29D              tcpSendZ_wait1 ;бесконечно ждём
 184++A29D              	OS_WAIT
 184++A29D DF          >	rst #18
 185++A29E DD 7E 04     	ld a,(ix+4) ;флаг
 186++A2A1 FE 01        	cp 1
 187++A2A3 20 F8        	jr nz,tcpSendZ_wait1
 188++A2A5 B7           	or a
 189++A2A6 C9           	ret
 190++A2A7
 191++A2A7
 192++A2A7                  ; push hl
 193++A2A7                  ; EspSend "AT+CIPSEND="
 194++A2A7                  ; pop de : push de
 195++A2A7                  ; call strLen
 196++A2A7                  ; inc hl : inc hl ; +CRLF
 197++A2A7                  ; call hlToNumEsp
 198++A2A7                  ; ld a, 13 : call Uart.write
 199++A2A7                  ; ld a, 10 : call Uart.write
 200++A2A7                  ; call checkOkErr : ret c
 201++A2A7              ; .wait
 202++A2A7                  ; call Uart.read : cp '>' : jr nz, .wait
 203++A2A7                  ; pop hl
 204++A2A7              ; .loop
 205++A2A7                  ; ld a, (hl) : and a : jr z, .exit
 206++A2A7                  ; call Uart.write
 207++A2A7                  ; inc hl
 208++A2A7                  ; jp .loop
 209++A2A7              ; .exit
 210++A2A7                  ; ld a, 13 : call Uart.write
 211++A2A7                  ; ld a, 10 : call Uart.write
 212++A2A7                  ; jp checkOkErr
 213++A2A7
 214++A2A7              ;вх: hl - адрес буфера
 215++A2A7              getPacket:
 216++A2A7              	;переделано под ОС
 217++A2A7 7C           	ld a,h
 218++A2A8 FE FA        	cp buffer_top ;ограничение буфера
 219++A2AA 38 10        	jr c,getPacket_skip_over ; ниже ограничения грузим
 220++A2AC 3E 01        	ld a,1 ;или прекращаем
 221++A2AE 32 5E A2     	ld (closed),a ;флаг закрытия
 222++A2B1 21 00 00     	ld hl,0
 223++A2B4 22 5A A2     	ld (bytes_avail), hl
 224++A2B7              	OS_ESP_CLOSE ;освободить очередь
 224++A2B7 0E 0C       >    ld c,#0c
 224++A2B9 E7          >    rst #20
 225++A2BA 37           	scf
 226++A2BB C9           	ret
 227++A2BC              getPacket_skip_over
 228++A2BC
 229++A2BC              	;ld a,(link_id)
 230++A2BC              	OS_ESP_GET
 230++A2BC 0E 0F       >    ld c,#0f
 230++A2BE E7          >    rst #20
 231++A2BF              	; ret c ;сразу не удалось (может, очередь)
 232++A2BF              	; ld b,wait_count ;
 233++A2BF              getPacket_wait1
 234++A2BF              	OS_WAIT
 234++A2BF DF          >	rst #18
 235++A2C0 DD 7E 06     	ld a,(ix+6) ;флаг результат приёма
 236++A2C3              	; rlca
 237++A2C3              	; ret c ;если ошибка (=255)
 238++A2C3 FE 01        	cp 1
 239++A2C5 20 F8        	jr nz,getPacket_wait1
 240++A2C7
 241++A2C7
 242++A2C7              ;getPacket_wait1_skip
 243++A2C7 2A 5C A2     	ld hl,(buffer_pointer)
 244++A2CA DD 4E 09     	ld c,(ix+9) ; длина принятого
 245++A2CD DD 46 0A     	ld b,(ix+10)
 246++A2D0 ED 43 5A A2  	ld (bytes_avail), bc
 247++A2D4 09           	add hl,bc
 248++A2D5 22 5C A2     	ld (buffer_pointer),hl ;продолжить загружать с этого места
 249++A2D8
 250++A2D8 DD 7E 02     	ld a,(ix+2) ;!!! closed
 251++A2DB EE 01        	xor 1
 252++A2DD 32 5E A2     	ld (closed),a ;флаг закрытия
 253++A2E0 28 03        	jr z,getPacket_ex
 254++A2E2              	OS_ESP_CLOSE ;освободить очередь
 254++A2E2 0E 0C       >    ld c,#0c
 254++A2E4 E7          >    rst #20
 255++A2E5              getPacket_ex
 256++A2E5 B7           	or a
 257++A2E6 C9           	ret
 258++A2E7
 259++A2E7
 260++A2E7                  ; call Uart.read
 261++A2E7                  ; cp '+' : jr z, .ipdBegun    ; "+IPD," packet
 262++A2E7                  ; cp 'O' : jr z, .closedBegun ; It enough to check "OSED\n" :-)
 263++A2E7                  ; jr getPacket
 264++A2E7              ; .closedBegun
 265++A2E7                  ; call Uart.read : cp 'S' : jr nz, getPacket
 266++A2E7                  ; call Uart.read : cp 'E' : jr nz, getPacket
 267++A2E7                  ; call Uart.read : cp 'D' : jr nz, getPacket
 268++A2E7                  ; call Uart.read : cp 13 : jr nz, getPacket
 269++A2E7                  ; ld a, 1, (closed), a
 270++A2E7                  ; ret
 271++A2E7              ; .ipdBegun
 272++A2E7                  ; call Uart.read : cp 'I' : jr nz, getPacket
 273++A2E7                  ; call Uart.read : cp 'P' : jr nz, getPacket
 274++A2E7                  ; call Uart.read : cp 'D' : jr nz, getPacket
 275++A2E7                  ; call Uart.read ; Comma
 276++A2E7                  ; call .count_ipd_lenght : ld (bytes_avail), hl
 277++A2E7                  ; ld bc, hl
 278++A2E7                  ; ld hl, (buffer_pointer)
 279++A2E7              ; .readp
 280++A2E7                  ; ld a, h : cp #ff : jr nc, .skipbuff
 281++A2E7                  ; push bc, hl
 282++A2E7                  ; call Uart.read
 283++A2E7                  ; pop hl, bc
 284++A2E7                  ; ld (hl), a
 285++A2E7                  ; dec bc : inc hl
 286++A2E7                  ; ld a, b : or c : jr nz, .readp
 287++A2E7                  ; ld (buffer_pointer), hl
 288++A2E7                  ; ret
 289++A2E7              ; .skipbuff
 290++A2E7                  ; push bc
 291++A2E7                  ; call Uart.read
 292++A2E7                  ; pop bc
 293++A2E7                  ; dec bc : ld a, b : or c : jr nz, .skipbuff
 294++A2E7                  ; ret
 295++A2E7              ; .count_ipd_lenght
 296++A2E7              		; ld hl,0			; count lenght
 297++A2E7              ; .cil1	push  hl
 298++A2E7                      ; call Uart.read
 299++A2E7                      ; pop hl
 300++A2E7              		; cp ':' : ret z
 301++A2E7              		; sub 0x30 : ld c,l : ld b,h : add hl,hl : add hl,hl : add hl,bc : add hl,hl : ld c,a : ld b,0 : add hl,bc
 302++A2E7              		; jr .cil1
 303++A2E7
 304++A2E7              ; ; Based on: https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
 305++A2E7              ; ; HL - number
 306++A2E7              ; ; It will be written to UART
 307++A2E7              ; hlToNumEsp:
 308++A2E7              	; ld	bc,-10000
 309++A2E7              	; call	.n1
 310++A2E7              	; ld	bc,-1000
 311++A2E7              	; call	.n1
 312++A2E7              	; ld	bc,-100
 313++A2E7              	; call	.n1
 314++A2E7              	; ld	c,-10
 315++A2E7              	; call	.n1
 316++A2E7              	; ld	c,-1
 317++A2E7              ; .n1	ld	a,'0'-1
 318++A2E7              ; .n2	inc	a
 319++A2E7              	; add	hl,bc
 320++A2E7              	; jr	c, .n2
 321++A2E7              	; sbc	hl,bc
 322++A2E7                  ; push bc
 323++A2E7              	; call Uart.write
 324++A2E7                  ; pop bc
 325++A2E7                  ; ret
 326++A2E7
 327++A2E7                  ENDMODULE
# file closed: drivers/wifi.asm
  23+ A2E7                  include "proxy.asm"
# file opened: drivers/proxy.asm
   1++A2E7                  IFDEF PROXY
   2++A2E7 ~                MODULE Wifi
   3++A2E7 ~            ; Same singature as wifi.openTCP
   4++A2E7 ~            ; HL - host pointer in gopher row
   5++A2E7 ~            ; DE - port pointer in gopher row
   6++A2E7 ~            openTCP:
   7++A2E7 ~                push de
   8++A2E7 ~                push hl
   9++A2E7 ~
  10++A2E7 ~                xor a
  10++A2E7 ~              ld hl, hostBuff, de, hostBuff + 1, bc, 102, (hl), a
  10++A2E7 ~              ldir
  11++A2E7 ~
  12++A2E7 ~                EspCmdOkErr "AT+CIPCLOSE"
  13++A2E7 ~                EspCmdOkErr 'AT+CIPSTART="TCP","138.68.76.243",6912' // Replace here for yourown proxy. If you wish
  14++A2E7 ~                jr c, .error
  15++A2E7 ~                pop hl
  15++A2E7 ~              ld de, hostBuff
  16++A2E7 ~            .copyHost
  17++A2E7 ~                ld a, (hl)
  17++A2E7 ~              and a
  17++A2E7 ~              jr z, 1F
  17++A2E7 ~              and a
  17++A2E7 ~              jr z, 1F
  18++A2E7 ~                ld (de), a
  18++A2E7 ~              inc hl, de
  19++A2E7 ~                jr .copyHost
  20++A2E7 ~            1   xor a
  20++A2E7 ~              ld (de), a
  21++A2E7 ~                pop hl
  21++A2E7 ~              ld de, portBuff
  22++A2E7 ~            .copyPort
  23++A2E7 ~                ld a, (hl)
  23++A2E7 ~              and a
  23++A2E7 ~              jr z, 1F
  23++A2E7 ~              and a
  23++A2E7 ~              jr z, 1F
  24++A2E7 ~                ld (de), a
  24++A2E7 ~              inc hl, de
  25++A2E7 ~                jr .copyPort
  26++A2E7 ~            1   ld hl, hostBuff
  26++A2E7 ~              call tcpSendZ
  27++A2E7 ~                ld hl, portBuff
  27++A2E7 ~              call tcpSendZ
  28++A2E7 ~                xor a
  28++A2E7 ~              ld (closed), a
  29++A2E7 ~                ret
  30++A2E7 ~            .error
  31++A2E7 ~                pop hl
  31++A2E7 ~              pop de
  32++A2E7 ~                ret
  33++A2E7 ~
  34++A2E7 ~            continue:
  35++A2E7 ~                EspCmdOkErr "AT+CIPSEND=1"
  36++A2E7 ~                ret c
  37++A2E7 ~            .wait
  38++A2E7 ~                call Uart.read
  38++A2E7 ~              cp '>'
  38++A2E7 ~              jr nz, .wait
  39++A2E7 ~                ld a, 'c'
  39++A2E7 ~              call Uart.write
  40++A2E7 ~                jp checkOkErr
  41++A2E7 ~
  42++A2E7 ~            hostBuff ds 96
  43++A2E7 ~            portBuff ds 7
  44++A2E7 ~                ENDMODULE
  45++A2E7                  ENDIF
# file closed: drivers/proxy.asm
  24+ A2E7                  include "memory.asm"
# file opened: drivers/memory.asm
   1++A2E7                  module Memory
   2++A2E7              BANKM = #5b5c
   3++A2E7              MEM_PORT = #7ffd
   4++A2E7
   5++A2E7              init:
   6++A2E7 F3               di
   7++A2E8 FD CB 01 A6      res 4, (iy + 1)
   8++A2EC
   9++A2EC AF               xor a
   9++A2ED CD F1 A2       call setPage
  10++A2F0 C9               ret
  11++A2F1
  12++A2F1              ; a - page
  13++A2F1              setPage:
  14++A2F1 F6 18            or #18
  14++A2F3 32 5C 5B       ld (BANKM), a
  15++A2F6 01 FD 7F         ld bc, MEM_PORT
  15++A2F9 ED 79          out (c), a
  16++A2FB C9               ret
  17++A2FC
  18++A2FC                  endmodule
# file closed: drivers/memory.asm
  25+ A2FC                  include "general-sound.asm"
# file opened: drivers/general-sound.asm
   1++A2FC                  ifdef GS
   2++A2FC                  macro _WaitCommand
   3++A2FC ~            .wait
   4++A2FC ~                in a, (GeneralSound.CMD)
   5++A2FC ~                rrca
   6++A2FC ~                jr c, .wait
   7++A2FC                  endm
   8++A2FC
   9++A2FC                  macro _WaitData
  10++A2FC ~            .wait
  11++A2FC ~                in a, (GeneralSound.CMD)
  12++A2FC ~                rlca
  13++A2FC ~                jr c, .wait
  14++A2FC                  endm
  15++A2FC
  16++A2FC                  macro _SendCommand nn
  17++A2FC ~                ld a, nn
  17++A2FC ~              out (GeneralSound.CMD), a
  18++A2FC                  endm
  19++A2FC
  20++A2FC                  module GeneralSound
  21++A2FC              ;; Control ports
  22++A2FC              CMD  = 187
  23++A2FC              DATA = 179
  24++A2FC
  25++A2FC              ;; Commands
  26++A2FC              CMD_WARM_RESET      = #F3
  27++A2FC              CMD_COLD_RESET      = #F4
  28++A2FC              CMD_LOAD_MODULE     = #30
  29++A2FC              CMD_PLAY_MODULE     = #31
  30++A2FC              CMD_STOP_MODULE     = #32
  31++A2FC              CMD_CONTINUE_MODULE = #33
  32++A2FC              CMD_OPEN_STREAM     = #D1
  33++A2FC              CMD_CLOSE_STREAM    = #D2
  34++A2FC
  35++A2FC              ; A - 0 warm reset, other - cold
  36++A2FC              init:
  37++A2FC A7               and a
  37++A2FD 20 05          jr nz, .cold
  38++A2FF                  _SendCommand CMD_WARM_RESET
  38++A2FF 3E F3       >    ld a, CMD_WARM_RESET
  38++A301 D3 BB       >  out (GeneralSound.CMD), a
  39++A303 C9               ret
  40++A304              .cold
  41++A304                  _SendCommand CMD_COLD_RESET
  41++A304 3E F4       >    ld a, CMD_COLD_RESET
  41++A306 D3 BB       >  out (GeneralSound.CMD), a
  42++A308 C9               ret
  43++A309
  44++A309              ;; Initializes loading module
  45++A309              loadModule:
  46++A309                  _SendCommand CMD_LOAD_MODULE
  46++A309 3E 30       >    ld a, CMD_LOAD_MODULE
  46++A30B D3 BB       >  out (GeneralSound.CMD), a
  47++A30D                  _WaitCommand
  47++A30D             >.wait
  47++A30D DB BB       >    in a, (GeneralSound.CMD)
  47++A30F 0F          >    rrca
  47++A310 38 FB       >    jr c, .wait
  48++A312                  _SendCommand CMD_OPEN_STREAM
  48++A312 3E D1       >    ld a, CMD_OPEN_STREAM
  48++A314 D3 BB       >  out (GeneralSound.CMD), a
  49++A316                  _WaitCommand
  49++A316             >.wait
  49++A316 DB BB       >    in a, (GeneralSound.CMD)
  49++A318 0F          >    rrca
  49++A319 38 FB       >    jr c, .wait
  50++A31B C9               ret
  51++A31C
  52++A31C              ;; Use it for streaming mod file
  53++A31C              sendByte:
  54++A31C D3 B3            out (DATA), a
  55++A31E                  _WaitData
  55++A31E             >.wait
  55++A31E DB BB       >    in a, (GeneralSound.CMD)
  55++A320 07          >    rlca
  55++A321 38 FB       >    jr c, .wait
  56++A323 C9               ret
  57++A324
  58++A324              ;; Call it when module was loaded
  59++A324              finishLoadingModule:
  60++A324                  _SendCommand CMD_CLOSE_STREAM
  60++A324 3E D2       >    ld a, CMD_CLOSE_STREAM
  60++A326 D3 BB       >  out (GeneralSound.CMD), a
  61++A328                  _WaitCommand
  61++A328             >.wait
  61++A328 DB BB       >    in a, (GeneralSound.CMD)
  61++A32A 0F          >    rrca
  61++A32B 38 FB       >    jr c, .wait
  62++A32D              rewind:
  63++A32D 3E 01            ld a, 1
  63++A32F D3 B3          out (DATA), a
  64++A331                  _SendCommand CMD_PLAY_MODULE
  64++A331 3E 31       >    ld a, CMD_PLAY_MODULE
  64++A333 D3 BB       >  out (GeneralSound.CMD), a
  65++A335                  _WaitCommand
  65++A335             >.wait
  65++A335 DB BB       >    in a, (GeneralSound.CMD)
  65++A337 0F          >    rrca
  65++A338 38 FB       >    jr c, .wait
  66++A33A 3E 01 32 5E      ld a, 1, (state),a
  66++A33E A3
  67++A33F C9               ret
  68++A340
  69++A340              ;; Works like pause too
  70++A340              stopModule:
  71++A340 AF               xor a
  71++A341 32 5E A3       ld (state), a
  72++A344                  _SendCommand CMD_STOP_MODULE
  72++A344 3E 32       >    ld a, CMD_STOP_MODULE
  72++A346 D3 BB       >  out (GeneralSound.CMD), a
  73++A348 C9               ret
  74++A349
  75++A349              continueModule:
  76++A349 3E 01            ld a, 1
  76++A34B 32 5E A3       ld (state), a
  77++A34E                  _SendCommand CMD_CONTINUE_MODULE
  77++A34E 3E 33       >    ld a, CMD_CONTINUE_MODULE
  77++A350 D3 BB       >  out (GeneralSound.CMD), a
  78++A352 C9               ret
  79++A353
  80++A353              ; Pauses resumes
  81++A353              toggleModule:
  82++A353 CD A4 86         call Console.waitForKeyUp
  83++A356 3A 5E A3         ld a, (state)
  83++A359 A7             and a
  84++A35A 28 ED            jr z, continueModule
  85++A35C 18 E2            jr stopModule
  86++A35E
  87++A35E 00           state db 0
  88++A35F                  endmodule
  89++A35F
  90++A35F                  endif
# file closed: drivers/general-sound.asm
  26+ A35F
# file closed: drivers/index.asm
  29  A35F              start:
  30  A35F              	; IFDEF TRD
  31  A35F              	; align 256 ;временно
  32  A35F              	; ENDIF
  33  A35F              outputBuffer: ;equ #c000
  34  A35F                  ;di
  35  A35F                  ;xor a : ld (#5c6a), a  ; Thank you, Mario Prato, for feedback
  36  A35F                  ;ld (#5c00),a
  37  A35F                  ;ld sp, asmOrg
  38  A35F                  ;call Memory.init
  39  A35F                  ;xor a : out (#fe),a
  40  A35F                  ;ei
  41  A35F
  42  A35F                  ;ld a, 7 : call Memory.setPage
  43  A35F                  ;; Logo
  44  A35F                  ; ld hl, logo, b, Dos.FMODE_READ : call Dos.fopen
  45  A35F                  ; push af
  46  A35F                  ; ld hl, #c000, bc, 6912 : call Dos.fread
  47  A35F                  ; pop af
  48  A35F                  ; call Dos.fclose
  49  A35F
  50  A35F              	; ifdef ZSGMX
  51  A35F              	; call TextMode.disable
  52  A35F              	; endif
  53  A35F
  54  A35F                  ; ld b, 50
  55  A35F              ; 1   halt
  56  A35F                  ; djnz 1b
  57  A35F                  ;; End of logo :-)
  58  A35F
  59  A35F CD 03 80         call TextMode.init
  60  A362
  61  A362                  ; ld hl, initing : call TextMode.printZ
  62  A362                  ; IFNDEF EMU
  63  A362                  ; call Wifi.init
  64  A362                  ; ENDIF
  65  A362
  66  A362 C3 23 87         jp History.home
  67  A365
  68  A365              ;initing db "Initing Wifi...",13,0
  69  A365 64 61 74 61  logo    db  "data/logo.scr", 0
  69  A369 2F 6C 6F 67
  69  A36D 6F 2E 73 63
  69  A371 72 00
  70  A373                  display "ENDS: ", $
  71  A373                  display "Buff size", #ffff - $
  72  A373
  73  A373                  ;IFDEF ESX
  74  A373                  ;save3dos "moon.bin", asmOrg, $ - asmOrg
  75  A373                  savebin "moonr.apg", asmOrg, $ - asmOrg
  76  A373              	;ELSE
  77  A373                  ;SAVETRD "MOONR.TRD",|"moon.C",asmOrg, $ - asmOrg
  78  A373                  ;ENDIF
# file closed: main.asm
