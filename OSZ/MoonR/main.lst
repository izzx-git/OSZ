# file opened: main.asm
   1  0000                  device	zxspectrum128
   2  0000              	include "../os_defs.asm"
# file opened: ../os_defs.asm
   1+ 0000              ;Список всех вызовов (функций) ОС GMX
   2+ 0000
   3+ 0000              ;Включить в свой код (в начале файла):
   4+ 0000              	; include os_defs.asm
   5+ 0000
   6+ 0000              ;Использовать только имена функций, коды могут поменяться
   7+ 0000
   8+ 0000              ;например:
   9+ 0000              	; org PROGSTART
  10+ 0000              	; ../include os_defs.asm
  11+ 0000              	; ld hl,text
  12+ 0000              	; OS_PRINTZ ;печать	до кода 0
  13+ 0000
  14+ 0000              ;сохранность регистров не гарантируется
  15+ 0000              ;на выходе обычно (но не всегда) CY=1 = ошибка
  16+ 0000
  17+ 0000              PROGSTART equ #8000 ;адрес старта приложений
  18+ 0000
  19+ 0000
  20+ 0000              ;вывод в консоль --------------------
  21+ 0000
  22+ 0000              ;печать символа в консоль (ускоренная)
  23+ 0000              	MACRO OS_PRCHARF ;a=char
  24+ 0000 ~            	rst #10
  25+ 0000              	ENDM
  26+ 0000
  27+ 0000              ;очистить консоль
  28+ 0000              	macro OS_CLS ;clear visible area of terminal
  29+ 0000 ~                ld c,#00
  30+ 0000 ~                rst #20
  31+ 0000                  endm
  32+ 0000
  33+ 0000              ;установить позицию курсора в консоли
  34+ 0000                  macro OS_SETXY ;de=yx ;SET CURSOR POSITION
  35+ 0000 ~                ld c,#01
  36+ 0000 ~                rst #20
  37+ 0000                  endm
  38+ 0000
  39+ 0000              ;печать символа в консоль
  40+ 0000                  macro OS_PRCHAR ;a=char
  41+ 0000 ~                ld c,#02
  42+ 0000 ~                rst #20
  43+ 0000                  endm
  44+ 0000
  45+ 0000              ;заполнение строки одним символом
  46+ 0000                  macro OS_FLINE ;; H - line ; A - char
  47+ 0000 ~                ld c,#03
  48+ 0000 ~                rst #20
  49+ 0000                  endm
  50+ 0000
  51+ 0000              ;покрасить строку цветом
  52+ 0000                  macro OS_PLINE ;a - line, b - color
  53+ 0000 ~                ld c,#04
  54+ 0000 ~                rst #20
  55+ 0000                  endm
  56+ 0000
  57+ 0000
  58+ 0000                  ; macro OS_ ;
  59+ 0000                  ; ld c,#05
  60+ 0000                  ; rst #20
  61+ 0000                  ; endm
  62+ 0000
  63+ 0000              ;установить цвет текста в консоли;
  64+ 0000                  macro OS_SET_COLOR ;a = color, b = color 2 (highlight)
  65+ 0000 ~                ld c,#06
  66+ 0000 ~                rst #20
  67+ 0000                  endm
  68+ 0000
  69+ 0000                  ; macro OS_ ;
  70+ 0000                  ; ld c,#07
  71+ 0000                  ; rst #20
  72+ 0000                  ; endm
  73+ 0000
  74+ 0000                  ; macro OS_ ;
  75+ 0000                  ; ld c,#08
  76+ 0000                  ; rst #20
  77+ 0000                  ; endm
  78+ 0000
  79+ 0000
  80+ 0000
  81+ 0000              ;печать в консоль до кода 0
  82+ 0000                  macro OS_PRINTZ ;hl=text ;PRINT to 0
  83+ 0000 ~                ld c,#09
  84+ 0000 ~                rst #20
  85+ 0000                  endm
  86+ 0000
  87+ 0000              ;прочитать байт из uart порта;
  88+ 0000                  macro OS_UART_READ ; A - byte (Out: CY=1 Not Readed)
  89+ 0000 ~                ld c,#0a
  90+ 0000 ~                rst #20
  91+ 0000                  endm
  92+ 0000
  93+ 0000              ;записать байт в uart порт;
  94+ 0000                  macro OS_UART_WRITE ; A - byte (Out: CY=1 Not Writed)
  95+ 0000 ~                ld c,#0b
  96+ 0000 ~                rst #20
  97+ 0000                  endm
  98+ 0000
  99+ 0000                  ; macro OS_ ;
 100+ 0000                  ; ld c,#0c
 101+ 0000                  ; rst #20
 102+ 0000                  ; endm
 103+ 0000
 104+ 0000                  ; macro OS_ ;
 105+ 0000                  ; ld c,#0d
 106+ 0000                  ; rst #20
 107+ 0000                  ; endm
 108+ 0000
 109+ 0000                  ; macro OS_ ;
 110+ 0000                  ; ld c,#0e
 111+ 0000                  ; rst #20
 112+ 0000                  ; endm
 113+ 0000
 114+ 0000                  ; macro OS_ ;
 115+ 0000                  ; ld c,#0f
 116+ 0000                  ; rst #20
 117+ 0000                  ; endm
 118+ 0000
 119+ 0000              ;ввод с консоли ----------------------
 120+ 0000
 121+ 0000              ;получить код нажатой клавиши
 122+ 0000                  macro OS_GETCHAR ;read char from stdin (out: A=char, 255-no char)
 123+ 0000 ~                ld c,#10
 124+ 0000 ~                rst #20
 125+ 0000                  endm
 126+ 0000
 127+ 0000
 128+ 0000                  ; macro OS_ ;
 129+ 0000                  ; ld c,#11
 130+ 0000                  ; rst #20
 131+ 0000                  ; endm
 132+ 0000
 133+ 0000                  ; macro OS_ ;
 134+ 0000                  ; ld c,#12
 135+ 0000                  ; rst #20
 136+ 0000                  ; endm
 137+ 0000
 138+ 0000                  ; macro OS_ ;
 139+ 0000                  ; ld c,#13
 140+ 0000                  ; rst #20
 141+ 0000                  ; endm
 142+ 0000
 143+ 0000
 144+ 0000              ;прерывания --------------------------
 145+ 0000
 146+ 0000              ;установка адреса обработчика прерываний процесса;
 147+ 0000                  ; macro OS_SET_INTER ;(HL - address, A = 1 - On, A = 0 - Off)
 148+ 0000                  ; ld c,#14
 149+ 0000                  ; rst #20
 150+ 0000                  ; endm
 151+ 0000
 152+ 0000
 153+ 0000              ;плеер AY ----------------------------
 154+ 0000
 155+ 0000              ;инициализация плеера AY;
 156+ 0000                  macro OS_VTPL_INIT ;(HL - address music)
 157+ 0000 ~                ld c,#15
 158+ 0000 ~                rst #20
 159+ 0000                  endm
 160+ 0000
 161+ 0000              ;запустить плеер AY (система будет сама вызывать его каждое прерывание);
 162+ 0000                  macro OS_VTPL_PLAY ;()
 163+ 0000 ~                ld c,#16
 164+ 0000 ~                rst #20
 165+ 0000                  endm
 166+ 0000
 167+ 0000              ;заглушить плеер AY;
 168+ 0000                  macro OS_VTPL_MUTE ;()
 169+ 0000 ~                ld c,#17
 170+ 0000 ~                rst #20
 171+ 0000                  endm
 172+ 0000
 173+ 0000              ;получить значение переменной плеера;
 174+ 0000                  macro OS_GET_VTPL_SETUP ;(out: HL - setup address)
 175+ 0000 ~                ld c,#18
 176+ 0000 ~                rst #20
 177+ 0000                  endm
 178+ 0000
 179+ 0000
 180+ 0000              ;прочие ------------------------------
 181+ 0000
 182+ 0000
 183+ 0000              ;скопировать страницу в страницу
 184+ 0000                  macro OS_PAGE_COPY ;(A- page from, B - page to)
 185+ 0000 ~                ld c,#19
 186+ 0000 ~                rst #20
 187+ 0000                  endm
 188+ 0000
 189+ 0000              ;получить дополнительную страницу памяти;
 190+ 0000                  macro OS_GET_PAGE ;(out A - number page)
 191+ 0000 ~                ld c,#1a
 192+ 0000 ~                rst #20
 193+ 0000                  endm
 194+ 0000
 195+ 0000              ;включить страницу в слот 2 (#8000); предварительно зарезервировать страницу OS_GET_PAGE
 196+ 0000                  macro OS_SET_PAGE_SLOT2 ;(A - page number)
 197+ 0000 ~                ld c,#1b
 198+ 0000 ~                rst #20
 199+ 0000                  endm
 200+ 0000
 201+ 0000              ;включить страницу в слот 3 (#C000); предварительно зарезервировать страницу OS_GET_PAGE
 202+ 0000                  macro OS_SET_PAGE_SLOT3 ;(A - page number)
 203+ 0000 ~                ld c,#1c
 204+ 0000 ~                rst #20
 205+ 0000                  endm
 206+ 0000
 207+ 0000              ;включить экран N;
 208+ 0000                  macro OS_SET_SCR ;(A - number screen 5, 7, 39, 3a)
 209+ 0000 ~                ld c,#1d
 210+ 0000 ~                rst #20
 211+ 0000                  endm
 212+ 0000
 213+ 0000
 214+ 0000              ;получить номера страниц процесса;
 215+ 0000                  macro OS_GET_MAIN_PAGES ;(b, c - pages in slot2, 3)
 216+ 0000 ~                ld c,#1e
 217+ 0000 ~                rst #20
 218+ 0000                  endm
 219+ 0000
 220+ 0000              ;получить значение системного таймера
 221+ 0000                  macro OS_GET_TIMER ;(out: HL, DE - timer)
 222+ 0000 ~                ld c,#1F
 223+ 0000 ~                rst #20
 224+ 0000                  endm
 225+ 0000
 226+ 0000
 227+ 0000
 228+ 0000                  ; macro OS_ ;
 229+ 0000                  ; ld c,#20
 230+ 0000                  ; rst #20
 231+ 0000                  ; endm
 232+ 0000
 233+ 0000
 234+ 0000              ;дисковые операции -------------------
 235+ 0000
 236+ 0000              ;открыть файл для чтения или записи
 237+ 0000                  macro OS_FOPENRW ;HL - File name (out: A - id file, bc, de - size)
 238+ 0000 ~                ld c,#21
 239+ 0000 ~                rst #20
 240+ 0000                  endm
 241+ 0000
 242+ 0000              ;создать файл
 243+ 0000                  macro OS_FOPENC ;HL - File name  (out: A - id file)
 244+ 0000 ~                ld c,#22
 245+ 0000 ~                rst #20
 246+ 0000                  endm
 247+ 0000
 248+ 0000              ;прочитать из файла
 249+ 0000                  macro OS_FREAD ;HL - address, A - id file, DE - length (out: bc - size readed)
 250+ 0000 ~                ld c,#23
 251+ 0000 ~                rst #20
 252+ 0000                  endm
 253+ 0000
 254+ 0000              ;записать в файл
 255+ 0000                  macro OS_FWRITE ;HL - address, A - id file, DE - length (out: bc - size writed)
 256+ 0000 ~                ld c,#24
 257+ 0000 ~                rst #20
 258+ 0000                  endm
 259+ 0000
 260+ 0000              ;закрыть файл
 261+ 0000                  macro OS_FCLOSE ;A - id file
 262+ 0000 ~                ld c,#25
 263+ 0000 ~                rst #20
 264+ 0000                  endm
 265+ 0000
 266+ 0000                  ; macro OS_ ;
 267+ 0000                  ; ld c,#26
 268+ 0000                  ; rst #20
 269+ 0000                  ; endm
 270+ 0000
 271+ 0000                  ; macro OS_ ;
 272+ 0000                  ; ld c,#27
 273+ 0000                  ; rst #20
 274+ 0000                  ; endm
 275+ 0000
 276+ 0000                  ; macro OS_ ;
 277+ 0000                  ; ld c,#28
 278+ 0000                  ; rst #20
 279+ 0000                  ; endm
 280+ 0000
 281+ 0000                  ; macro OS_ ;
 282+ 0000                  ; ld c,#29
 283+ 0000                  ; rst #20
 284+ 0000                  ; endm
 285+ 0000
 286+ 0000
# file closed: ../os_defs.asm
   3  0000                  org PROGSTART
   4  8000              asmOrg:
   5  8000 C3 F1 A5         jp start
   6  8003
   7  8003              ; Generate version string
   8  8003                  LUA ALLPASS
   9  8003 ~                v = tostring(sj.get_define("V"))
  10  8003 ~                maj = string.sub(v, 1,1)
  11  8003 ~                min = string.sub(v, 2,2)
  12  8003 ~                sj.insert_define("VERSION_STRING", "\"" .. maj .. "." .. min .. "\"")
  13  8003                  ENDLUA
  14  8003
  15  8003                  include "vdp/index.asm"
# file opened: vdp/index.asm
   1+ 8003                  IFDEF TIMEX
   2+ 8003 ~                include "timex.asm"
   3+ 8003                  ENDIF
   4+ 8003
   5+ 8003                  IFDEF TIMEX80
   6+ 8003 ~                include "timex80.asm"
   7+ 8003                  ENDIF
   8+ 8003
   9+ 8003                  IFDEF ZXSCR
  10+ 8003 ~                include "zx.asm"
  11+ 8003                  ENDIF
  12+ 8003
  13+ 8003                  IFDEF ZSGMX
  14+ 8003                  include "zsgmx.asm"
# file opened: vdp/zsgmx.asm
   1++8003              COLOR=1
   2++8003              ;; ZS GMX screen driver (izzx)
   3++8003              	;define LINE_LIMIT 80
   4++8003                  module TextMode
   5++8003              init:
   6++8003                  ; ld hl, font_file, b, Dos.FMODE_READ
   7++8003                  ; call Dos.fopen
   8++8003                  ; push af
   9++8003                  ; ld bc, 2048, hl, font
  10++8003                  ; call Dos.fread
  11++8003                  ; pop af
  12++8003                  ; call Dos.fclose
  13++8003              	; xor a : out (#fe), a
  14++8003              	; call cls
  15++8003              	; ret
  16++8003              cls:
  17++8003              	OS_CLS
  17++8003 0E 00       >    ld c,#00
  17++8005 E7          >    rst #20
  18++8006 C9           	ret
  19++8007                  ; ld de, 0 : call gotoXY
  20++8007                  ; ;ld a, 7 : call Memory.setPage
  21++8007              	; ld a,#3b
  22++8007              	; call PageSlot3 ;включить страницу пикселей
  23++8007                  ; xor a : out (#fe), a
  24++8007                  ; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  25++8007              	; ld a,#7b
  26++8007              	; call PageSlot3 ;включить страницу атрибутов
  27++8007              	; ld a,(attr_screen) ;цвет
  28++8007              	; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  29++8007              	; call gmxscron ;включить расширенный экран
  30++8007              	; xor a
  31++8007              	; jp PageSlot3 ;вернуть страницу 0
  32++8007                  ;jp Memory.setPage
  33++8007
  34++8007
  35++8007              ; Set console coordinates
  36++8007              ; d = row(0..23), e = column (0..79)
  37++8007              gotoXY:
  38++8007              	OS_SETXY
  38++8007 0E 01       >    ld c,#01
  38++8009 E7          >    rst #20
  39++800A              	;rr e
  40++800A              	; ld a, 0
  41++800A              	; ld (half_tile_screen), a
  42++800A                  ;ld (col_screen), de
  43++800A C9               ret
  44++800B
  45++800B              disable:
  46++800B                  ; Nothing to disable
  47++800B              	;call gmxscroff ;выключить расширенный экран
  48++800B C9               ret
  49++800C
  50++800C              ; H - line
  51++800C              ; A - char
  52++800C              fillLine: ;заполнение строки одним символом
  53++800C              	OS_FLINE
  53++800C 0E 03       >    ld c,#03
  53++800E E7          >    rst #20
  54++800F C9           	ret
  55++8010                  ; push af
  56++8010                  ; ld d, h, e, 0 : call gotoXY
  57++8010                  ; pop af
  58++8010                  ; ld hl, fill_buff, de, fill_buff + 1, bc, 80-1, (hl), a : ldir
  59++8010                  ; ld hl, fill_buff : jp printZ
  60++8010
  61++8010              usualLine: ;на входе в A номер строки, которую надо покрасить обычным цветом
  62++8010 06 07        	ld b,#07 ;цвет
  63++8012              	OS_PLINE
  63++8012 0E 04       >    ld c,#04
  63++8014 E7          >    rst #20
  64++8015 C9           	ret
  65++8016                  ; ld b, a
  66++8016                  ; ld c, 0
  67++8016                  ; call bc_to_attr
  68++8016                  ; ;ld a, 7 : call Memory.setPage
  69++8016              	; push hl
  70++8016              	; ld a,#7b ;атрибуты
  71++8016              	; call PageSlot3
  72++8016              	; pop hl
  73++8016              	; ld a,(attr_screen) ;цвет
  74++8016                  ; ld (hl), a
  75++8016                  ; ld de, hl
  76++8016                  ; inc de
  77++8016                  ; ld bc, (80*8)-1
  78++8016                  ; ldir
  79++8016                  ; xor a : ;jp Memory.setPage
  80++8016              	; jp PageSlot3 ;вернуть страницу 0
  81++8016
  82++8016              highlightLine: ;на входе в A номер строки, которую надо покрасить другим цветом
  83++8016 06 0C        	ld b,#0c ;цвет
  84++8018              	OS_PLINE
  84++8018 0E 04       >    ld c,#04
  84++801A E7          >    rst #20
  85++801B C9           	ret
  86++801C                  ; ld b, a
  87++801C                  ; ld c, 0
  88++801C                  ; call bc_to_attr
  89++801C                  ; ;ld a, 7 : call Memory.setPage
  90++801C              	; push hl
  91++801C              	; ld a,#7b ;атрибуты
  92++801C              	; call PageSlot3
  93++801C              	; pop hl
  94++801C              	; ld a,(attr_screen2) ;цвет
  95++801C                  ; ld (hl), a
  96++801C                  ; ld de, hl
  97++801C                  ; inc de
  98++801C                  ; ld bc, (80*8)-1
  99++801C                  ; ldir
 100++801C                  ; xor a : ;jp Memory.setPage
 101++801C              	; jp PageSlot3 ;вернуть страницу 0
 102++801C
 103++801C              ; mvCR ;каретка вниз
 104++801C              	; ld de, (col_screen)
 105++801C              	; inc d
 106++801C              	; ld e, 0
 107++801C              	; ; ld a, 0
 108++801C              	; ; ld (half_tile_screen), a
 109++801C              	; jp gotoXY
 110++801C
 111++801C              ; Print just one symbol
 112++801C              ; A - symbol
 113++801C              putC
 114++801C              	OS_PRCHARF
 114++801C D7          >	rst #10
 115++801D C9           	ret
 116++801E                  ; cp 13 : jp z, mvCR
 117++801E
 118++801E              	; ld hl, single_symbol
 119++801E              	; ld (hl), a
 120++801E              	; ;ld a, 7 : call Memory.setPage
 121++801E              	; ld a,#3b ;пиксели
 122++801E              	; call PageSlot3
 123++801E                  ; ld hl, single_symbol_print
 124++801E                  ; call printL
 125++801E                  ; xor a : ;jp Memory.setPage
 126++801E              	; jp PageSlot3 ;вернуть страницу 0
 127++801E
 128++801E              ; Put string
 129++801E              ; hl - string pointer that's begins from symbol count
 130++801E              printZ
 131++801E              	OS_PRINTZ
 131++801E 0E 09       >    ld c,#09
 131++8020 E7          >    rst #20
 132++8021 C9           	ret
 133++8022                  ; ld a, (hl) : and a : ret z
 134++8022                  ; push hl
 135++8022                  ; call putC
 136++8022                  ; pop hl
 137++8022                  ; inc hl
 138++8022                  ; jr printZ
 139++8022
 140++8022              ; printL
 141++8022                      ; ld	a, (hl)
 142++8022              		; and	a
 143++8022              		; ret	z
 144++8022
 145++8022              		; ; push	hl
 146++8022              		; ; call	calc_addr_scr
 147++8022              		; ; ld	a,(attr_screen)
 148++8022              		; ; ;ld	(hl),a ;покрасить символ
 149++8022              		; ; pop	hl
 150++8022
 151++8022              		; ;call	calc_addr_scr
 152++8022
 153++8022              		; ; ld	a,(half_tile_screen)
 154++8022              		; ; bit	0,a
 155++8022              		; ; ld	a,(hl)
 156++8022              		; ; jp	nz,print64_4
 157++8022              ; ;print80_3
 158++8022                      ; push    af
 159++8022              		; push	hl
 160++8022              		; ; ld a,#7b ;атрибуты
 161++8022              		; ; call PageSlot3
 162++8022              		; call	calc_addr_scr
 163++8022              		; ; ld	a,(attr_screen)
 164++8022              		; ; ld	(hl),a ;покрасить символ
 165++8022              		; ld d,h ;координаты экрана в DE
 166++8022              		; ld e,l
 167++8022              		; ; ld a,#3b ;пиксели
 168++8022              		; ; call PageSlot3
 169++8022              		; pop	hl
 170++8022
 171++8022                      ; inc     hl
 172++8022                      ; push    hl
 173++8022
 174++8022                      ; ld      a,(hl)
 175++8022              		; ld	l,a
 176++8022              		; ld	h,0
 177++8022              		; add	hl,hl
 178++8022              		; add	hl,hl
 179++8022              		; add	hl,hl
 180++8022                      ; ld      bc,font
 181++8022                      ; add     hl,bc
 182++8022
 183++8022                      ; ;push    de
 184++8022
 185++8022                      ; ld      b,8
 186++8022              		; ; xor	a
 187++8022              		; ; ld	(de),a
 188++8022              ; print80_1
 189++8022              	; ;inc     d
 190++8022
 191++8022              	; ld      a,(hl)
 192++8022              	; ;and	#f0
 193++8022              	; ld      (de),a
 194++8022              	; inc     hl
 195++8022
 196++8022              	; push hl ;на строку пикселей вниз
 197++8022              	; ld hl,80
 198++8022              	; add hl,de
 199++8022              	; ex de,hl
 200++8022              	; pop hl
 201++8022
 202++8022              	; djnz    print80_1
 203++8022
 204++8022              	; ;inc	d
 205++8022              	; ; push hl
 206++8022              	; ; ld hl,80
 207++8022              	; ; add hl,de
 208++8022              	; ; ex de,hl
 209++8022              	; ; pop hl
 210++8022
 211++8022              	; ; xor	a
 212++8022              	; ; ld	(de),a
 213++8022
 214++8022              	; ; ld	a,1
 215++8022              	; ; ld	(half_tile_screen),a
 216++8022
 217++8022              	; ;pop     de
 218++8022              	; pop     hl
 219++8022              	; pop     af
 220++8022
 221++8022              	; ;dec     a
 222++8022              	; ; ret     ;z
 223++8022
 224++8022              ; ; print64_4
 225++8022              	; ; push    af
 226++8022
 227++8022              	; ; inc     hl
 228++8022              	; ; push    hl
 229++8022
 230++8022              	; ; ld      a,(hl)
 231++8022              	; ; ld	l,a
 232++8022              	; ; ld	h,0
 233++8022              	; ; add	hl,hl
 234++8022              	; ; add	hl,hl
 235++8022              	; ; add	hl,hl
 236++8022              	; ; ld      bc,font
 237++8022              	; ; add     hl,bc
 238++8022
 239++8022              	; ; push    de
 240++8022
 241++8022              	; ; ld      b,6
 242++8022              	; ; xor	a
 243++8022              	; ; ld	(de),a
 244++8022              ; ; print64_2
 245++8022              	; ; ;inc     d
 246++8022              	; ; push hl
 247++8022              	; ; ld hl,80
 248++8022              	; ; add hl,de
 249++8022              	; ; ex de,hl
 250++8022              	; ; pop hl
 251++8022              	; ; ld      a,(hl)
 252++8022              	; ; ;and     #0f
 253++8022              	; ; ld      c,a
 254++8022              	; ; ld      a,(de)
 255++8022              	; ; or      c
 256++8022              	; ; ld      (de),a
 257++8022              	; ; inc     hl
 258++8022              	; ; djnz    print64_2
 259++8022
 260++8022              	; ; ;inc	d
 261++8022              	; ; push hl
 262++8022              	; ; ld hl,80
 263++8022              	; ; add hl,de
 264++8022              	; ; ex de,hl
 265++8022              	; ; pop hl
 266++8022              	; ; xor	a
 267++8022              	; ; ld	(de),a
 268++8022
 269++8022              	; ; ld	(half_tile_screen),a
 270++8022
 271++8022              	; ; pop     de
 272++8022
 273++8022              	; ; call	move_cr64
 274++8022
 275++8022              	; ; pop     hl
 276++8022              	; ; pop     af
 277++8022              	; ; dec     a
 278++8022
 279++8022              	; ; jp      nz,print64_3
 280++8022
 281++8022              	; ; ret
 282++8022
 283++8022              ; ; move cursor на одну позицию вперёд
 284++8022              ; move_cr80
 285++8022              	; ;inc	de
 286++8022
 287++8022              	; ld	hl,col_screen
 288++8022              	; inc	(hl) ;увеличить столбец
 289++8022              	; ld	a,(hl)
 290++8022
 291++8022              	; cp	80
 292++8022              	; ret	c
 293++8022
 294++8022              	; xor	a
 295++8022              	; ;ld	(half_tile_screen),a
 296++8022              	; ld	(hl),a
 297++8022              	; ld	c,a
 298++8022
 299++8022              	; inc	hl ;на переменную row
 300++8022              	; inc	(hl)
 301++8022              	; ld	a,(hl)
 302++8022              	; ld	b,a
 303++8022
 304++8022              	; cp	24
 305++8022              	; jp	c,move_cr80_01
 306++8022
 307++8022              	; ld	a,23
 308++8022              	; ld	(hl),a
 309++8022              	; ld	b,a
 310++8022
 311++8022              	; ; push	bc
 312++8022              	; ; call	scroll_up8
 313++8022              	; ; pop	bc
 314++8022
 315++8022              ; move_cr80_01
 316++8022              	; ; call	calc_addr_scr
 317++8022              	; ; ret
 318++8022
 319++8022              ; calc_addr_scr	;определение адреса экрана по координатам символа
 320++8022              	; ld	bc,(col_screen)
 321++8022              ; bc_to_attr:
 322++8022              	; ld h,0
 323++8022              	; ld l,b ;строка
 324++8022              	; add hl,hl ;*2
 325++8022              	; ld de,table_addr_scr
 326++8022              	; add hl,de
 327++8022              	; ld e,(hl)
 328++8022              	; inc hl
 329++8022              	; ld d,(hl) ;узнали координаты строки
 330++8022              	; ld h,0
 331++8022              	; ld l,c ;колонка
 332++8022              	; add hl,de ;узнали адрес символа
 333++8022              	; ; ld      a,b
 334++8022              	; ; ld      d,a
 335++8022              	; ; rrca
 336++8022              	; ; rrca
 337++8022              	; ; rrca
 338++8022              	; ; and     a,224
 339++8022              	; ; add     a,c
 340++8022              	; ; ld      e,a
 341++8022              	; ; ld      a,d
 342++8022              	; ; and     24
 343++8022              	; ; or      #c0
 344++8022              	; ; ld      d,a
 345++8022              	; ret
 346++8022
 347++8022              ; ; calc_addr_attr
 348++8022              	; ; ld	bc,(col_screen)
 349++8022              ; ; bc_to_attr:
 350++8022              	; ; ld	a,b
 351++8022              	; ; rrca
 352++8022              	; ; rrca
 353++8022              	; ; rrca
 354++8022              	; ; ld	l,a
 355++8022              	; ; and	31
 356++8022              	; ; or	#d8
 357++8022              	; ; ld	h,a
 358++8022              	; ; ld	a,l
 359++8022              	; ; and	252
 360++8022              	; ; or	c
 361++8022              	; ; ld	l,a
 362++8022              	; ; ret
 363++8022
 364++8022              ; ; scroll_up8	;
 365++8022              	; ; ld	hl,table_addr_scr
 366++8022              	; ; ld	b,184
 367++8022
 368++8022              ; ; scroll_up8_01
 369++8022              	; ; push	bc
 370++8022
 371++8022              	; ; ld	e,(hl)
 372++8022              	; ; inc	hl
 373++8022              	; ; ld	d,(hl)
 374++8022              	; ; inc	hl
 375++8022
 376++8022              	; ; push	hl
 377++8022
 378++8022              	; ; ld	bc,14
 379++8022              	; ; add	hl,bc
 380++8022              	; ; ld	c,(hl)
 381++8022              	; ; inc	hl
 382++8022              	; ; ld	b,(hl)
 383++8022
 384++8022              	; ; ld	h,b
 385++8022              	; ; ld	l,c
 386++8022
 387++8022              	; ; ld	bc,32
 388++8022              	; ; ldir
 389++8022
 390++8022              	; ; pop	hl
 391++8022              	; ; pop	bc
 392++8022              	; ; djnz	scroll_up8_01
 393++8022
 394++8022              	; ; ld	b,8
 395++8022
 396++8022              ; ; scroll_up8_02
 397++8022              	; ; push	bc
 398++8022
 399++8022              	; ; ld	e,(hl)
 400++8022              	; ; inc	hl
 401++8022              	; ; ld	d,(hl)
 402++8022              	; ; inc	hl
 403++8022
 404++8022              	; ; push	hl
 405++8022
 406++8022              	; ; ld	h,d
 407++8022              	; ; ld	l,e
 408++8022              	; ; inc	de
 409++8022              	; ; ld	(hl),0
 410++8022              	; ; ld	bc,31
 411++8022              	; ; ldir
 412++8022
 413++8022              	; ; pop	hl
 414++8022              	; ; pop	bc
 415++8022              	; ; djnz	scroll_up8_02
 416++8022              	; ; ld	de,#D800, hl,#D820, bc,736
 417++8022              	; ; ldir
 418++8022              	; ; ld	a,(de)
 419++8022              	; ; ld	hl,#dae0, de,#dae1, (hl),a, bc,31
 420++8022              	; ; ldir
 421++8022
 422++8022              	; ; ret
 423++8022
 424++8022
 425++8022              ; gmxscron
 426++8022                          ; ld      bc,#7efd
 427++8022                          ; ld      a,#c8
 428++8022                          ; out     (c),a
 429++8022                          ; ; ld      bc,#7ffd
 430++8022                          ; ; ld      a,#10    ;5 screen
 431++8022                          ; ; out     (c),a
 432++8022                          ; ret
 433++8022
 434++8022              ; ; gmxscron2
 435++8022                          ; ; ld      bc,#7efd
 436++8022                          ; ; ld      a,#c8
 437++8022                          ; ; out     (c),a
 438++8022                          ; ; ld      bc,#7ffd
 439++8022                          ; ; ld      a,#18    ;7 screen
 440++8022                          ; ; out     (c),a
 441++8022                          ; ; ret
 442++8022
 443++8022              ; gmxscroff
 444++8022                          ; ld      bc,#7efd
 445++8022                          ; ld      a,#c0
 446++8022                          ; out     (c),a
 447++8022                          ; ; ld      bc,#7ffd
 448++8022                          ; ; ld      a,#10    ;5 screen
 449++8022                          ; ; out     (c),a
 450++8022                          ; ret
 451++8022
 452++8022
 453++8022              ; PageSlot3
 454++8022              ; ; драйвер памяти для TR-DOS Navigator
 455++8022              ; ; и Scorpion GMX 2Mb
 456++8022                       ; ; org  #5b00
 457++8022                       ; ; jr   pag_on
 458++8022                       ; ; jr   clock
 459++8022                       ; ; db   #00
 460++8022                       ; ; db   #00
 461++8022
 462++8022                       ; ;push hl
 463++8022                       ; ld   hl,table
 464++8022                       ; add  a,l
 465++8022                       ; jr   nc,PageSlot3_1
 466++8022                       ; inc  h          ;коррекция
 467++8022              ; PageSlot3_1  ld   l,a
 468++8022                       ; ld   a,(hl)
 469++8022                       ; ;pop  hl
 470++8022                       ; ;cp   #ff
 471++8022                       ; ;scf
 472++8022                       ; ;ret  z
 473++8022                       ; ;push bc
 474++8022                       ; push af
 475++8022                       ; rlca
 476++8022                       ; and  #10
 477++8022                       ; ld   bc,#1ffd
 478++8022              ; PageSlot3DOS
 479++8022              		 ; ;or #00 ; #04 тут выбор ПЗУ TRDOS
 480++8022                       ; out  (c),a
 481++8022                       ; pop  af
 482++8022                       ; push af
 483++8022                       ; and  #07
 484++8022              ; PageSlot3Scr ;тут выбор экрана и ПЗУ
 485++8022                       ; or   #18 ;#0 ;#18
 486++8022                       ; ld   b,#7f
 487++8022                       ; out  (c),a
 488++8022                       ; pop  af
 489++8022                       ; rrca
 490++8022                       ; rrca
 491++8022                       ; rrca
 492++8022                       ; rrca
 493++8022                       ; and  #07
 494++8022                       ; ld   b,#df
 495++8022                       ; out  (c),a
 496++8022                       ; ;pop  hl
 497++8022                       ; ret
 498++8022              ; ; clock    ld   d,%00100000
 499++8022                       ; ; rst  8
 500++8022                       ; ; db   #89
 501++8022                       ; ; ret
 502++8022
 503++8022                       ; ; org  #5b5c ; здесь системная переменая
 504++8022                       ; ; db   #10
 505++8022              ; ;все страницы
 506++8022              ; table    db   #00,#01,#02,#03,#04,#05,#06,#07,#08,#09
 507++8022                       ; db   #0a,#0b,#0c,#0d,#0e
 508++8022                       ; db   #0f,#10,#11,#12,#13,#14
 509++8022                       ; db   #15,#16,#17,#18,#19,#1a
 510++8022                       ; db   #1b,#1c,#1d,#1e,#1f,#20
 511++8022                       ; db   #21,#22,#23,#24,#25,#26
 512++8022                       ; db   #27,#28,#29,#2a,#2b,#2c
 513++8022                       ; db   #2d,#2e,#2f,#30,#31,#32
 514++8022                       ; db   #33,#34,#35,#36,#37,#38,#39
 515++8022                       ; db   #3a,#3b,#3c,#3d,#3e,#3f,#40
 516++8022                       ; db   #41,#42,#43,#44,#45,#46
 517++8022                       ; db   #47,#48,#49,#4a,#4b,#4c
 518++8022
 519++8022                       ; db   #4d,#4e,#4f,#50,#51,#52
 520++8022                       ; db   #53,#54,#55,#56,#57,#58
 521++8022                       ; db   #59,#5a,#5b,#5c,#5d,#5e
 522++8022                       ; db   #5f,#60,#61,#62,#63,#64
 523++8022                       ; db   #65,#66,#67,#68,#69,#6a
 524++8022                       ; db   #6b,#6c,#6d,#6e,#6f,#70
 525++8022                       ; db   #71,#72,#73,#74,#75,#76
 526++8022                       ; db   #77,#78,#79,#7a,#7b,#7c,#7d,#7e
 527++8022                       ; db   #7f
 528++8022
 529++8022                       ; db   #ff ;конец таблицы
 530++8022
 531++8022
 532++8022
 533++8022              ; font equ #4000 ; Using ZX-Spectrum screen as font buffer
 534++8022              ; font_file db "data/font.bin", 0
 535++8022
 536++8022
 537++8022              ; table_addr_scr	;адреса строк текста
 538++8022              	; defw	#c000 ;0
 539++8022              	; defw	#c280
 540++8022              	; defw	#c500
 541++8022              	; defw	#c780
 542++8022              	; defw	#ca00
 543++8022              	; defw	#cc80
 544++8022              	; defw	#cf00
 545++8022              	; defw	#d180
 546++8022
 547++8022              	; defw	#d400 ;8
 548++8022              	; defw	#d680
 549++8022              	; defw	#d900
 550++8022              	; defw	#db80
 551++8022              	; defw	#de00
 552++8022              	; defw	#e080
 553++8022              	; defw	#e300
 554++8022              	; defw	#e580
 555++8022
 556++8022              	; defw	#e800 ;16
 557++8022              	; defw	#ea80
 558++8022              	; defw	#ed00
 559++8022              	; defw	#ef80
 560++8022              	; defw	#f200
 561++8022              	; defw	#f480
 562++8022              	; defw	#f700
 563++8022              	; defw	#f980
 564++8022
 565++8022              	; defw	#fc00 ;24
 566++8022              	; defw	#fe80 ;25 вне экрана
 567++8022
 568++8022
 569++8022              ; col_screen			db	0	;столбец
 570++8022              ; row_screen			db	0	;строка
 571++8022              ; ;half_tile_screen	db	0
 572++8022              ; attr_screen			db	07	;основной цвет
 573++8022              ; attr_screen2		db	#c	;другой цвет
 574++8022
 575++8022              ; ;col_screen_temp			dw	0
 576++8022              ; ;half_tile_screen_temp	db	0
 577++8022
 578++8022              ; single_symbol_print db 1
 579++8022              ; single_symbol 		db 0
 580++8022
 581++8022              ; fill_buff ds 80+1
 582++8022
 583++8022                  endmodule
# file closed: vdp/zsgmx.asm
  15+ 8022                  ENDIF
# file closed: vdp/index.asm
  16  8022                  include "utils/index.asm"
# file opened: utils/index.asm
   1+ 8022                  include "atoi.asm"
# file opened: utils/atoi.asm
   1++8022              ; DE - buffer
   2++8022              ; HL - output
   3++8022              atohl:
   4++8022 21 00 00         ld hl, 0
   5++8025              .loop
   6++8025 1A               ld a, (de)
   7++8026 13               inc de
   8++8027                  ; Sepparators
   9++8027 C5 E5            push bc, hl
  10++8029 01 05 00             ld bc, sepparators_len
  11++802C 21 44 80             ld hl, sepparators
  12++802F ED B1                cpir
  13++8031 E1 C1            pop hl, bc
  14++8033 C8               ret z
  15++8034
  16++8034 D6 30            sub '0'
  17++8036
  18++8036 C5               push bc
  19++8037 4D                   ld c, l
  20++8038 44                   ld b, h
  21++8039
  22++8039 29                   add hl, hl
  23++803A 29                   add hl, hl
  24++803B 09                   add hl, bc
  25++803C 29                   add hl, hl
  26++803D 4F                   ld c, a
  27++803E 06 00                ld b, 0
  28++8040 09                   add hl, bc
  29++8041 C1               pop bc
  30++8042 18 E1            jr .loop
  31++8044
# file closed: utils/atoi.asm
   2+ 8044                  include "constants.asm"
# file opened: utils/constants.asm
   1++8044              TAB = 9
   2++8044              CR = 13
   3++8044              LF = 10
   4++8044              NULL = 0
   5++8044              SPACE = ' '
   6++8044              ESC = 27
   7++8044
   8++8044                  IFNDEF TIMEX80
   9++8044              MIME_DOWNLOAD = 1
  10++8044              MIME_LINK     = 2
  11++8044              MIME_TEXT     = 3
  12++8044              MIME_IMAGE    = 6
  13++8044              MIME_MUSIC    = 5
  14++8044              MIME_INPUT    = 4
  15++8044              MIME_MOD      = 7
  16++8044
  17++8044              BORDER_TOP    = 9
  18++8044              BORDER_BOTTOM = 8
  19++8044                  ELSE
  20++8044 ~            MIME_DOWNLOAD = #19
  21++8044 ~            MIME_LINK = #1A
  22++8044 ~            MIME_TEXT = #10
  23++8044 ~            MIME_IMAGE = #01
  24++8044 ~            MIME_MUSIC = #0e
  25++8044 ~            MIME_INPUT = #b3
  26++8044 ~            MIME_MOD = #0d
  27++8044 ~
  28++8044 ~            BORDER_TOP = #b2
  29++8044 ~            BORDER_BOTTOM = #b1
  30++8044 ~
  31++8044                  ENDIF
  32++8044
  33++8044 0D 0A 09 00  sepparators db CR, LF, TAB, NULL, SPACE
  33++8048 20
  34++8049              sepparators_len = $ - sepparators
# file closed: utils/constants.asm
   3+ 8049                  include "strutils.asm"
# file opened: utils/strutils.asm
   1++8049              ; de - pointer
   2++8049              ; hl - count
   3++8049              strlen:
   4++8049 21 00 00         ld hl, 0
   5++804C              .loop
   6++804C 1A               ld a, (de)
   7++804D A7               and a
   7++804E 28 04          jr z, .exit
   8++8050 23               inc hl
   9++8051 13               inc de
  10++8052 18 F8            jr .loop
  11++8054              .exit
  12++8054 C9               ret
  13++8055
  14++8055                  module CompareBuff
  15++8055
  16++8055              ; Pushes A to buffer
  17++8055              push
  18++8055 F5               push af
  19++8056 06 20            ld b, 32
  19++8058 21 A1 80       ld hl, buffer + 1
  19++805B 11 A0 80       ld de, buffer
  20++805E              .loop
  21++805E 7E               ld a, (hl)
  21++805F 12             ld (de), a
  21++8060 23             inc hl
  21++8061 13             inc de
  21++8062 10 FA          djnz .loop
  22++8064 F1               pop af
  23++8065 21 BF 80         ld hl, buffer + 31
  23++8068 77             ld (hl), a
  24++8069 C9               ret
  25++806A
  26++806A              ; HL - Compare string(null terminated)
  27++806A              ; A - 0 NOT Found
  28++806A              ;     1 Found
  29++806A              search:
  30++806A 06 00            ld b, 0
  30++806C E5             push hl
  31++806D              .loop:
  32++806D 7E               ld a, (hl)
  32++806E 23             inc hl
  32++806F 04             inc b
  32++8070 A7             and a
  32++8071 C2 6D 80       jp nz, .loop
  33++8074 05               dec b
  33++8075 E1             pop hl
  33++8076 C5             push bc
  33++8077 E5             push hl
  34++8078 E1               pop hl
  35++8079 11 C0 80         ld de, buffer + 32
  36++807C              .sourceLoop
  37++807C 1B               dec de
  37++807D 10 FD          djnz .sourceLoop
  38++807F C1               pop bc
  39++8080              .compare
  40++8080 C5               push bc
  40++8081 F5             push af
  41++8082 1A               ld a, (de)
  41++8083 47             ld b, a
  42++8084 F1               pop af
  42++8085 7E             ld a, (hl)
  42++8086 B8             cp b
  42++8087 C1             pop bc
  42++8088 3E 00          ld a, 0
  42++808A C0             ret nz
  43++808B 13               inc de
  43++808C 23             inc hl
  44++808D 10 F1            djnz .compare
  45++808F 3E 01            ld a, 1
  46++8091 C9               ret
  47++8092
  48++8092              clear:
  49++8092 AF               xor a
  49++8093 21 A0 80       ld hl, buffer
  49++8096 11 A1 80       ld de, buffer + 1
  49++8099 01 20 00       ld bc, 32
  49++809C 77             ld (hl), a
  49++809D ED B0          ldir
  50++809F C9               ret
  51++80A0
  52++80A0 00 00 00...  buffer ds 32
  53++80C0
  54++80C0                  endmodule
# file closed: utils/strutils.asm
   4+ 80C0                  include "screen.asm"
# file opened: utils/screen.asm
   1++80C0                  IFNDEF LINE_LIMIT
   2++80C0              LINE_LIMIT = 60
   3++80C0                  ENDIF
   4++80C0              ; HL - string pointer
   5++80C0              print70Text:
   6++80C0 06 3C            ld b, LINE_LIMIT
   7++80C2              .loop
   8++80C2 7E               ld a, (hl)
   9++80C3 A7               and a
   9++80C4 C8             ret z
  10++80C5 FE 0D            cp 13
  10++80C7 C8             ret z
  11++80C8 FE 0A            cp 10
  11++80CA C8             ret z
  12++80CB C5               push bc
  13++80CC E5               push hl
  14++80CD CD 1C 80         call TextMode.putC
  15++80D0 E1               pop hl
  16++80D1 23               inc hl
  17++80D2 C1               pop bc
  18++80D3 05               dec b
  19++80D4 78               ld a, b
  19++80D5 A7             and a
  19++80D6 C8             ret z
  20++80D7 C3 C2 80         jp .loop
  21++80DA
  22++80DA              ; HL - string pointer
  23++80DA              print70Goph:
  24++80DA 06 3C            ld b, LINE_LIMIT
  25++80DC              .loop
  26++80DC 7E               ld a, (hl)
  26++80DD FE 09          cp 09
  26++80DF C8             ret z
  27++80E0 A7               and a
  27++80E1 C8             ret z
  28++80E2 C5               push bc
  29++80E3 E5               push hl
  30++80E4 CD 1C 80         call TextMode.putC
  31++80E7 E1               pop hl
  32++80E8 23               inc hl
  33++80E9 C1               pop bc
  34++80EA 05               dec b
  35++80EB 78               ld a, b
  35++80EC A7             and a
  35++80ED C8             ret z
  36++80EE C3 DC 80         jp .loop
# file closed: utils/screen.asm
# file closed: utils/index.asm
  17  80F1                  include "gopher/render/index.asm"
# file opened: gopher/render/index.asm
   1+ 80F1                  MODULE Render
   2+ 80F1              PER_PAGE = 19
   3+ 80F1              CURSOR_OFFSET = 3
   4+ 80F1                  include "row.asm"
# file opened: gopher/render/row.asm
   1++80F1              ; A - row number
   2++80F1              ; HL - pointer to row
   3++80F1              renderRow:
   4++80F1 C6 03            add CURSOR_OFFSET
   5++80F3 57 1E 00         ld d, a, e, 0
   5++80F6 CD 07 80       call TextMode.gotoXY
   6++80F9 7E               ld a, (hl)
   7++80FA E5               push hl
   8++80FB CD 06 81         call getIcon
   9++80FE CD 1C 80         call TextMode.putC
  10++8101 E1               pop hl
  11++8102 23               inc hl
  12++8103 C3 DA 80         jp print70Goph
  13++8106
  14++8106              ; A - gopher id char
  15++8106              getIcon:
  16++8106 FE 69            cp 'i'
  16++8108 CA 22 81       jp z, .info
  17++810B FE 39            cp '9'
  17++810D CA 25 81       jp z, .down
  18++8110 FE 31            cp '1'
  18++8112 CA A5 81       jp z, .page
  19++8115 FE 30            cp '0'
  19++8117 CA A8 81       jp z, .text
  20++811A FE 37            cp '7'
  20++811C CA AB 81       jp z, .input
  21++811F 3E 20            ld a, ' '
  22++8121 C9               ret
  23++8122              .info
  24++8122 3E 20            ld a, SPACE
  24++8124 C9             ret
  25++8125              .down
  26++8125 54 5D            ld de, hl
  27++8127 01 FF 00 3E      ld bc, #ff, a, TAB
  27++812B 09
  27++812C ED B1          cpir
  28++812E 78               ld a, b
  28++812F B1             or c
  28++8130 28 70          jr z, .downExit
  29++8132 D5               push de
  30++8133              .nameLoop
  31++8133 7E               ld a, (hl)
  31++8134 A7             and a
  31++8135 28 10          jr z, .check
  32++8137 FE 09            cp TAB
  32++8139 28 0C          jr z, .check
  33++813B FE 0D            cp CR
  33++813D 28 08          jr z, .check
  34++813F E5               push hl
  35++8140 CD 55 80         call CompareBuff.push
  36++8143 E1               pop hl
  37++8144 23               inc hl
  38++8145 18 EC            jr .nameLoop
  39++8147              .check
  40++8147 3A E7 81     	ld a,(saveMode+1);фикс обход открытия файлов, чтобы их скачать по кнопке Caps
  41++814A B7           	or a
  42++814B 20 54        	jr nz,.checkExit
  43++814D 21 BA 81         ld hl, scrExt1
  43++8150 CD 6A 80       call CompareBuff.search
  43++8153 A7             and a
  43++8154 20 58          jr nz, .image
  44++8156 21 BF 81         ld hl, scrExt2
  44++8159 CD 6A 80       call CompareBuff.search
  44++815C A7             and a
  44++815D 20 4F          jr nz, .image
  45++815F              	OS_GET_VTPL_SETUP
  45++815F 0E 18       >    ld c,#18
  45++8161 E7          >    rst #20
  46++8162 3E 03            ld a, 3
  46++8164
  47++8164 77           	ld (hl), a ; 0 bit - looping, 1 bit - pt2 file
  48++8165 21 CE 81         ld hl, pt2Ext1
  48++8168 CD 6A 80       call CompareBuff.search
  48++816B A7             and a
  48++816C 20 44          jr nz, .music
  49++816E 21 D3 81         ld hl, pt2Ext2
  49++8171 CD 6A 80       call CompareBuff.search
  49++8174 A7             and a
  49++8175 20 3B          jr nz, .music
  50++8177              	OS_GET_VTPL_SETUP
  50++8177 0E 18       >    ld c,#18
  50++8179 E7          >    rst #20
  51++817A 3E 01            ld a, 1
  51++817C
  52++817C 77           	ld (hl), a
  53++817D 21 C4 81         ld hl, pt3Ext1
  53++8180 CD 6A 80       call CompareBuff.search
  53++8183 A7             and a
  53++8184 20 2C          jr nz, .music
  54++8186 21 C9 81         ld hl, pt3Ext2
  54++8189 CD 6A 80       call CompareBuff.search
  54++818C A7             and a
  54++818D 20 23          jr nz, .music
  55++818F
  56++818F                  ; General Sound support
  57++818F                  ifdef GS
  58++818F 21 D8 81         ld hl, modExt1
  58++8192 CD 6A 80       call CompareBuff.search
  58++8195 A7             and a
  58++8196 20 1E          jr nz, .mod
  59++8198 21 DD 81         ld hl, modExt2
  59++819B CD 6A 80       call CompareBuff.search
  59++819E A7             and a
  59++819F 20 15          jr nz, .mod
  60++81A1                  endif
  61++81A1              .checkExit
  62++81A1 E1               pop hl
  63++81A2              .downExit
  64++81A2 3E 01            ld a, MIME_DOWNLOAD
  64++81A4 C9             ret
  65++81A5              .page
  66++81A5 3E 02            ld a, MIME_LINK
  66++81A7 C9             ret
  67++81A8              .text
  68++81A8 3E 03            ld a, MIME_TEXT
  68++81AA C9             ret
  69++81AB              .input
  70++81AB 3E 04            ld a, MIME_INPUT
  70++81AD C9             ret
  71++81AE              .image
  72++81AE E1               pop hl
  72++81AF 3E 06          ld a, MIME_IMAGE
  72++81B1 C9             ret
  73++81B2              .music
  74++81B2 E1               pop hl
  74++81B3 3E 05          ld a, MIME_MUSIC
  74++81B5 C9             ret
  75++81B6              .mod
  76++81B6 E1               pop hl
  76++81B7 3E 07          ld a, MIME_MOD
  76++81B9 C9             ret
  77++81BA
  78++81BA 2E 73 63 72  scrExt1 db ".scr", 0
  78++81BE 00
  79++81BF 2E 53 43 52  scrExt2 db ".SCR", 0
  79++81C3 00
  80++81C4
  81++81C4 2E 70 74 33  pt3Ext1 db ".pt3", 0
  81++81C8 00
  82++81C9 2E 50 54 33  pt3Ext2 db ".PT3", 0
  82++81CD 00
  83++81CE 2E 70 74 32  pt2Ext1 db ".pt2", 0
  83++81D2 00
  84++81D3 2E 50 54 32  pt2Ext2 db ".PT2", 0
  84++81D7 00
  85++81D8
  86++81D8 2E 6D 6F 64  modExt1 db ".mod", 0
  86++81DC 00
  87++81DD 2E 4D 4F 44  modExt2 db ".MOD", 0
  87++81E1 00
  88++81E2
  89++81E2              toggleSaveMode
  90++81E2 F5           			push af
  91++81E3 CD A0 86     			call Console.waitForKeyUp
  92++81E6 3E 00        saveMode	ld a,0 ; Флаг Open/Save files
  93++81E8 EE 01        			xor 1
  94++81EA 32 E7 81     			ld (saveMode+1),a
  95++81ED F1           			pop af
  96++81EE C9           			ret
# file closed: gopher/render/row.asm
   5+ 81EF                  include "buffer.asm"
# file opened: gopher/render/buffer.asm
   1++81EF              ; B - line count
   2++81EF              findLine:
   3++81EF 21 F1 A5         ld hl, outputBuffer
   4++81F2              findLine2:
   5++81F2 AF               xor a
   5++81F3 B0             or b
   5++81F4 28 1D          jr z, .checkEmpty
   6++81F6              .loop
   7++81F6 7E               ld a, (hl)
   7++81F7 A7             and a
   7++81F8 28 1C          jr z, .nope
   8++81FA FE 0D            cp 13
   8++81FC 23             inc hl
   8++81FD 28 0C          jr z, .checkLF
   9++81FF FE 0A            cp 10
   9++8201 28 02          jr z, .nextCheck
  10++8203 18 F1            jr .loop
  11++8205              .nextCheck
  12++8205 A7               and a
  12++8206 28 0E          jr z, .nope
  13++8208 10 EC            djnz .loop
  14++820A C9               ret
  15++820B              .checkLF
  16++820B 7E               ld a, (hl)
  17++820C FE 0A            cp 10
  17++820E 20 F5          jr nz, .nextCheck
  18++8210 23               inc hl
  19++8211 18 F2            jr  .nextCheck
  20++8213              .checkEmpty
  21++8213 7E               ld a, (hl)
  21++8214 A7             and a
  21++8215 C0             ret nz
  22++8216              .nope
  23++8216 21 00 00         ld hl, 0
  23++8219 C9             ret
# file closed: gopher/render/buffer.asm
   6+ 821A                  include "ui.asm"
# file opened: gopher/render/ui.asm
   1++821A              prepareScreen:
   2++821A CD 03 80         call TextMode.cls
   3++821D 21 46 83         ld hl, header
   3++8220 CD 1E 80       call TextMode.printZ
   4++8223 21 4A 82         ld hl, toolbox
   4++8226 CD 1E 80       call TextMode.printZ
   5++8229 21 28 9D         ld hl, hostName
   5++822C CD 1E 80       call TextMode.printZ
   6++822F 11 00 17         ld de, #1700
   6++8232 CD 07 80       call TextMode.gotoXY
   6++8235 21 56 82       ld hl, footer
   6++8238 CD 1E 80       call TextMode.printZ
   7++823B
   8++823B AF               xor a
   8++823C CD 16 80       call TextMode.highlightLine
   9++823F 3E 01            ld a, 1
   9++8241 CD 16 80       call TextMode.highlightLine
  10++8244 3E 17            ld a, #17
  10++8246 CD 16 80       call TextMode.highlightLine
  11++8249 C9               ret
  12++824A
  13++824A
  14++824A 20 5B 44 5D  toolbox db " [D]omain: ", 0
  14++824E 6F 6D 61 69
  14++8252 6E 3A 20 00
  15++8256 20 20 43 75  footer db "  Cursor - movement  [B]ack to prev. page  [H]ome page", 0
  15++825A 72 73 6F 72
  15++825E 20 2D 20 6D
  15++8262 6F 76 65 6D
  15++8266 65 6E 74 20
  15++826A 20 5B 42 5D
  15++826E 61 63 6B 20
  15++8272 74 6F 20 70
  15++8276 72 65 76 2E
  15++827A 20 70 61 67
  15++827E 65 20 20 5B
  15++8282 48 5D 6F 6D
  15++8286 65 20 70 61
  15++828A 67 65 00
  16++828D
  17++828D              inputHost:
  18++828D CD A0 86         call Console.waitForKeyUp
  19++8290              .loop
  20++8290 11 0B 01         ld de, #010B
  20++8293 CD 07 80       call TextMode.gotoXY
  20++8296 21 28 9D       ld hl, hostName
  20++8299 CD 1E 80       call TextMode.printZ
  21++829C 3E 04            ld a, MIME_INPUT
  21++829E CD 1C 80       call TextMode.putC
  22++82A1 3E 20            ld a, ' '
  22++82A3 CD 1C 80       call TextMode.putC
  23++82A6              .wait
  24++82A6 CD A9 86         call Console.getC
  25++82A9 5F               ld e, a
  26++82AA FE 0C            cp Console.BACKSPACE
  26++82AC 28 17          jr z, .removeChar
  27++82AE FE 0D            cp CR
  27++82B0 CA D3 82       jp z, inputNavigate
  28++82B3 FE 20            cp 32
  28++82B5 38 EF          jr c, .wait
  29++82B7              .putC
  30++82B7 AF               xor a
  30++82B8 21 28 9D 01    ld hl, hostName, bc, 48
  30++82BC 30 00
  30++82BE ED B1          cpir
  31++82C0 77               ld (hl), a
  31++82C1 2B             dec hl
  31++82C2 73             ld (hl), e
  32++82C3 18 CB            jr .loop
  33++82C5              .removeChar
  34++82C5 AF               xor a
  35++82C6 21 28 9D 01      ld hl, hostName, bc, 48
  35++82CA 30 00
  35++82CC ED B1          cpir
  36++82CE 2B               dec hl
  36++82CF 2B             dec hl
  36++82D0 77             ld (hl), a
  37++82D1 18 BD            jr .loop
  38++82D3
  39++82D3              inputNavigate:
  40++82D3 21 28 9D 11      ld hl, hostName, de, domain
  40++82D7 06 83
  41++82D9 7E               ld a,(hl)
  42++82DA A7               and a
  43++82DB CA CD 86         jp z, History.load
  44++82DE              .loop
  45++82DE 7E               ld a, (hl)
  45++82DF A7             and a
  45++82E0 28 05          jr z, .complete
  46++82E2 12               ld (de), a
  46++82E3 23 13          inc hl, de
  47++82E5 18 F7            jr .loop
  48++82E7              .complete
  49++82E7 3E 09            ld a, TAB
  49++82E9 12             ld (de), a
  49++82EA 13             inc de
  50++82EB 3E 37            ld a, '7'
  50++82ED 12             ld (de), a
  50++82EE 13             inc de
  51++82EF 3E 30            ld a, '0'
  51++82F1 12             ld (de), a
  51++82F2 13             inc de
  52++82F3 3E 0D            ld a, CR
  52++82F5 12             ld (de), a
  52++82F6 13             inc de
  53++82F7 3E 0A            ld a, LF
  53++82F9 12             ld (de), a
  53++82FA 13             inc de
  54++82FB 21 01 83         ld hl, navRow
  54++82FE C3 22 87       jp History.navigate
  55++8301
  56++8301 31 20 09 2F  navRow db "1 ", TAB, "/", TAB
  56++8305 09
  57++8306 6E 69 68 69  domain db "nihirash.net"
  57++830A 72 61 73 68
  57++830E 2E 6E 65 74
  58++8312 00 00 00...      ds 64 - ($ - domain)
  59++8346
  60++8346                  IFDEF MB03
  61++8346 ~            header db "      Moon Rabbit "
  62++8346 ~                   db VERSION_STRING
  63++8346 ~                   db " for MB03+  (c) 2021 Alexander Nihirash",13, 0
  64++8346                  ENDIF
  65++8346
  66++8346                  IFDEF UNO
  67++8346 ~            header db "      Moon Rabbit "
  68++8346 ~                   db VERSION_STRING
  69++8346 ~                   db " for ZX-Uno (c) 2021 Alexander Nihirash",13, 0
  70++8346                  ENDIF
  71++8346
  72++8346                  IFDEF AY
  73++8346 ~            header db "      Moon Rabbit "
  74++8346 ~                   db VERSION_STRING
  75++8346 ~                   db " for AYWIFI (c) 2021 Alexander Nihirash",13, 0
  76++8346                  ENDIF
  77++8346
  78++8346                  IFDEF ZW
  79++8346 20 20 20 20  header db "      Moon Rabbit "
  79++834A 20 20 4D 6F
  79++834E 6F 6E 20 52
  79++8352 61 62 62 69
  79++8356 74 20
  80++8358 31 2E 36            db "1.6"
  81++835B 20 66 6F 72         db " for ZX WiFi (c) 2021 Alexander Nihirash",13, 0
  81++835F 20 5A 58 20
  81++8363 57 69 46 69
  81++8367 20 28 63 29
  81++836B 20 32 30 32
  81++836F 31 20 41 6C
  81++8373 65 78 61 6E
  81++8377 64 65 72 20
  81++837B 4E 69 68 69
  81++837F 72 61 73 68
  81++8383 0D 00
  82++8385                  ENDIF
# file closed: gopher/render/ui.asm
   7+ 8385                  include "gopher-page.asm"
# file opened: gopher/render/gopher-page.asm
   1++8385              renderGopherScreen:
   2++8385 CD 1A 82         call Render.prepareScreen
   3++8388
   4++8388              	;поиск и печать первой нужной строки
   5++8388 3A 36 8B         ld a, (page_offset)
   5++838B 47             ld b, a
   5++838C CD EF 81       call findLine ;поиск с начала буфера
   6++838F 7C               ld a, h
   6++8390 B5             or l
   6++8391 28 1F          jr z, .exit2
   7++8393 AF               xor a
   7++8394 E5             push hl
   7++8395 CD F1 80       call renderRow
   7++8398 E1             pop hl ;печать строки 0
   8++8399              	;теперь поиск продолжается
   9++8399
  10++8399 06 12            ld b, PER_PAGE-1 ;одну строку уже обработали
  11++839B              .loop
  12++839B C5               push bc
  13++839C 3E 13            ld a, PER_PAGE
  13++839E 90             sub b
  14++839F 5F               ld e, a
  14++83A0 06 01          ld b, 1
  14++83A2 CD F2 81       call findLine2 ;поиск одной следующей
  15++83A5 7C               ld a, h
  15++83A6 B5             or l
  15++83A7 28 06          jr z, .exit
  16++83A9 7B               ld a, e
  16++83AA E5             push hl
  16++83AB CD F1 80       call renderRow
  16++83AE E1             pop hl ;указатель hl надо сохранить
  17++83AF              .exit
  18++83AF C1               pop bc
  19++83B0 10 E9            djnz .loop
  20++83B2              .exit2
  21++83B2 CD 8C 84         call showCursor
  22++83B5 C9               ret
  23++83B6
  24++83B6              checkBorder:
  25++83B6 3A 37 8B         ld a, (cursor_position)
  25++83B9 FE FF          cp #ff
  25++83BB CA B0 84       jp z, pageUp
  26++83BE 3A 37 8B         ld a, (cursor_position)
  26++83C1 FE 13          cp PER_PAGE
  26++83C3 CA D3 84       jp z, pageDn
  27++83C6 CD 8C 84         call showCursor
  28++83C9 C3 CC 83         jp workLoop
  29++83CC
  30++83CC              workLoop:
  31++83CC 3A 81 85         ld a, (play_next)
  31++83CF A7             and a
  31++83D0 C2 45 84       jp nz, navigate
  32++83D3
  33++83D3                  ; dup 4
  34++83D3                  ; halt
  35++83D3                  ; edup
  36++83D3              .nothing
  37++83D3 76           	halt
  38++83D4 CD 4D A2     	call printRTC
  39++83D7 CD B2 86         call Console.peekC
  40++83DA FE FF            cp 255
  40++83DC 28 F5          jr z, .nothing
  41++83DE
  42++83DE FE 0A            cp Console.KEY_DN
  42++83E0 CA 9C 84       jp z, cursorDown
  43++83E3 FE 61            cp 'a'
  43++83E5 CA 9C 84       jp z, cursorDown
  44++83E8 FE 0B            cp Console.KEY_UP
  44++83EA CA A6 84       jp z, cursorUp
  45++83ED FE 71            cp 'q'
  45++83EF CA A6 84       jp z, cursorUp
  46++83F2 FE 08            cp Console.KEY_LT
  46++83F4 CA B0 84       jp z, pageUp
  47++83F7 FE 6F            cp 'o'
  47++83F9 CA B0 84       jp z, pageUp
  48++83FC FE 09            cp Console.KEY_RT
  48++83FE CA D3 84       jp z, pageDn
  49++8401 FE 70            cp 'p'
  49++8403 CA D3 84       jp z, pageDn
  50++8406
  51++8406 FE 68            cp 'h'
  51++8408 CA 1F 87       jp z, History.home
  52++840B FE 48            cp 'H'
  52++840D CA 1F 87       jp z, History.home
  53++8410
  54++8410 FE 62            cp 'b'
  54++8412 CA B6 86       jp z, History.back
  55++8415 FE 42            cp 'B'
  55++8417 CA B6 86       jp z, History.back
  56++841A FE 0C            cp Console.BACKSPACE
  56++841C CA B6 86       jp z, History.back
  57++841F
  58++841F FE 64            cp 'd'
  58++8421 CA 8D 82       jp z, inputHost
  59++8424 FE 44            cp 'D'
  59++8426 CA 8D 82       jp z, inputHost
  60++8429
  61++8429 FE 0D            cp CR
  61++842B CA 45 84       jp z, navigate
  62++842E
  63++842E                  ifdef GS
  64++842E FE 4D            cp 'M'
  64++8430 CC E5 A5       call z, GeneralSound.toggleModule
  65++8433 FE 6D            cp 'm'
  65++8435 CC E5 A5       call z, GeneralSound.toggleModule
  66++8438                  endif
  67++8438
  68++8438 FE 53        	cp 'S'
  68++843A CC E2 81       call z, toggleSaveMode
  69++843D FE 73        	cp 's'
  69++843F CC E2 81       call z, toggleSaveMode
  70++8442
  71++8442 C3 CC 83         jp workLoop
  72++8445
  73++8445              navigate:
  74++8445 CD A0 86         call Console.waitForKeyUp
  75++8448 AF               xor a
  75++8449 32 81 85       ld (play_next), a
  76++844C
  77++844C CD 94 84         call hideCursor
  78++844F 3A 36 8B 47      ld a, (page_offset), b, a, a, (cursor_position)
  78++8453 3A 37 8B
  78++8456 80             add b
  78++8457 47             ld b, a
  78++8458 CD EF 81       call Render.findLine
  79++845B 7E               ld a, (hl)
  80++845C FE 31            cp '1'
  80++845E CA 76 84       jp z, .load
  81++8461 FE 30            cp '0'
  81++8463 CA 76 84       jp z, .load
  82++8466 FE 39            cp '9'
  82++8468 CA 76 84       jp z, .load
  83++846B FE 37            cp '7'
  83++846D CA 7E 84       jp z, .input
  84++8470 CD 8C 84         call showCursor
  85++8473 C3 CC 83         jp workLoop
  86++8476              .load
  87++8476 E5               push hl
  88++8477 CD 06 81         call getIcon
  89++847A E1               pop hl
  90++847B C3 22 87         jp History.navigate
  91++847E              .input
  92++847E E5               push hl
  93++847F CD 82 85         call DialogBox.inputBox
  94++8482 E1               pop hl
  95++8483 3A D7 85         ld a, (DialogBox.inputBuffer)
  95++8486 A7             and a
  95++8487 CA CD 86       jp z, History.load
  96++848A 18 EA            jr .load
  97++848C
  98++848C              showCursor:
  99++848C 3A 37 8B         ld a, (cursor_position)
  99++848F C6 03          add CURSOR_OFFSET
 100++8491 C3 16 80         jp TextMode.highlightLine
 101++8494
 102++8494              hideCursor:
 103++8494 3A 37 8B         ld a, (cursor_position)
 103++8497 C6 03          add CURSOR_OFFSET
 104++8499 C3 10 80         jp TextMode.usualLine
 105++849C
 106++849C              cursorDown:
 107++849C CD 94 84         call hideCursor
 108++849F 21 37 8B         ld hl, cursor_position
 109++84A2 34               inc (hl)
 110++84A3 C3 B6 83         jp checkBorder
 111++84A6
 112++84A6              cursorUp:
 113++84A6 CD 94 84         call hideCursor
 114++84A9 21 37 8B         ld hl, cursor_position
 115++84AC 35               dec (hl)
 116++84AD C3 B6 83         jp checkBorder
 117++84B0
 118++84B0              pageUp:
 119++84B0 3A 36 8B         ld a, (page_offset)
 119++84B3 A7             and a
 119++84B4 28 13          jr z, .skip
 120++84B6 3E 12            ld a, PER_PAGE - 1
 120++84B8 32 37 8B       ld (cursor_position), a
 121++84BB 3A 36 8B         ld a, (page_offset)
 121++84BE D6 13          sub PER_PAGE
 121++84C0 32 36 8B       ld (page_offset), a
 122++84C3              .exit
 123++84C3 CD 85 83         call renderGopherScreen
 124++84C6 C3 CC 83         jp workLoop
 125++84C9              .skip
 126++84C9 AF               xor a
 126++84CA 32 37 8B       ld (cursor_position), a
 126++84CD CD 85 83       call renderGopherScreen
 126++84D0 C3 CC 83       jp workLoop
 127++84D3
 128++84D3              pageDn:
 129++84D3 AF               xor a
 129++84D4 32 37 8B       ld (cursor_position), a
 130++84D7 3A 36 8B         ld a, (page_offset)
 130++84DA C6 13          add PER_PAGE
 130++84DC 32 36 8B       ld (page_offset), a
 131++84DF 18 E2            jr pageUp.exit
# file closed: gopher/render/gopher-page.asm
   8+ 84E1                  include "plaintext.asm"
# file opened: gopher/render/plaintext.asm
   1++84E1              renderPlainTextScreen:
   2++84E1 CD 1A 82         call prepareScreen
   3++84E4
   4++84E4              	;поиск и печать первой нужной строки
   5++84E4 3A 36 8B         ld a, (page_offset)
   5++84E7 47             ld b, a
   5++84E8 CD EF 81       call findLine ;поиск с начала буфера
   6++84EB 7C               ld a, h
   6++84EC B5             or l
   6++84ED 28 2D          jr z, .exit2
   7++84EF AF               xor a
   8++84F0 C6 03            add CURSOR_OFFSET
   8++84F2 57 1E 01       ld d, a, e, 1
   8++84F5 CD 07 80       call TextMode.gotoXY
   9++84F8 CD C0 80         call print70Text
  10++84FB              	;теперь поиск продолжается
  11++84FB
  12++84FB 06 12            ld b, PER_PAGE-1
  13++84FD              .loop
  14++84FD C5               push bc
  15++84FE 3E 13            ld a, PER_PAGE
  15++8500 90             sub b
  16++8501 5F               ld e, a
  16++8502 06 01          ld b, 1
  16++8504 CD F2 81       call Render.findLine2
  17++8507 7C               ld a, h
  17++8508 B5             or l
  17++8509 28 10          jr z, .exit
  18++850B 7B               ld a, e
  19++850C C6 03            add CURSOR_OFFSET
  19++850E 57 1E 01       ld d, a, e, 1
  19++8511 CD 07 80       call TextMode.gotoXY
  20++8514 CD C0 80         call print70Text
  21++8517 C1               pop bc
  22++8518 10 E3            djnz .loop
  23++851A C9               ret
  24++851B              .exit
  25++851B C1               pop bc
  26++851C              .exit2
  27++851C C9               ret
  28++851D
  29++851D              plainTextLoop:
  30++851D CD A9 86         call Console.getC
  31++8520
  32++8520 FE 0A            cp Console.KEY_DN
  32++8522 CA 63 85       jp z, textDown
  33++8525 FE 61            cp 'a'
  33++8527 CA 63 85       jp z, textDown
  34++852A
  35++852A FE 0B            cp Console.KEY_UP
  35++852C CA 71 85       jp z, textUp
  36++852F FE 71            cp 'q'
  36++8531 CA 71 85       jp z, textUp
  37++8534
  38++8534 FE 68            cp 'h'
  38++8536 CA 1F 87       jp z, History.home
  39++8539 FE 48            cp 'H'
  39++853B CA 1F 87       jp z, History.home
  40++853E
  41++853E FE 62            cp 'b'
  41++8540 CA B6 86       jp z, History.back
  42++8543 FE 42            cp 'B'
  42++8545 CA B6 86       jp z, History.back
  43++8548
  44++8548 FE 0C            cp Console.BACKSPACE
  44++854A CA B6 86       jp z, History.back
  45++854D
  46++854D                  ifdef GS
  47++854D FE 4D            cp 'M'
  47++854F CC E5 A5       call z, GeneralSound.toggleModule
  48++8552 FE 6D            cp 'm'
  48++8554 CC E5 A5       call z, GeneralSound.toggleModule
  49++8557                  endif
  50++8557
  51++8557 FE 53            cp 'S'
  51++8559 CC E2 81       call z, toggleSaveMode
  52++855C FE 73        	cp 's'
  52++855E CC E2 81       call z, toggleSaveMode
  53++8561
  54++8561 18 BA            jr plainTextLoop
  55++8563
  56++8563
  57++8563              textDown:
  58++8563 3A 36 8B         ld a, (page_offset)
  58++8566 C6 13          add PER_PAGE
  58++8568 32 36 8B       ld (page_offset), a
  59++856B CD E1 84         call renderPlainTextScreen
  60++856E C3 1D 85         jp plainTextLoop
  61++8571
  62++8571              textUp:
  63++8571 21 36 8B         ld hl, page_offset
  64++8574 7E               ld a, (hl)
  64++8575 A7             and a
  64++8576 28 A5          jr z, plainTextLoop
  65++8578 D6 13            sub PER_PAGE
  65++857A 77             ld (hl), a
  66++857B CD E1 84         call renderPlainTextScreen
  67++857E C3 1D 85         jp plainTextLoop
# file closed: gopher/render/plaintext.asm
   9+ 8581
  10+ 8581 00           play_next       db  0
  11+ 8582              position        EQU historyBlock.position
  12+ 8582              cursor_position EQU position + 1
  13+ 8582              page_offset     EQU position
  14+ 8582                  ENDMODULE
  15+ 8582
  16+ 8582                  include "dialogbox.asm"
# file opened: gopher/render/dialogbox.asm
   1++8582                  module DialogBox
   2++8582
   3++8582              inputBox:
   4++8582 AF               xor a
   4++8583 32 D7 85       ld (inputBuffer), a
   5++8586              .noclear
   6++8586 CD 38 86         call drawBox
   7++8589              .loop
   8++8589 11 05 0B         ld de, #0B05
   8++858C CD 07 80       call TextMode.gotoXY
   9++858F 21 D7 85         ld hl, inputBuffer
   9++8592 CD 1E 80       call TextMode.printZ
  10++8595 3E 04            ld a, MIME_INPUT
  10++8597 CD 1C 80       call TextMode.putC
  10++859A 3E 20          ld a, ' '
  10++859C CD 1C 80       call TextMode.putC
  11++859F              .checkkey
  12++859F CD A9 86         call Console.getC
  13++85A2 FE 0C            cp Console.BACKSPACE
  13++85A4 28 16          jr z, .removeChar
  14++85A6 FE 0D            cp CR
  14++85A8 C8             ret z
  15++85A9 FE 20            cp SPACE
  15++85AB 38 F2          jr c, .checkkey
  16++85AD              .putC
  17++85AD 5F               ld e, a
  18++85AE AF               xor a
  18++85AF 21 D7 85 01    ld hl, inputBuffer, bc, #ff
  18++85B3 FF 00
  18++85B5 ED B1          cpir
  19++85B7 77               ld (hl), a
  19++85B8 2B             dec hl
  19++85B9 73             ld (hl), e
  20++85BA 18 CD            jr .loop
  21++85BC              .removeChar
  22++85BC AF               xor a
  23++85BD 21 D7 85 01      ld hl, inputBuffer, bc, #ff
  23++85C1 FF 00
  23++85C3 ED B1          cpir
  24++85C5 E5               push hl
  25++85C6 11 D8 85             ld de, inputBuffer + 1
  26++85C9 B7                   or a
  26++85CA ED 52          sbc hl, de
  27++85CC 7C                   ld a, h
  27++85CD B5             or l
  28++85CE E1               pop hl
  29++85CF 28 B8            jr z, .loop
  30++85D1 AF               xor a
  31++85D2 2B               dec hl
  31++85D3 2B             dec hl
  31++85D4 77             ld (hl), a
  32++85D5 18 B2            jr .loop
  33++85D7
  34++85D7 00 00 00...  inputBuffer ds 80
  35++8627
  36++8627              msgBox:
  37++8627 CD 30 86         call msgNoWait
  38++862A 06 96            ld b, 150
  39++862C              .loop
  40++862C 76               halt
  41++862D 10 FD            djnz .loop
  42++862F C9               ret
  43++8630
  44++8630              msgNoWait:
  45++8630 E5               push hl
  46++8631 CD 38 86         call drawBox
  47++8634 E1               pop hl
  48++8635 C3 1E 80         jp TextMode.printZ
  49++8638
  50++8638              drawBox:
  51++8638 26 0A 3E 09      ld h, #0A, a, BORDER_TOP
  51++863C CD 0C 80       call TextMode.fillLine
  52++863F 26 0B 3E 20      ld h, #0B, a, ' '
  52++8643 CD 0C 80       call TextMode.fillLine
  53++8646 26 0C 3E 08      ld h, #0C, a, BORDER_BOTTOM
  53++864A CD 0C 80       call TextMode.fillLine
  54++864D
  55++864D                  IFNDEF TIMEX80
  56++864D 3E 0A            ld a, #0a
  56++864F CD 16 80       call TextMode.highlightLine
  57++8652 3E 0C            ld a, #0c
  57++8654 CD 16 80       call TextMode.highlightLine
  58++8657                  ENDIF
  59++8657
  60++8657 11 05 0B         ld de, #0B05
  60++865A CD 07 80       call TextMode.gotoXY
  61++865D C9               ret
  62++865E                  endmodule
  63++865E
# file closed: gopher/render/dialogbox.asm
# file closed: gopher/render/index.asm
  18  865E                  include "dos/index.asm"
# file opened: dos/index.asm
   1+ 865E                  IFDEF ESX
   2+ 865E ~                include "esxdos.asm"
   3+ 865E              	ENDIF
   4+ 865E                  IFDEF TRD
   5+ 865E ~                include "trdos.asm"
   6+ 865E              	ENDIF
   7+ 865E                  IFDEF ZSFAT
   8+ 865E                  include "zsfat.asm"
# file opened: dos/zsfat.asm
   1++865E              ;trdos driver (izzx)
   2++865E                  MODULE Dos
   3++865E              ; API methods
   4++865E              ESX_GETSETDRV = #89
   5++865E              ESX_FOPEN = #9A
   6++865E              ESX_FCLOSE = #9B
   7++865E              ESX_FSYNC = #9C
   8++865E              ESX_FREAD = #9D
   9++865E              ESX_FWRITE = #9E
  10++865E
  11++865E              ; File modes
  12++865E              FMODE_READ = #01
  13++865E              FMODE_WRITE = #06
  14++865E              FMODE_CREATE = #0E
  15++865E
  16++865E                  ; MACRO esxCall func
  17++865E                  ; rst #8 : db func
  18++865E                  ; ENDM
  19++865E
  20++865E              ;макросы модуля
  21++865E              ;
  22++865E              ;R8DOS			вызов функции R8DOS
  23++865E              ;R8FAT			вызов функции R8FAT
  24++865E              ;R8DOSc			вызов функции R8DOS
  25++865E              ;
  26++865E              ;------------------------------------------------------------------------------
  27++865E              ;вызов функции R8DOS
  28++865E              ;вх: =0 номер функции
  29++865E              ;
  30++865E              	; MACRO	R8DOS nFunc
  31++865E              	; ld	c,nFunc
  32++865E              	; rst	#08
  33++865E              	; db	#81
  34++865E              	; ENDM
  35++865E
  36++865E              ; ;------------------------------------------------------------------------------
  37++865E              ; ;вызов функции R8FAT
  38++865E              ; ;вх: =0 номер функции
  39++865E              ; ;
  40++865E              	; MACRO	R8FAT nFunc
  41++865E              	; ld	c,nFunc
  42++865E              	; rst	#08
  43++865E              	; db	#91
  44++865E              	; ENDM
  45++865E
  46++865E              ; ;------------------------------------------------------------------------------
  47++865E              ; ;вызов функции R8DOS
  48++865E              ; ;вх: c - номер функции
  49++865E              ; ;
  50++865E              	; MACRO	R8DOSc
  51++865E              	; rst	#08
  52++865E              	; db	#81
  53++865E              	; ENDM
  54++865E
  55++865E              ; ;------------------------------------------------------------------------------
  56++865E              ; ;вызов функции #02 (FileMan) R8CONF
  57++865E              ; ;вх: =#00 - номер функции файл менеджера
  58++865E              ; ;
  59++865E              	; MACRO	R8C02FM nFunct
  60++865E              	; ld	bc,#100*nFunct+#02
  61++865E              	; rst	#08
  62++865E              	; db	#8E
  63++865E              	; ENDM
  64++865E
  65++865E              ;==============================================================================
  66++865E              ; r8f00_DeinitFAT		equ #00
  67++865E              ; r8f01_InitFAT		equ #01
  68++865E              ; r8f04_FindPath		equ #04
  69++865E              ; r8f07_FileOpen		equ #07 ;открыть файл для последующих операций с ним
  70++865E              ; r8f09_FileWrite		equ #09	;запись данных из памяти в файл
  71++865E              ; r8f0E_CreateFileLFN	equ #0E ;создание файла с длинным именем в текущем каталоге
  72++865E              ; r8f0F_CreateFileSFN	equ #0F
  73++865E
  74++865E              ; r8d2D_FindPart		equ #2D
  75++865E              ; r8d2E_CngHDD		equ #2E
  76++865E
  77++865E
  78++865E              ;id = 0 файл не открыт
  79++865E              ;id = 1 файл для чтения trdos
  80++865E              ;id = 2 файл для записи trdos
  81++865E              ;id = 3 файл для записи тип TRD trdos
  82++865E              ;id = 4 файл для записи тип SCL trdos
  83++865E              ;id = 5 файл для чтения fat32 (пока не сделано)
  84++865E              ;id = 6 файл для записи fat32
  85++865E
  86++865E              ; HL - filename in ASCIIZ
  87++865E              loadBuffer:
  88++865E 06 01            ld b, Dos.FMODE_READ
  88++8660 CD 7A 86       call Dos.fopen
  89++8663 F5               push af
  90++8664 21 F1 A5 01          ld hl, outputBuffer, bc, #ffff - outputBuffer
  90++8668 0E 5A
  90++866A CD 93 86       call Dos.fread
  91++866D 21 F1 A5             ld hl, outputBuffer
  91++8670 09             add hl, bc
  91++8671 AF             xor a
  91++8672 77             ld (hl), a
  91++8673 23             inc hl
  91++8674 77             ld (hl), a
  92++8675 F1               pop af
  93++8676 CD 8F 86         call Dos.fclose
  94++8679 C9               ret
  95++867A
  96++867A
  97++867A              ; Returns:
  98++867A              ;  A - current drive
  99++867A              ; getDefaultDrive: ;нигде не используется
 100++867A                  ; ld a, 0 : esxCall ESX_GETSETDRV
 101++867A                  ; ret
 102++867A
 103++867A
 104++867A
 105++867A              ; Opens file on default drive
 106++867A              ; B - File mode
 107++867A              ; HL - File name
 108++867A              ; Returns:
 109++867A              ;  A - file stream id
 110++867A              fopen:
 111++867A                  ; push bc : push hl
 112++867A                  ; call getDefaultDrive
 113++867A                  ; pop ix : pop bc
 114++867A                  ; esxCall ESX_FOPEN
 115++867A                  ; ret
 116++867A 78           	ld a,b
 117++867B FE 01        	cp FMODE_READ ;если режим открытие файла
 118++867D 28 06        	jr z,fopen_r
 119++867F FE 0E        	cp FMODE_CREATE
 120++8681 28 08        	jr z,fopen_c ;если режим создание файла
 121++8683 18 04        	jr fopen_err ;иначе выход
 122++8685
 123++8685              fopen_r	;открытие существующего файла на чтение (id=1)
 124++8685
 125++8685              	;call format_name ;
 126++8685
 127++8685              	OS_FOPENRW
 127++8685 0E 21       >    ld c,#21
 127++8687 E7          >    rst #20
 128++8688 C9           	ret
 129++8689              	; ld a,(#5D19) ;номер дисковода по умолчанию
 130++8689              	; ld 	(prev_drive),a ;запомним
 131++8689              			;call format_name ;
 132++8689              			; ld      c,#13 ;move file info to syst var
 133++8689                          ; call    call3d13
 134++8689                          ; ld      c,#0a ;find file
 135++8689                          ; call    call3d13
 136++8689                          ; ld      a,c
 137++8689              			; cp 		#ff
 138++8689              			; jr 		z,fopen_err ;если не нашли файла
 139++8689                          ; ld      c,#08 ;read file title
 140++8689                          ; call    call3d13
 141++8689                          ; ;ld      hl,loadadr ;куда
 142++8689                          ; ld      de,(#5ceb) ;начало файла сектор дорожка
 143++8689                          ; ld      (f_r_cur_trk),de
 144++8689
 145++8689                          ; ld      a,(#5cea)
 146++8689                          ; ld      (f_r_len_sec),a ;длина в секторах
 147++8689                          ; ;or      a
 148++8689                          ; ;ret     z    ;выход если пустой
 149++8689
 150++8689              			; ld de,(#5CE8) ; длина файла или программной части для BASIC
 151++8689              			; ld      (f_r_len),de
 152++8689
 153++8689                          ; ; ld      de,(fcurtrk) ;текущие сектор дорожка
 154++8689                          ; ; ld      (#5cf4),de ;восстановим
 155++8689              			; xor a
 156++8689              			; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 157++8689              			; ld 		a,1
 158++8689              			; ld (f_r_flag),a ;флаг что файл для чтения открыт
 159++8689              			; ;id канала будет 1
 160++8689              	;ret
 161++8689
 162++8689              fopen_err
 163++8689              	; ld a,1
 164++8689              	; ld (com_file_err_flag),a
 165++8689              	; xor a ;если никакой файл не открыли, то id = 0
 166++8689 37           	scf ;флаг ошибки
 167++868A C9           	ret
 168++868B
 169++868B
 170++868B              fopen_c	;создание нового файла (id=2-4,6)
 171++868B              	; ld a,(#5D19) ;номер дисковода по умолчанию
 172++868B              	; ld 	(prev_drive),a ;запомним
 173++868B
 174++868B              	;call format_name ;
 175++868B
 176++868B              	OS_FOPENC
 176++868B 0E 22       >    ld c,#22
 176++868D E7          >    rst #20
 177++868E C9           	ret
 178++868F
 179++868F              	; call select_drive
 180++868F              	; cp "y"
 181++868F              	; jr nz,fopen_err
 182++868F
 183++868F              	; ld a,(curr_drive)
 184++868F              	; cp 4
 185++868F              	; jp nc,fopen_c_fat ;если выбран FAT
 186++868F
 187++868F              	; ;выясним, не образ ли это для разворачивания
 188++868F                  ; ld hl, trdExt1 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 189++868F                  ; ld hl, trdExt2 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 190++868F              	; ld hl, sclExt1 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 191++868F                  ; ld hl, sclExt2 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 192++868F
 193++868F
 194++868F              	; ;создание произвольного файла (id=2)
 195++868F              	; call cat_buf_cls
 196++868F
 197++868F              	; ld hl,cat_buf ;считаем каталог диска
 198++868F              	; ld de,0
 199++868F                  ; ld      bc,#0905 ;
 200++868F                  ; call    call3d13
 201++868F
 202++868F              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 203++868F              	; cp 128
 204++868F              	; jp c,fopen_c2 ;если уже максимум
 205++868F                  ; ld hl, file_err
 206++868F                  ; call DialogBox.msgBox ;предуреждение
 207++868F              	; jr fopen_err
 208++868F
 209++868F              ; fopen_c2
 210++868F              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 211++868F              	; ld a,h
 212++868F              	; or l
 213++868F              	; jr nz,fopen_c3 ;если ещё есть место
 214++868F                  ; ld hl, file_err
 215++868F                  ; call DialogBox.msgBox ;предуреждение
 216++868F              	; jr fopen_err
 217++868F
 218++868F              ; fopen_c3
 219++868F              	; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 220++868F                  ; ld   (#5cf4),de ;отсюда будем писать файл
 221++868F
 222++868F              	; xor a
 223++868F              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 224++868F              	; ld (sec_shift),a ;переменная
 225++868F              	; ld hl,0
 226++868F              	; ld (f_w_len+0),hl
 227++868F              	; ld (f_w_len+2),hl
 228++868F              	; ld a,2 ;id канала
 229++868F              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 230++868F              	; ret
 231++868F
 232++868F
 233++868F              ; cat_buf_cls ;очистка буфера каталога
 234++868F              	; ld hl,cat_buf ;очистить место для каталога дискеты
 235++868F              	; ld de,cat_buf+1
 236++868F              	; ld (hl),0
 237++868F              	; ld bc,9*256-1
 238++868F              	; ldir
 239++868F              	; ret
 240++868F
 241++868F
 242++868F
 243++868F              ; fopen_c_trd	;открытие файла для разворачивания образа trd (id=3)
 244++868F              	; call select_drive
 245++868F              	; cp "y"
 246++868F              	; jp nz,fopen_err
 247++868F
 248++868F              	; ld      de,0 ;начало сектор дорожка
 249++868F                  ; ld      (#5cf4),de
 250++868F
 251++868F              	; xor a
 252++868F              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 253++868F              	; ld (sec_shift),a ;переменная
 254++868F              	; ld hl,0
 255++868F              	; ld (f_w_len+0),hl
 256++868F              	; ld (f_w_len+2),hl
 257++868F              	; ld a,3 ;id канала
 258++868F              	; ld (f_w_flag),a ;флаг что trd для записи открыт
 259++868F              	; ret
 260++868F
 261++868F
 262++868F
 263++868F              ; fopen_c_scl	;открытие файла для разворачивания образа scl (id=4)
 264++868F              	; call select_drive
 265++868F              	; cp "y"
 266++868F              	; jp nz,fopen_err
 267++868F
 268++868F              	; ld      de,0 ;начало сектор дорожка
 269++868F                  ; ld      (#5cf4),de
 270++868F
 271++868F              	; call cat_buf_cls ;почистить место
 272++868F
 273++868F              	; call scl_parse ;запуск цикла сборки образа
 274++868F
 275++868F              	; xor a
 276++868F              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 277++868F              	; ld (sec_shift),a ;переменная
 278++868F              	; ;ld (scl_que),a
 279++868F              	; ld hl,0
 280++868F              	; ld (f_w_len+0),hl
 281++868F              	; ld (f_w_len+2),hl
 282++868F              	; ld a,4 ;id канала
 283++868F              	; ld (f_w_flag),a ;флаг что scl для записи открыт
 284++868F              	; ret
 285++868F
 286++868F
 287++868F
 288++868F
 289++868F              ; fopen_c_fat	;создание файла FAT (id=6)
 290++868F
 291++868F              ; ;переинициализация FAT раздела
 292++868F              	; R8FAT	r8f00_DeinitFAT
 293++868F              	; jp 		c,fopen_err
 294++868F
 295++868F              	; ld a,(curr_drive)
 296++868F              	; ld bc,typeDrive-4
 297++868F              	; ld l,a
 298++868F              	; ld h,0
 299++868F              	; add hl,bc
 300++868F              	; ld a,(hl) ;получили код раздела из списка
 301++868F              	; rlca
 302++868F              	; rlca
 303++868F              	; rlca
 304++868F              	; rlca
 305++868F              	; and %11110000
 306++868F                  ; ;         ld      a,%0000????
 307++868F                                     ; ; ││└┴─── номер раздела
 308++868F                                     ; ; │└───── master/slave для Hdd
 309++868F                                     ; ; └────── SD/Hdd
 310++868F              	; R8FAT	r8f01_InitFAT
 311++868F                  ; jp      c,fopen_err
 312++868F
 313++868F              ; ;поиск пути в разделе
 314++868F              	; ld	hl,ActPathFAT		;путь к каталогу Download
 315++868F              	; ld	de,fcb
 316++868F              	; xor	a
 317++868F              	; dec	a
 318++868F              	; R8FAT	r8f04_FindPath
 319++868F                  ; ;jp      c,fopen_err ;если не нашли, файл будет в корне
 320++868F
 321++868F              	; ld	hl,(temp_hl)		;строка с именем
 322++868F              	; ld	de,fcb
 323++868F              	; R8FAT r8f07_FileOpen
 324++868F              	; jp 	nc,fopen_c_fat2 ;если файл есть, откроем
 325++868F
 326++868F              ; ;создание файла, если нет
 327++868F              	; ld	hl,(temp_hl)		;строка с именем
 328++868F              	; xor	a
 329++868F              	; ld	(fcb+#14+0),a
 330++868F              	; ld	(fcb+#14+1),a
 331++868F              	; ld	(fcb+#14+2),a	;установим размер
 332++868F              	; ld	(fcb+#14+3),a
 333++868F              	; ld	de,fcb
 334++868F              	; R8FAT	r8f0E_CreateFileLFN	;создание файла
 335++868F              	; jp 	c,fopen_err
 336++868F
 337++868F              ; fopen_c_fat2
 338++868F
 339++868F              	; ld hl,0
 340++868F              	; ld (f_w_len+0),hl
 341++868F              	; ld (f_w_len+2),hl
 342++868F              	; xor a
 343++868F              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 344++868F              	; ld a,6 ;id канала
 345++868F              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 346++868F              	; ret
 347++868F
 348++868F
 349++868F
 350++868F
 351++868F
 352++868F              ; select_drive	;запрос номера дисковода
 353++868F              	; ld a,(hdd_init_flag) ;если в первый раз
 354++868F              	; or a
 355++868F              	; jr nz,select_drive2
 356++868F              	; ld a,(#5D19) ;номер дисковода по умолчанию
 357++868F              	; ld (curr_drive),a
 358++868F              	; call GetNumPart ;узнаем какая буква последняя, сколько разделов ФАТ
 359++868F              	; add "D"
 360++868F              	; ld (write_ima_e),a	;выбор до этой буквы
 361++868F              	; sub "D"
 362++868F              	; inc a
 363++868F              	; add "d"
 364++868F              	; ld (next_lett),a ;эта буква первая свободная
 365++868F              	; ld a,1
 366++868F              	; ld (hdd_init_flag),a
 367++868F              ; select_drive2
 368++868F              	; ld a,(curr_drive) ;номер дисковода по умолчанию
 369++868F              	; add a,"A"
 370++868F              	; ld (write_ima_d),a ;подставим букву в запросе
 371++868F                  ; ld hl, write_ima
 372++868F                  ; call DialogBox.msgNoWait ;текст запроса
 373++868F              ; select_drive_wait
 374++868F              	; ;halt
 375++868F              	; call Console.getC
 376++868F              	; cp 255
 377++868F              	; JR Z,select_drive_wait	;ждём любую клавишу
 378++868F              	; cp "y"
 379++868F              	; jr z,select_drive_ex
 380++868F              	; cp "n"
 381++868F              	; ret z
 382++868F              	; cp "a" ;от буквы A
 383++868F              	; jr c,select_drive_wait
 384++868F              	; ld hl,next_lett
 385++868F              	; cp (hl) ;до первой свободной буквы
 386++868F              	; jr nc,select_drive_wait
 387++868F              	; sub "a"
 388++868F              	; ld (curr_drive),a ;новый номер диска
 389++868F              	; jr select_drive2 ;обновить строку
 390++868F              ; select_drive_ex ;выход
 391++868F              	; ld a,(curr_drive)
 392++868F              	; cp 4 ;начиная с буквы E идёт HDD
 393++868F              	; jr nc,select_drive3
 394++868F                  ; ld      (#5d19) ,a ;если дискета, настроим trdos
 395++868F                  ; ld      c,1
 396++868F                  ; call    call3d13
 397++868F                  ; ld      c,#18
 398++868F                  ; call    call3d13
 399++868F              ; select_drive3
 400++868F              	; ld a,"y"
 401++868F              	; ret
 402++868F
 403++868F
 404++868F              ; ; restore_drive ;восстановить дисковод по умолчанию
 405++868F              	; ; ld 	a,(prev_drive)
 406++868F                  ; ; ld      (#5d19) ,a
 407++868F                  ; ; ld      c,1
 408++868F                  ; ; call    call3d13
 409++868F                  ; ; ld      c,#18
 410++868F                  ; ; call    call3d13
 411++868F              	; ; ret
 412++868F
 413++868F
 414++868F              ; call3d13 ;фикс для GMX
 415++868F              	; ifndef ZSGMX
 416++868F                  ; jp    #3d13
 417++868F              	; endif
 418++868F
 419++868F              	; ; ifdef ZSGMX
 420++868F                  ; ; call    #3d13
 421++868F              	; ; exx
 422++868F              	; ; call TextMode.gmxscron
 423++868F              	; ; exx
 424++868F              	; ; endif
 425++868F              	; ret
 426++868F
 427++868F
 428++868F
 429++868F              ; A - file stream id
 430++868F              fclose:
 431++868F              	OS_FCLOSE
 431++868F 0E 25       >    ld c,#25
 431++8691 E7          >    rst #20
 432++8692 C9           	ret
 433++8693
 434++8693                  ; ;esxCall ESX_FCLOSE
 435++8693              	; ; push af
 436++8693              	; ; pop af
 437++8693              	; cp 2 ;если обычный файл
 438++8693              	; jp nz,fclose_scl
 439++8693
 440++8693              	; ;дописать остаток файла
 441++8693              	; ld a,(write_end_flag) ;нужно записывать остаток?
 442++8693              	; or a
 443++8693              	; jr nz,fclose_f ;не нужно
 444++8693
 445++8693              	; ld hl,sec_buf
 446++8693              	; ld bc,#0106
 447++8693              	; ld de,(#5cf4)
 448++8693              	; call call3d13
 449++8693
 450++8693              	; ld a,"0" ;номер части файла
 451++8693              	; ld (file_num),a
 452++8693
 453++8693              ; fclose_f ;поправить каталог
 454++8693              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 455++8693              	; ld hl,(f_w_len+0)
 456++8693              	; or h
 457++8693              	; or l
 458++8693              	; jp z,fclose_ex ;выход если длина 0
 459++8693
 460++8693              	; ;проверки на заполнение
 461++8693              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 462++8693              	; cp 128
 463++8693              	; jp nc,fclose_ex ;если уже максимум
 464++8693              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 465++8693              	; ld a,h
 466++8693              	; or l
 467++8693              	; jp z,fclose_ex ;если места нет
 468++8693
 469++8693              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 470++8693              	; or a
 471++8693              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 472++8693              	; ld a,(f_w_len+1)
 473++8693              	; cp 255
 474++8693              	; jr nz,fclose_f1
 475++8693              	; ld a,(f_w_len+0)
 476++8693              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 477++8693              ; fclose_f1
 478++8693              	; ;файл не превышает максимальный размер для trdos
 479++8693              	; ld de,(f_w_len+0)
 480++8693              	; ld hl,f_name+11 ;длина файла
 481++8693              	; ld (hl),e
 482++8693              	; inc hl
 483++8693              	; ld (hl),d
 484++8693              	; inc hl
 485++8693              	; ld a,(f_w_len+1) ;длина секторов
 486++8693              	; ld (hl),a
 487++8693              	; ld a,(f_w_len+0) ;длина младший
 488++8693              	; or a
 489++8693              	; jr z,fclose_f2
 490++8693              	; inc (hl) ;коррекция секторов
 491++8693              ; fclose_f2
 492++8693              	; call fclose_f_one ;записать информацию
 493++8693              	; jp fclose_ex ;готово
 494++8693
 495++8693              ; fclose_f_multi ;файл большой, будет несколько записей в каталоге
 496++8693              	; ld a,(file_num)
 497++8693              	; ld (f_name+7),a ;в конце имени номер
 498++8693
 499++8693              	; ld hl,f_name+11 ;длина файла
 500++8693              	; ld (hl),0
 501++8693              	; inc hl
 502++8693              	; ld (hl),#ff ;65280
 503++8693              	; inc hl
 504++8693              	; ;длина секторов
 505++8693              	; ld (hl),#ff
 506++8693              	; call fclose_f_one ;записать информацию
 507++8693
 508++8693              	; ;вычесть длину записанного
 509++8693              	; ld hl,(f_w_len+1) ;старший и средний байт
 510++8693              	; ld bc,255
 511++8693              	; and a
 512++8693              	; sbc hl,bc ;вычесть 255 секторов
 513++8693              	; ld (f_w_len+1),hl
 514++8693
 515++8693              	; ld a,(file_num)
 516++8693              	; inc a
 517++8693              	; ld (file_num),a
 518++8693              	; ld (f_name+7),a ;в конце имени номер
 519++8693
 520++8693              	; jr fclose_f ;сначала
 521++8693
 522++8693
 523++8693              ; fclose_f_one ;запись об одном файле
 524++8693              			; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 525++8693              			; ld l,a ;узнать в каком секторе будет запись о файле
 526++8693              			; ld h,0
 527++8693              			; add hl,hl ;*2
 528++8693              			; add hl,hl ;*4
 529++8693              			; add hl,hl ;*8
 530++8693              			; add hl,hl ;*16
 531++8693              			; ld a,h ;запомнить номер сетора в каталоге
 532++8693              			; ld (sec_cat),a
 533++8693              			; ld bc,cat_buf
 534++8693              			; add hl,bc ;здесь будет запись о новом файле
 535++8693              			; ex de,hl
 536++8693
 537++8693              			; ld hl,f_name ;запись о файле
 538++8693              			; ld bc,16
 539++8693              			; ldir ;скопировать
 540++8693              			; ex de,hl
 541++8693              			; dec hl
 542++8693              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка назначения
 543++8693              			; ld (hl),d ;дорожка
 544++8693              			; dec hl
 545++8693              			; ld (hl),e ;сектор
 546++8693
 547++8693              			; ld l,0 ;записать сектор целиком по ровному адресу
 548++8693              			; ld d,0
 549++8693              			; ld a,(sec_cat)
 550++8693              			; ld e,a ;номер сектора
 551++8693              			; ld bc,#0106 ;1 сектор записать
 552++8693              			; call call3d13
 553++8693
 554++8693              			; ;служебный сектор
 555++8693              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 556++8693              			; ld a,(f_name+13) ;размер файла в секторах
 557++8693              			; ld b,a
 558++8693              			; call calc_next_pos2
 559++8693              			; ld (cat_buf+8*256+#e1),de
 560++8693
 561++8693              			; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 562++8693              			; ld a,(f_name+13) ;размер файла в секторах
 563++8693              			; ld c,a
 564++8693              			; ld b,0
 565++8693              			; and a
 566++8693              			; sbc hl,bc
 567++8693              			; jr nc,fclose_f_one2
 568++8693              			; ld hl,0 ;если было отрицательное
 569++8693              ; fclose_f_one2
 570++8693              			; ld (cat_buf+8*256+#e5),hl
 571++8693
 572++8693              			; ld hl,cat_buf+8*256+#e4 ; общее количество файлов
 573++8693              			; inc (hl)
 574++8693
 575++8693              			; ld hl,cat_buf+8*256
 576++8693              			; ld de,#0008
 577++8693              			; ld bc,#0106 ;1 сектор записать
 578++8693              			; call call3d13
 579++8693              			; ret
 580++8693
 581++8693
 582++8693              ; fclose_scl
 583++8693              	; cp 4 ;если scl
 584++8693              	; jr nz,fclose_ex
 585++8693              	; ld hl,sec_buf ;
 586++8693              	; ld b,1
 587++8693              	; call scl_write_buf ;допишем остаток scl, если есть
 588++8693
 589++8693              ; fclose_ex
 590++8693              	; xor a ;закрываем все файлы
 591++8693              	; ld (f_r_flag),a
 592++8693              	; ld (f_w_flag),a
 593++8693
 594++8693              	; ld a,(com_file_err_flag) ;была ли ошибка
 595++8693              	; or a
 596++8693              	; ret z
 597++8693              	; ld a,2 ;если была
 598++8693              	; out (254),a ;бордюр красный
 599++8693                  ; ld hl, com_file_err ;общая ошибка
 600++8693                  ; call DialogBox.msgBox ;предуреждение
 601++8693              	; xor a ;
 602++8693              	; out (254),a
 603++8693              	; ;call restore_drive ;вернуть диск, какой был
 604++8693                  ; ret
 605++8693
 606++8693
 607++8693
 608++8693
 609++8693              ; A - file stream id
 610++8693              ; BC - length
 611++8693              ; HL - buffer
 612++8693              ; Returns
 613++8693              ;  BC - length(how much was actually read)
 614++8693              fread: ;(id=1)
 615++8693 59           	ld e,c ;сохранить длину
 616++8694 50           	ld d,b
 617++8695              	OS_FREAD
 617++8695 0E 23       >    ld c,#23
 617++8697 E7          >    rst #20
 618++8698 C9           	ret
 619++8699
 620++8699                  ; push hl : pop ix
 621++8699                  ; esxCall ESX_FREAD
 622++8699              	; push af
 623++8699              	; ld a,4
 624++8699              	; out (254),a
 625++8699              	; xor a
 626++8699              	; out (254),a
 627++8699              	; pop af
 628++8699
 629++8699              	; cp 1 ;id = 1?
 630++8699              	; jr nz,fread_no_chek ;выход если номер потока не = 1
 631++8699              	; ld a,(f_r_flag)
 632++8699              	; or a
 633++8699              	; jr nz,fread_chek ;файл уже открыт?
 634++8699              ; fread_no_chek ;выход с ошибкой
 635++8699              	; xor a
 636++8699              	; scf ;флаг ошибки
 637++8699              	; ld bc,0 ;ничего мы не считали
 638++8699              	; ret
 639++8699
 640++8699              ; fread_chek
 641++8699              	; ld bc,(f_r_len_sec-1) ;загружаем файл целиком, не смотря на то, сколько байт было запрошено
 642++8699                  ; ld      c,5 ;read читаем целыми секторами
 643++8699              	; ld de,(f_r_cur_trk)
 644++8699                  ; call    call3d13
 645++8699              	; ld bc,(f_r_len) ;возвратим сколько считали байт (длину файла)
 646++8699              	; xor a ;флаги сбросим
 647++8699                  ; ret
 648++8699
 649++8699              ; A - file stream id
 650++8699              ; BC - length
 651++8699              ; HL - buffer
 652++8699              ; Returns:
 653++8699              ;   BC - actually written bytes
 654++8699              fwrite: ;
 655++8699 59           	ld e,c ;сохранить длину
 656++869A 50           	ld d,b
 657++869B              	OS_FWRITE
 657++869B 0E 24       >    ld c,#24
 657++869D E7          >    rst #20
 658++869E C9           	ret
 659++869F
 660++869F                  ; push hl : pop ix
 661++869F                  ; esxCall ESX_FWRITE
 662++869F
 663++869F              	; push af
 664++869F              	; ld a,2
 665++869F              	; out (254),a
 666++869F
 667++869F              	; xor a
 668++869F              	; out (254),a
 669++869F              	; pop af
 670++869F
 671++869F              	; cp 2 ;id = 2?
 672++869F              	; jr z,fwrite_chek ;проверка id потока
 673++869F              	; cp 3 ;id = 3?
 674++869F              	; jr z,fwrite_chek_trd ;проверка id потока
 675++869F              	; cp 4 ;id = 4?
 676++869F              	; jp z,fwrite_chek_scl ;проверка id потока
 677++869F              	; cp 6 ;id = 6?
 678++869F              	; jp z,fwrite_chek_fat ;проверка id потока
 679++869F
 680++869F
 681++869F              ; fwrite_no_chek ;выход с ошибкой
 682++869F              	; ld a,1
 683++869F              	; ld (com_file_err_flag),a
 684++869F              	; xor a
 685++869F              	; scf ;флаг ошибки
 686++869F              	; ld bc,0 ;ничего мы не записали
 687++869F              	; ret
 688++869F
 689++869F              ; fwrite_chek ;запись произвольного типа файла (id=2)
 690++869F
 691++869F              	; ;не отличается от записи trd, пишется входящий поток на диск, отличия при открытии и закрытии файла
 692++869F
 693++869F
 694++869F
 695++869F
 696++869F
 697++869F              ; fwrite_chek_trd ;запись trd файла (разворачивание образа, id=3)
 698++869F              	; ; ld a,2
 699++869F              	; ; out (254),a
 700++869F
 701++869F              	; ; xor a
 702++869F              	; ; out (254),a
 703++869F              	; ld a,(f_w_flag)
 704++869F              	; or a
 705++869F              	; jr z,fwrite_no_chek ;файл уже открыт?
 706++869F              	; ld (temp_bc),bc ;длина
 707++869F              	; ld (temp_hl),hl ;адрес данных
 708++869F              	; ld a,b
 709++869F              	; or c
 710++869F              	; jr z,fwrite_no_chek ; если длина 0, то выход
 711++869F
 712++869F              	; ;защита от переполнения диска
 713++869F              	; ld de,(#5cf4)
 714++869F              	; ld a,d
 715++869F              	; cp #a0 ;последняя дорожка 160
 716++869F              	; jr nc,fwrite_no_chek
 717++869F
 718++869F              	; xor a
 719++869F              	; ld (sec_part),a ;обнулить переменные
 720++869F              	; ld (sec_shift2),a
 721++869F              	; ld (sec_shift2+1),a
 722++869F              	; ld (sec_shift_flag),a
 723++869F              	; ld (write_end_flag),a ;
 724++869F
 725++869F
 726++869F              	; ld a,(sec_shift)
 727++869F              	; or a
 728++869F              	; jr z,fwrite_trd3 ;если смещения нет, то первую часть пропустим
 729++869F
 730++869F
 731++869F              	; ld c,a
 732++869F              	; ld b,0
 733++869F              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 734++869F              	; add hl,bc
 735++869F
 736++869F              	; ld a,1
 737++869F              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 738++869F
 739++869F              	; ld a,h
 740++869F              	; or a
 741++869F              	; jr nz,fwrite_trd4
 742++869F              	; ld a,1
 743++869F              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 744++869F
 745++869F              ; fwrite_trd4
 746++869F              	; ld hl,sec_buf ;буфер последнего сектора
 747++869F              	; add hl,bc ;на этой точке остановились
 748++869F              	; ex de,hl
 749++869F              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 750++869F              	; ; ld a,c
 751++869F              	; ; or a
 752++869F              	; ; jr nz,fwrite_trd2
 753++869F              	; ; inc b ;коррекция
 754++869F              ; ; fwrite_trd2
 755++869F              	; ; ld c,a
 756++869F              	; xor a
 757++869F              	; sub c
 758++869F              	; ld c,a ;сколько осталось перенести до заполнения сектора
 759++869F              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 760++869F              	; ldir
 761++869F
 762++869F              	; ld a,(sec_shift_flag)
 763++869F              	; or a
 764++869F              	; jr nz,fwrite_trd3 ;если сектор ещё не заполнен писать не будем
 765++869F
 766++869F              	; ld hl,sec_buf
 767++869F              	; ld de,(#5cf4)
 768++869F              	; ;ld (f_w_cur_trk),de	;запомним позицию
 769++869F                  ; ld      bc,#0106 ;пишем 1 сектор из буфера
 770++869F                  ; call    call3d13
 771++869F              	; ld a,c
 772++869F              	; cp 255
 773++869F              	; jp z,fwrite_no_chek ;выход если ошибка
 774++869F
 775++869F              	; xor a
 776++869F              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 777++869F              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 778++869F              	; ; ld (#5cf4),de
 779++869F              	; ; ld b,1 ;на сектор вперёд
 780++869F              	; ; ld de,(f_w_cur_trk)
 781++869F              	; ; call calc_next_pos
 782++869F              	; ; ld (f_w_cur_trk),de
 783++869F
 784++869F              ; fwrite_trd3
 785++869F              	; ld hl,(temp_hl) ;запишем остаток данных
 786++869F              	; ;ld a,(sec_shift)
 787++869F              	; ;ld c,a
 788++869F              	; ;ld b,0
 789++869F              	; ld bc,(sec_shift2)
 790++869F              	; add hl,bc ;с этой точки пишем
 791++869F              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 792++869F
 793++869F              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 794++869F              	; and a
 795++869F              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 796++869F              	; ld c,l
 797++869F              	; ld b,h
 798++869F              	; jr nc,fwrite_trd5
 799++869F              	; ld b,0 ;коррекция если вышел минус
 800++869F              ; fwrite_trd5
 801++869F              	; ld hl,(temp_hl)
 802++869F              	; add hl,bc
 803++869F
 804++869F              	; ld de,outputBuffer
 805++869F              	; and a
 806++869F              	; sbc hl,de
 807++869F
 808++869F              	; ld a,l
 809++869F              	; ld (sec_shift),a ;смещение на следующий раз
 810++869F              	; ;ld hl,(temp_hl)
 811++869F
 812++869F
 813++869F              	; ; or a
 814++869F              	; ; jr z,fwrite_trd1
 815++869F              	; ; inc b  ;коррекция количества секторов
 816++869F
 817++869F              	; ld a,b ;нужна проверка на количество секторов!!!
 818++869F              	; ld (sec_part),a ;запомним сколько секторов во второй части
 819++869F
 820++869F              	; ;ld a,b
 821++869F              	; or a
 822++869F              	; jr z,fwrite_trd1 ;если размер данных меньше сектора, то пропустим запись
 823++869F
 824++869F              	; ld hl,(temp_hl2)
 825++869F              	; ;push bc
 826++869F              	; ld de,(#5cf4)
 827++869F                  ; ld      c,6 ;пишем целыми секторами
 828++869F                  ; call    call3d13
 829++869F              	; ld a,c
 830++869F              	; ;pop bc
 831++869F              	; cp 255
 832++869F              	; jp z,fwrite_no_chek ;выход если ошибка
 833++869F              	; ; ld de,(f_w_cur_trk)
 834++869F              	; ; call calc_next_pos
 835++869F              	; ; ld (f_w_cur_trk),de
 836++869F
 837++869F              	; xor a
 838++869F              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 839++869F
 840++869F              ; fwrite_trd1
 841++869F              	; ld a,(write_end_flag) ;нужно записывать остаток?
 842++869F              	; or a
 843++869F              	; jr nz,fwrite_trd_ex ;не нужно
 844++869F
 845++869F              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
 846++869F              	; ld a,(sec_part)
 847++869F              	; ld b,a
 848++869F              	; ld c,0
 849++869F              	; add hl,bc
 850++869F              	; ld de,sec_buf
 851++869F              	; ld bc,256
 852++869F              	; ldir
 853++869F              ; ;fwrite_trd2
 854++869F
 855++869F
 856++869F              ; fwrite_trd_ex
 857++869F              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 858++869F              	; ;посчитаем общую длину записанного
 859++869F              	; ld hl,(f_w_len)
 860++869F              	; add hl,bc
 861++869F              	; ld (f_w_len),hl
 862++869F              	; jr nc,fwrite_trd_ex1
 863++869F              	; ld hl,(f_w_len+2)
 864++869F              	; inc hl
 865++869F              	; ld (f_w_len+2),hl
 866++869F
 867++869F              ; fwrite_trd_ex1
 868++869F              	; xor a ;флаги сбросим
 869++869F                  ; ret
 870++869F
 871++869F
 872++869F
 873++869F
 874++869F
 875++869F              ; ;------------------scl----------------------
 876++869F              ; fwrite_chek_scl ;запись scl файла (разворачивание образа, id=4)
 877++869F              	; ; ld a,2
 878++869F              	; ; out (254),a
 879++869F
 880++869F              	; ; xor a
 881++869F              	; ; out (254),a
 882++869F              	; ld a,(f_w_flag)
 883++869F              	; or a
 884++869F              	; jp z,fwrite_no_chek ;файл уже открыт?
 885++869F              	; ld (temp_bc),bc ;длина
 886++869F              	; ld (temp_hl),hl ;адрес данных
 887++869F              	; ld a,b
 888++869F              	; or c
 889++869F              	; jp z,fwrite_no_chek ; если длина 0, то выход
 890++869F
 891++869F              	; ; ld a,b
 892++869F              	; ; or a
 893++869F              	; ; jr nz,testt1
 894++869F              	; ; nop
 895++869F
 896++869F              ; ; testt1
 897++869F
 898++869F              	; xor a
 899++869F              	; ld (sec_part),a ;обнулить переменные
 900++869F              	; ld (sec_shift2),a
 901++869F              	; ld (sec_shift2+1),a
 902++869F              	; ld (sec_shift_flag),a
 903++869F              	; ld (write_end_flag),a ;
 904++869F
 905++869F
 906++869F              	; ld a,(sec_shift)
 907++869F              	; or a
 908++869F              	; jr z,fwrite_scl3 ;если смещения нет, то первую часть пропустим
 909++869F
 910++869F
 911++869F              	; ld c,a
 912++869F              	; ld b,0
 913++869F              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 914++869F              	; add hl,bc
 915++869F
 916++869F              	; ld a,1
 917++869F              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 918++869F
 919++869F              	; ld a,h
 920++869F              	; or a
 921++869F              	; jr nz,fwrite_scl4
 922++869F              	; ld a,1
 923++869F              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 924++869F
 925++869F              ; fwrite_scl4
 926++869F              	; ld hl,sec_buf ;буфер последнего сектора
 927++869F              	; add hl,bc ;на этой точке остановились
 928++869F              	; ex de,hl
 929++869F              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 930++869F              	; ; ld a,c
 931++869F              	; ; or a
 932++869F              	; ; jr nz,fwrite_scl2
 933++869F              	; ; inc b ;коррекция
 934++869F              ; ; fwrite_scl2
 935++869F              	; ; ld c,a
 936++869F              	; xor a
 937++869F              	; sub c
 938++869F              	; ld c,a ;сколько осталось перенести до заполнения сектора
 939++869F              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 940++869F              	; ldir
 941++869F
 942++869F              	; ld a,(sec_shift_flag)
 943++869F              	; or a
 944++869F              	; jr nz,fwrite_scl3 ;если сектор ещё не заполнен писать не будем
 945++869F
 946++869F              	; ld hl,sec_buf
 947++869F              	; ;ld de,(#5cf4)
 948++869F              	; ;ld (f_w_cur_trk),de	;запомним позицию
 949++869F                  ; ld      b,#01 ;пишем 1 сектор из буфера
 950++869F                  ; call    scl_write_buf
 951++869F              	; ; ld a,c
 952++869F              	; ; cp 255
 953++869F              	; ; jp z,fwrite_no_chek ;выход если ошибка
 954++869F
 955++869F              	; xor a
 956++869F              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 957++869F              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 958++869F              	; ; ld (#5cf4),de
 959++869F              	; ; ld b,1 ;на сектор вперёд
 960++869F              	; ; ld de,(f_w_cur_trk)
 961++869F              	; ; call calc_next_pos
 962++869F              	; ; ld (f_w_cur_trk),de
 963++869F
 964++869F              ; fwrite_scl3
 965++869F              	; ld hl,(temp_hl) ;запишем остаток данных
 966++869F              	; ;ld a,(sec_shift)
 967++869F              	; ;ld c,a
 968++869F              	; ;ld b,0
 969++869F              	; ld bc,(sec_shift2)
 970++869F              	; add hl,bc ;с этой точки пишем
 971++869F              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 972++869F
 973++869F              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 974++869F              	; and a
 975++869F              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 976++869F              	; ld c,l
 977++869F              	; ld b,h
 978++869F              	; jr nc,fwrite_scl5
 979++869F              	; ld b,0 ;коррекция если вышел минус
 980++869F              ; fwrite_scl5
 981++869F              	; ld hl,(temp_hl)
 982++869F              	; add hl,bc
 983++869F
 984++869F              	; ld de,outputBuffer
 985++869F              	; and a
 986++869F              	; sbc hl,de
 987++869F
 988++869F              	; ld a,l
 989++869F              	; ld (sec_shift),a ;смещение на следующий раз
 990++869F              	; ;ld hl,(temp_hl)
 991++869F
 992++869F
 993++869F              	; ; or a
 994++869F              	; ; jr z,fwrite_scl1
 995++869F              	; ; inc b  ;коррекция количества секторов
 996++869F
 997++869F              	; ld a,b ;нужна проверка на количество секторов!!!
 998++869F              	; ld (sec_part),a ;запомним сколько секторов во второй части
 999++869F
1000++869F              	; ;ld a,b
1001++869F              	; or a
1002++869F              	; jr z,fwrite_scl1 ;если размер данных меньше сектора, то пропустим запись
1003++869F
1004++869F              	; ld hl,(temp_hl2)
1005++869F              	; ;push bc
1006++869F              	; ;ld de,(#5cf4)
1007++869F                  ; ;ld      c,6 ;пишем целыми секторами
1008++869F                  ; call    scl_write_buf
1009++869F              	; ;ld a,c
1010++869F              	; ;pop bc
1011++869F              	; ; cp 255
1012++869F              	; ; jp z,fwrite_no_chek ;выход если ошибка
1013++869F              	; ; ld de,(f_w_cur_trk)
1014++869F              	; ; call calc_next_pos
1015++869F              	; ; ld (f_w_cur_trk),de
1016++869F
1017++869F              	; xor a
1018++869F              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
1019++869F
1020++869F              ; fwrite_scl1
1021++869F              	; ld a,(write_end_flag) ;нужно записывать остаток?
1022++869F              	; or a
1023++869F              	; jr nz,fwrite_scl_ex ;не нужно
1024++869F
1025++869F              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
1026++869F              	; ld a,(sec_part)
1027++869F              	; ld b,a
1028++869F              	; ld c,0
1029++869F              	; add hl,bc
1030++869F              	; ld de,sec_buf
1031++869F              	; ld bc,256
1032++869F              	; ldir
1033++869F              ; ;fwrite_scl2
1034++869F
1035++869F
1036++869F              ; fwrite_scl_ex
1037++869F              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1038++869F              	; ;посчитаем общую длину записанного
1039++869F              	; ld hl,(f_w_len)
1040++869F              	; add hl,bc
1041++869F              	; ld (f_w_len),hl
1042++869F              	; jr nc,fwrite_scl_ex1
1043++869F              	; ld hl,(f_w_len+2)
1044++869F              	; inc hl
1045++869F              	; ld (f_w_len+2),hl
1046++869F
1047++869F              ; fwrite_scl_ex1
1048++869F              	; xor a ;флаги сбросим
1049++869F                  ; ret
1050++869F
1051++869F
1052++869F
1053++869F
1054++869F
1055++869F
1056++869F              ; scl_write_buf ;заполнение промежуточного буфера
1057++869F              	; push bc ;сколько пакетов указано в b
1058++869F              	; ld de,scl_buf ;перенесём сектор во временный буфер
1059++869F              	; ld bc,256
1060++869F              	; ldir
1061++869F              	; ld (scl_temp_hl2),hl ;сохраним адрес данных
1062++869F              	; ld a,(scl_que) ;проверим флаг что нужны данные
1063++869F              	; or a
1064++869F              	; jr z,scl_write_buf_ret ;не будем вызывать парсер если не нужны
1065++869F              	; ld hl,scl_write_buf_ret ;адрес возврата
1066++869F              	; push hl
1067++869F              	; ld hl,(scl_parse_ret_adr) ;адрес для продолжения основного цикла сборки
1068++869F              	; jp (hl) ;отдадим пакет 256 байт парсеру
1069++869F              ; scl_write_buf_ret
1070++869F              	; ld hl,(scl_temp_hl2)
1071++869F              	; pop bc
1072++869F              	; djnz scl_write_buf
1073++869F
1074++869F              	; ret
1075++869F
1076++869F
1077++869F
1078++869F              ; scl_parse ;разбор образа scl в trd, основной цикл
1079++869F              	; ;получить первый сектор
1080++869F              ; ;запрос порции данных по 256 байт
1081++869F              	; ld (scl_temp_hl),hl
1082++869F              	; ld (scl_temp_de),de
1083++869F              	; ld (scl_temp_bc),bc
1084++869F              	; ld a,1
1085++869F              	; ld (scl_que),a ;включим флаг что нужны данные
1086++869F              	; ld hl,scl_parse_ret ;сохраним адрес возврата
1087++869F              	; ld (scl_parse_ret_adr),hl
1088++869F              	; ret ;вернёмся для ожидания данных
1089++869F              ; scl_parse_ret
1090++869F              	; xor a
1091++869F              	; ld (scl_que),a
1092++869F              	; ld hl,(scl_temp_hl)
1093++869F              	; ld de,(scl_temp_de)
1094++869F              	; ld bc,(scl_temp_bc)
1095++869F
1096++869F              	; ld de,scl_buf ;проверка метки образа
1097++869F              	; ld hl,scl_sign
1098++869F              	; ld b,8
1099++869F              ; scl_parse_chk
1100++869F              	; ld a,(de)
1101++869F              	; cp (hl)
1102++869F              	; jr nz,scl_parse_chk_no
1103++869F              	; inc hl
1104++869F              	; inc de
1105++869F              	; djnz scl_parse_chk
1106++869F              	; jr scl_parse_chk_ok
1107++869F              ; scl_parse_chk_no ;если не совпало, значит плохой образ
1108++869F                  ; ld hl, scl_err
1109++869F                  ; call DialogBox.msgBox ;предуреждение
1110++869F              	; xor a
1111++869F              	; ld (scl_que),a ;выключим флаг что нужны данные
1112++869F              	; ld a,4 ;закроем файл
1113++869F              	; call fclose
1114++869F              	; ret
1115++869F              ; scl_parse_chk_ok ;сигнатура правильная
1116++869F
1117++869F              ; ;формирование каталога
1118++869F              	; ld a,(scl_buf+8)
1119++869F              	; ld (scl_files),a ;всего файлов
1120++869F              	; ld (scl_cat_cycl),a ;цикл
1121++869F              	; ld hl,scl_buf+9 ;адрес первого заголовка
1122++869F              	; ld de,cat_buf ;адрес формируемого каталога trd
1123++869F              ; scl_parse_cat2
1124++869F              	; ld b,14 ;14 байт одна запись
1125++869F              ; scl_parse_cat
1126++869F              	; ld a,(hl)
1127++869F              	; ld (de),a
1128++869F              	; inc de
1129++869F              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1130++869F              	; jr nz,scl_parse_cat1
1131++869F              	; ;тут пора запросить следующий сектор
1132++869F              ; ;запрос порции данных по 256 байт
1133++869F              	; ld (scl_temp_hl),hl
1134++869F              	; ld (scl_temp_de),de
1135++869F              	; ld (scl_temp_bc),bc
1136++869F              	; ld a,1
1137++869F              	; ld (scl_que),a ;включим флаг что нужны данные
1138++869F              	; ld hl,scl_parse_ret1 ;сохраним адрес возврата
1139++869F              	; ld (scl_parse_ret_adr),hl
1140++869F              	; ret ;вернёмся для ожидания данных
1141++869F              ; scl_parse_ret1
1142++869F              	; xor a
1143++869F              	; ld (scl_que),a
1144++869F              	; ld hl,(scl_temp_hl)
1145++869F              	; ld de,(scl_temp_de)
1146++869F              	; ld bc,(scl_temp_bc)
1147++869F
1148++869F              ; scl_parse_cat1
1149++869F              	; djnz scl_parse_cat
1150++869F              	; inc de
1151++869F              	; inc de
1152++869F              	; ld a,(scl_cat_cycl)
1153++869F              	; dec a
1154++869F              	; ld (scl_cat_cycl),a
1155++869F              	; jr nz,scl_parse_cat2
1156++869F
1157++869F              	; ld (scl_temp_hl),hl ;запомнить где остановились
1158++869F
1159++869F              ; ;подсчёт секторов и дорожек
1160++869F              	; push ix
1161++869F              	; ld a,(scl_files)
1162++869F              	; ld de,#0100 ;данные с первой дорожки
1163++869F              	; ld ix,cat_buf
1164++869F              	; ld (ix+14),e
1165++869F              	; ld (ix+15),d
1166++869F              	; ld hl,0 ;общее количество секторов
1167++869F              ; scl_cacl
1168++869F              	; ld (scl_cat_cycl),a ;цикл
1169++869F              	; ld a,(ix+13) ;длина файла в секторах
1170++869F              	; ld c,a
1171++869F              	; ld b,0
1172++869F              	; add hl,bc ;секторов
1173++869F
1174++869F              	; ld bc,16
1175++869F              	; add ix,bc
1176++869F              	; ld b,a
1177++869F              	; call calc_next_pos
1178++869F              	; ld a,(scl_cat_cycl)
1179++869F              	; cp 1
1180++869F              	; jr z,scl_cacl2 ;в последний раз пропусим
1181++869F              	; ld (ix+14),e
1182++869F              	; ld (ix+15),d
1183++869F              ; scl_cacl2
1184++869F              	; dec a
1185++869F              	; jr nz,scl_cacl
1186++869F              	; ;теперь узнаем первый свободный сектор
1187++869F              	; ld a,(ix+13) ;длина файла в секторах
1188++869F              	; ld c,a
1189++869F              	; ld b,0
1190++869F              	; add hl,bc
1191++869F              	; ; ld b,a
1192++869F              	; ; call calc_next_pos
1193++869F              	; ld (cat_buf+8*256+#e1),de ;Первый свободный сектор и дорожка на дискете
1194++869F              	; ld de,16*159
1195++869F              	; ex de,hl
1196++869F              	; and a
1197++869F              	; sbc hl,de
1198++869F              	; ld (cat_buf+8*256+#e5),hl ;Число свободных секторов на диске
1199++869F              	; pop ix
1200++869F
1201++869F
1202++869F
1203++869F              ; ;запись содержимого файлов
1204++869F              	; ld a,(scl_files) ;всего файлов
1205++869F              	; ld (scl_cat_cycl),a ;цикл
1206++869F              	; ld hl,cat_buf+13 ;адрес размер секторов файла
1207++869F              	; ld (cat_cur_adr),hl
1208++869F
1209++869F              	; ld hl,#0100 ;начиная с первой дорожки
1210++869F              	; ld (#5cf4),hl
1211++869F              ; scl_parse_file2
1212++869F              	; ld hl,(scl_temp_hl) ;адрес данных
1213++869F              	; ld de,(cat_cur_adr) ;адрес сектор дорожка файла
1214++869F              	; ;dec de
1215++869F              	; ld a,(de) ;количество секторов, цикл
1216++869F              	; ld c,a
1217++869F              ; scl_parse_file3
1218++869F              	; ld de,scl_buf2 ;адрес ещё одного буфера
1219++869F              	; ld b,0 ;256 байт один сектор, цикл
1220++869F              ; scl_parse_file
1221++869F              	; ld a,(hl)
1222++869F              	; ld (de),a
1223++869F              	; inc de
1224++869F              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1225++869F              	; jr nz,scl_parse_file1
1226++869F              	; ;тут пора запросить следующий сектор
1227++869F              ; ;запрос порции данных по 256 байт
1228++869F              	; ld (scl_temp_hl),hl
1229++869F              	; ld (scl_temp_de),de
1230++869F              	; ld (scl_temp_bc),bc
1231++869F              	; ld a,1
1232++869F              	; ld (scl_que),a ;включим флаг что нужны данные
1233++869F              	; ld hl,scl_parse_ret2 ;сохраним адрес возврата
1234++869F              	; ld (scl_parse_ret_adr),hl
1235++869F              	; ret ;вернёмся для ожидания данных
1236++869F              ; scl_parse_ret2
1237++869F              	; xor a
1238++869F              	; ld (scl_que),a
1239++869F              	; ld hl,(scl_temp_hl)
1240++869F              	; ld de,(scl_temp_de)
1241++869F              	; ld bc,(scl_temp_bc)
1242++869F
1243++869F              ; scl_parse_file1
1244++869F              	; djnz scl_parse_file
1245++869F              	; ld (scl_temp_hl),hl
1246++869F              	; ld (scl_temp_bc),bc
1247++869F
1248++869F              	; ld hl,scl_buf2 ;;запишем один сектор
1249++869F              	; ld  de,(#5cf4)
1250++869F                  ; ld      bc,#0106 ;
1251++869F                  ; call    call3d13
1252++869F              	; ; ld a,c
1253++869F              	; ; cp 255
1254++869F              	; ; jp z,fwrite_no_chek ;выход если ошибка
1255++869F              	; ld hl,(scl_temp_hl)
1256++869F              	; ld bc,(scl_temp_bc)
1257++869F
1258++869F              	; dec c
1259++869F              	; jr nz,scl_parse_file3
1260++869F
1261++869F              	; ld hl,(cat_cur_adr) ;адрес сектор дорожка файла
1262++869F              	; ; ld e,(hl)
1263++869F              	; ; inc hl
1264++869F              	; ; ld d,(hl)
1265++869F              	; ld bc,16
1266++869F              	; add hl,bc ;на следующий файл
1267++869F              	; ld (cat_cur_adr),hl
1268++869F
1269++869F
1270++869F              	; ld a,(scl_cat_cycl)
1271++869F              	; dec a
1272++869F              	; ld (scl_cat_cycl),a
1273++869F              	; jr nz,scl_parse_file2	;на следующий файл
1274++869F
1275++869F
1276++869F
1277++869F              ; ;формирование системного сектора №9 (8)
1278++869F              	; ;
1279++869F              	; ;ld (cat_buf+8*256+#e1),a ;// #E1 Первый свободный сектор на дискете
1280++869F              	; ;
1281++869F              	; ;ld (cat_buf+8*256+#e2),a ;// #E2 Первый свободный трек
1282++869F              	; ld a,#16
1283++869F              	; ld (cat_buf+8*256+#e3),a ;// #E3 16 80 дорожек, 2 стороны
1284++869F              	; ld a,(scl_files)
1285++869F              	; ld (cat_buf+8*256+#e4),a ;// #E4 Общее количество файлов записанных на диск
1286++869F              	; ;
1287++869F              	; ;ld (cat_buf+8*256+#e5),a ;// #Е5,Е6 Число свободных секторов на диске
1288++869F              	; ;ld (cat_buf+8*256+#e6),a
1289++869F              	; ld a,#10
1290++869F              	; ld (cat_buf+8*256+#e7),a ;// #E7 Код  #10,определяющий принадлежность к TR-DOS
1291++869F
1292++869F              	; ld hl,f_name ;запишем имя диска, взяв для этого имя файла
1293++869F              	; ld de,cat_buf+8*256+#f5 ;// #F5-#FC Имя диска в ASCII формате
1294++869F              	; ld bc,8
1295++869F              	; ldir
1296++869F
1297++869F              	; ld hl,cat_buf ;запишем каталог на диск
1298++869F              	; ld de,0
1299++869F                  ; ld      bc,#0906 ;
1300++869F                  ; call    call3d13
1301++869F              	; ; ld a,c
1302++869F              	; ; cp 255
1303++869F              	; ; jp z,fwrite_no_chek ;выход если ошибка
1304++869F              	; ret
1305++869F
1306++869F
1307++869F              ; ;-----------scl end --------------------
1308++869F
1309++869F
1310++869F
1311++869F              ; ;---------------------------------------
1312++869F              ; fwrite_chek_fat ;запись файла fat
1313++869F              	; ld (temp_bc),bc ;длина
1314++869F              	; ld a,c ;младший байт длины
1315++869F              	; ld	de,fcb
1316++869F              	; R8FAT r8f09_FileWrite	;записать в файл
1317++869F              	; jp 	c,fwrite_no_chek
1318++869F
1319++869F              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1320++869F              	; ;посчитаем общую длину записанного
1321++869F              	; ld hl,(f_w_len)
1322++869F              	; add hl,bc
1323++869F              	; ld (f_w_len),hl
1324++869F              	; jr nc,fwrite_fat_ex1
1325++869F              	; ld hl,(f_w_len+2)
1326++869F              	; inc hl
1327++869F              	; ld (f_w_len+2),hl
1328++869F              ; fwrite_fat_ex1
1329++869F              	; xor a ;флаги сбросим
1330++869F              	; ret
1331++869F              ;---------------------------------------
1332++869F
1333++869F
1334++869F
1335++869F              ; A - file stream id
1336++869F              ; fsync:
1337++869F              ;     esxCall ESX_FSYNC
1338++869F                  ; ret
1339++869F
1340++869F
1341++869F              ; ; HL - name (name.ext)
1342++869F              ; ; Returns:
1343++869F              ; ; HL - name (name    e)
1344++869F              ; format_name ;подгоняет имя файла под стандарт trdos (8+1)
1345++869F
1346++869F              	; ;сначала попробуем убрать из пути подпапку, если она есть
1347++869F              	; ld (temp_hl),hl ;сохраним адрес исходного имени
1348++869F              	; ld b,#00 ;не больше 255 символов
1349++869F              ; format_name5
1350++869F              	; ld a,(hl)
1351++869F              	; cp "/" ;если есть подпапка
1352++869F              	; jr z,format_name_path_yep
1353++869F              	; ld a,(hl)
1354++869F              	; cp "." ;если ещё не дошли до расширения
1355++869F              	; jr nz,format_name6
1356++869F              	; ld hl,(temp_hl) ;если дошли до расширения, то путей нет, вернёмся на начало имени
1357++869F              	; jr format_name_7 ;на выход
1358++869F              ; format_name6
1359++869F              	; inc hl
1360++869F              	; djnz format_name5
1361++869F
1362++869F              ; format_name_path_yep ;нашли
1363++869F              	; inc hl ;пропустим знак "/"
1364++869F
1365++869F              ; format_name_7
1366++869F
1367++869F              	; push hl ;очистим место для нового имени
1368++869F              	; ld hl,f_name
1369++869F              	; ld de,f_name+1
1370++869F              	; ld (hl)," "
1371++869F              	; ld bc,8+1
1372++869F              	; ldir
1373++869F              	; ld (hl),0
1374++869F              	; ld bc,16-8-1-1
1375++869F              	; ldir
1376++869F              	; pop hl
1377++869F
1378++869F              	; ld bc,#09ff ;длина имени 9 символов
1379++869F              	; ld de,f_name ;куда
1380++869F              ; format_name2
1381++869F              	; ld a,(hl)
1382++869F              	; cp "."
1383++869F              	; jr nz,format_name1
1384++869F              	; ld de,f_name+8
1385++869F              	; inc hl
1386++869F              	; ldi ; и в конце расширение 3 буквы
1387++869F              	; ldi
1388++869F              	; ldi
1389++869F              	; ;ex de,hl ;сохраним адрес исходного расширения
1390++869F              	; jr format_name_e
1391++869F              ; format_name1
1392++869F              	; ldi
1393++869F              	; djnz format_name2
1394++869F
1395++869F              	; ;если имя длинное, пропустим лишнее до расширения
1396++869F              	; ld b,#00 ;не больше 255 символов
1397++869F              ; format_name3
1398++869F              	; ld a,(hl)
1399++869F              	; cp "."
1400++869F              	; jr nz,format_name4
1401++869F              	; ld de,f_name+8
1402++869F              	; inc hl
1403++869F              	; ldi ; и в конце расширение 3 буквы
1404++869F              	; ldi
1405++869F              	; ldi
1406++869F              	; ;ex de,hl ;сохраним адрес исходного расширения
1407++869F              	; jr format_name_e
1408++869F              ; format_name4
1409++869F              	; inc hl
1410++869F              	; djnz format_name3
1411++869F
1412++869F              ; format_name_e ;выход
1413++869F              	; ld hl,f_name ;вернём результат
1414++869F              	; ret
1415++869F
1416++869F              ; ; DE - trk/sec
1417++869F              ; ; B - sectors step
1418++869F              ; ; Returns:
1419++869F              ; ; DE - trk/sec
1420++869F              ; calc_next_pos		;вперёд на N секторов
1421++869F              			; ;ld b,4
1422++869F              			; ;ld  de,(#5ceb)
1423++869F              ; calc_next_pos2
1424++869F              			; inc e
1425++869F              			; ld a,e
1426++869F              			; cp 16
1427++869F              			; jr c,calc_next_pos1
1428++869F              			; inc d
1429++869F              			; ld e,0
1430++869F              ; calc_next_pos1
1431++869F              			; ;ld (#5ceb),de
1432++869F              			; djnz calc_next_pos2
1433++869F              			; ret
1434++869F
1435++869F
1436++869F              ; ;testt db "123.trd"
1437++869F              ; write_ima db "Select disk "
1438++869F              ; write_ima_d db "A: (A-" ;текущая буква
1439++869F              ; write_ima_e	db "D). " ;последняя буква
1440++869F              		; db "All data may be lost! Press Y or N.",0
1441++869F              ; ;prev_drive db 0 ;предыдущий номер дисковода
1442++869F              ; curr_drive db 0 ;текущий диск
1443++869F
1444++869F              ; trdExt1 db ".trd", 0
1445++869F              ; trdExt2 db ".TRD", 0
1446++869F
1447++869F              ; sclExt1 db ".scl", 0
1448++869F              ; sclExt2 db ".SCL", 0
1449++869F
1450++869F              ;f_name ds 16 ;имя файла
1451++869F              ; f_r_cur_trk dw 	 0 ;текущие сектор-дорожка файла на чтение
1452++869F              ; f_r_len_sec db 0 ;длина файла на чтение в секторах
1453++869F              ; f_r_len dw 0;длина файла в байтах
1454++869F              ; f_r_flag db 0 ;флаг что открыт файл на чтение
1455++869F
1456++869F              ; f_w_cur_trk dw 	 0 ;текущие сектор-дорожка файла на запись
1457++869F              ; f_w_len_sec db 0 ;длина файла на запись в секторах
1458++869F              ; f_w_flag db 0 ;флаг что открыт файл на запись
1459++869F              ; f_w_len ds 4 ;длина записанных данных
1460++869F              ; write_end_flag db 0 ;флаг что нужно записать остаток
1461++869F
1462++869F              ; temp_bc dw 0 ;хранение регистра
1463++869F              ;temp_hl dw 0 ;хранение регистра
1464++869F              ; temp_hl2 dw 0 ;хранение регистра
1465++869F
1466++869F              ; sec_shift db 0 ;указатель на каком байте остановлена запись
1467++869F              ; sec_shift2 db 0 ;указатель на каком байте остановлена запись (остаток)
1468++869F              ; sec_part db 0 ;сколько секторов во второй порции для записи
1469++869F              ; sec_shift_flag db 0 ;флаг что буфер сектора не заполнен
1470++869F
1471++869F              ; ;секция scl
1472++869F              ; scl_sign db "SINCLAIR" ;метка
1473++869F              ; scl_que db 0 ;флаг запроса порции данных
1474++869F              ; scl_err db "SCL image error!",0
1475++869F              ; scl_parse_ret_adr dw 0; адрес возврата в цикл
1476++869F              ; scl_cat_cycl db 0 ;переменная цикла
1477++869F              ; scl_files db 0 ;всего файлов
1478++869F              ; scl_temp_hl dw 0;;хранение регистра
1479++869F              ; scl_temp_hl2 dw 0;
1480++869F              ; scl_temp_de dw 0;
1481++869F              ; scl_temp_bc dw 0;
1482++869F              ; cat_cur_adr dw 0;
1483++869F              ; ;scl end
1484++869F
1485++869F              ; ;секция сохранения любого файла
1486++869F              ; file_err db "Not enough space!",0
1487++869F              ; sec_cat db 0 ;сектор каталога
1488++869F              ; file_num db "0" ;номер части для больших файлов
1489++869F
1490++869F              	; ;по адресу #4000 шрифт
1491++869F              ; cat_buf equ #4800 ;буфер для кататога диска 9*256
1492++869F              ; sec_buf equ cat_buf + 9*256 ;буфер сектора для записи 256
1493++869F              ; scl_buf equ sec_buf + 512 ;промежуточный буфер 256
1494++869F              ; scl_buf2 equ scl_buf + 512 ;промежуточный буфер 256
1495++869F              ; ;общая ошибка с файлами
1496++869F              ; com_file_err db "File error!",0
1497++869F              ; com_file_err_flag db 0 ;общая ошибка
1498++869F
1499++869F
1500++869F
1501++869F
1502++869F              ; ;Раздел SMUC и SD ------------------------------------
1503++869F
1504++869F
1505++869F              ; ;список доступных разделов на винчестерах
1506++869F              ; ;7,=0/1 тип раздела MFS/FAT
1507++869F              ; ;6,=1 раздел есть
1508++869F              ; ;3,=0/1 Hdd/SD card
1509++869F              ; ;2,=0/1 для HDD master/slave
1510++869F              ; ;0..1,=?? номер раздела
1511++869F              ; ;
1512++869F              ; typeDrive	ds 3*4+1
1513++869F              ; ;typeDriveFAT	ds 3*4+1 ;список всех разделов FAT
1514++869F              ; numDrives db 0 ;количество устройств
1515++869F              ; ;numDrivesFAT db 0 ;количество устройств FAT
1516++869F              ; next_lett db 0 ;следующая свободная буква диска
1517++869F
1518++869F              ; ;подсчет количества доступных разделов на всех устройствах
1519++869F              ; ;вых: hl,a - количество устройств
1520++869F              ; ;     typeDrives - сформированная таблица
1521++869F              ; ;     cy=1 не обнаружено ни одного устройства
1522++869F              ; ;
1523++869F              ; GetNumPart
1524++869F              ; ;
1525++869F              	; push	de
1526++869F              	; push	bc
1527++869F              	; ld	hl,typeDrive
1528++869F              	; push	hl
1529++869F              	; xor	a
1530++869F              	; call	proc_01			;HDD master
1531++869F              	; ld	a,#01
1532++869F              	; call	proc_01			;HDD slave
1533++869F              	; ld	a,#02
1534++869F              	; call	proc_01			;SD card
1535++869F              	; pop	de
1536++869F              	; or	a
1537++869F              	; sbc	hl,de			;количество разделов на HDD
1538++869F              	; IFDEF	useTRD
1539++869F              	 ; ld	a,l
1540++869F              	 ; add	a,#04
1541++869F              	 ; ld	l,a
1542++869F              	; ELSE
1543++869F              	 ; ld	a,l
1544++869F              	; ENDIF
1545++869F              	; pop	bc
1546++869F              	; pop	de
1547++869F              	; ld	(numDrives),a
1548++869F              	; cp	1
1549++869F              	; ret
1550++869F
1551++869F              ; ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1552++869F              ; ;формирование таблицы с доступными разделами на винчестере
1553++869F              ; ;вх:  a =#00 выбрать master
1554++869F              ; ;       =#01 выбрать slave
1555++869F              ; ;       =#02 выбрать SD card
1556++869F              ; ;     hl - адрес в таблице разделов typeDrives
1557++869F              ; ;вых: hl - новый адрес в таблице разделов typeDrives
1558++869F              ; ;
1559++869F              ; proc_01	ld	c,a
1560++869F              	; push	hl
1561++869F              	; push	bc
1562++869F              	; R8DOS	r8d2E_CngHDD
1563++869F              	; jr	c,goto001		;на текущем канале нет винчестера
1564++869F              	; R8DOS	r8d2D_FindPart
1565++869F              ; goto001	pop	bc
1566++869F              	; pop	hl
1567++869F              	; ret	c			;на текущем винчестере нет разделов
1568++869F              	; ld	b,a
1569++869F              	; ld	a,c
1570++869F              	; add	a,a
1571++869F              	; add	a,a
1572++869F              	; ld	c,a			;номер винчестера и первого раздела
1573++869F              	; ld	a,b
1574++869F              	; ld	b,#04
1575++869F              ; loop001	ld	(hl),#00
1576++869F              	; rra
1577++869F              	; jr	nc,goto002		;нет раздела
1578++869F              	; IFDEF	useMFS
1579++869F              	 ; ld	(hl),c
1580++869F              	 ; set	6,(hl)			;=%01???hpp MFS
1581++869F              	 ; rra
1582++869F              	 ; jr	nc,goto003		;это MFS
1583++869F              	 ; set	7,(hl)			;=%11???hpp это FAT
1584++869F              	; ELSE
1585++869F              	 ; rra
1586++869F              	 ; jr	nc,goto004		;это MFS
1587++869F              	 ; ld	(hl),c
1588++869F              	 ; set	6,(hl)			;раздел есть
1589++869F              	 ; set	7,(hl)			;=%11???hpp это FAT
1590++869F              	; ENDIF
1591++869F              ; goto003	inc	hl
1592++869F              	; rla
1593++869F              ; goto002	rra
1594++869F              ; goto004	inc	c
1595++869F              	; djnz	loop001
1596++869F              	; ret
1597++869F
1598++869F
1599++869F
1600++869F              ; hdd_init_flag: db 0 ;флаг инициализации
1601++869F              ; ;fcb_tmp ds 32 ;буфер fcb временно
1602++869F              ; ActPathFAT db "\\Download",0 ;папка для сохранений
1603++869F              ; fcb ds 32	;буфер fcb
1604++869F              	; nop
1605++869F              ; ;конец секции SMUC и SD ----------------------------
1606++869F
1607++869F
1608++869F
1609++869F                  ENDMODULE
# file closed: dos/zsfat.asm
   9+ 869F              	ENDIF
  10+ 869F                  include "console.asm"
# file opened: dos/console.asm
   1++869F                  module Console
   2++869F              KEY_UP = 11
   3++869F              KEY_DN = 10
   4++869F              KEY_LT = 8
   5++869F              KEY_RT = 9
   6++869F              BACKSPACE = 12
   7++869F 00           keyCode db 0
   8++86A0
   9++86A0              ;BASIC_KEY = #5C08
  10++86A0
  11++86A0              waitForKeyUp:
  12++86A0 76           	halt
  13++86A1              	OS_GETCHAR
  13++86A1 0E 10       >    ld c,#10
  13++86A3 E7          >    rst #20
  14++86A4 FE FF           cp 255
  15++86A6 20 F8           jr nz, waitForKeyUp
  16++86A8
  17++86A8                 ; ld (BASIC_KEY), a
  18++86A8 C9              ret
  19++86A9
  20++86A9              getC:
  21++86A9 76           	halt
  22++86AA              	OS_GETCHAR
  22++86AA 0E 10       >    ld c,#10
  22++86AC E7          >    rst #20
  23++86AD                 ;ld a,(BASIC_KEY)
  24++86AD                 ;and a : jr z, getC
  25++86AD FE FF           cp 255
  26++86AF 28 F8           jr z, getC
  27++86B1                 ;ld b,a
  28++86B1                 ;xor a : ld (BASIC_KEY), a
  29++86B1                 ;ld a, b
  30++86B1 C9              ret
  31++86B2
  32++86B2              peekC:
  33++86B2              	OS_GETCHAR
  33++86B2 0E 10       >    ld c,#10
  33++86B4 E7          >    rst #20
  34++86B5                  ;xor a: ld (BASIC_KEY),a
  35++86B5                  ;call inkey
  36++86B5 C9               ret
  37++86B6
  38++86B6              ; inkey:
  39++86B6                 ; ld de,0
  40++86B6                 ; ld bc,$fefe
  41++86B6                 ; in a,(c)
  42++86B6                 ; or $e1
  43++86B6                 ; cp $ff
  44++86B6                 ; jr nz, .keyhitA
  45++86B6
  46++86B6                 ; ld e,5
  47++86B6                 ; ld b,$fd
  48++86B6                 ; in a,(c)
  49++86B6                 ; or $e0
  50++86B6                 ; cp $ff
  51++86B6                 ; jr nz, .keyhitA
  52++86B6
  53++86B6                 ; ld e,10
  54++86B6                 ; ld b,$fb
  55++86B6                 ; in a,(c)
  56++86B6                 ; or $e0
  57++86B6                 ; cp $ff
  58++86B6                 ; jr nz, .keyhitA
  59++86B6
  60++86B6                 ; ld e,15
  61++86B6                 ; ld b,$f7
  62++86B6                 ; in a,(c)
  63++86B6                 ; or $e0
  64++86B6                 ; cp $ff
  65++86B6                 ; jr nz, .keyhitA
  66++86B6
  67++86B6                 ; ld e,20
  68++86B6                 ; ld b,$ef
  69++86B6                 ; in a,(c)
  70++86B6                 ; or $e0
  71++86B6                 ; cp $ff
  72++86B6                 ; jr nz, .keyhitA
  73++86B6
  74++86B6                 ; ld e,25
  75++86B6                 ; ld b,$df
  76++86B6                 ; in a,(c)
  77++86B6                 ; or $e0
  78++86B6                 ; cp $ff
  79++86B6                 ; jr nz, .keyhitA
  80++86B6
  81++86B6                 ; ld e,30
  82++86B6                 ; ld b,$bf
  83++86B6                 ; in a,(c)
  84++86B6                 ; or $e0
  85++86B6                 ; cp $ff
  86++86B6                 ; jr nz, .keyhitA
  87++86B6
  88++86B6                 ; ld e,35
  89++86B6                 ; ld b,$7f
  90++86B6                 ; in a,(c)
  91++86B6                 ; or $e2
  92++86B6                 ; cp $ff
  93++86B6                 ; ld c,a
  94++86B6                 ; jr nz, .keyhitB
  95++86B6
  96++86B6              ; .nokey
  97++86B6                 ; xor a
  98++86B6                 ; ret
  99++86B6
 100++86B6              ; .keyhitA
 101++86B6
 102++86B6                 ; ld c,a
 103++86B6
 104++86B6                 ; ld a,b
 105++86B6                 ; cpl
 106++86B6                 ; or $81
 107++86B6                 ; in a,($fe)
 108++86B6                 ; or $e0
 109++86B6                 ; cp $ff
 110++86B6                 ; jr nz, .nokey
 111++86B6
 112++86B6                 ; ld a,$7f
 113++86B6                 ; in a,($fe)
 114++86B6                 ; or $e2
 115++86B6                 ; cp $ff
 116++86B6                 ; jr nz, .nokey
 117++86B6
 118++86B6              ; .keyhitB
 119++86B6
 120++86B6                 ; ld b,0
 121++86B6                 ; ld hl,.rowtbl-$e0
 122++86B6                 ; add hl,bc
 123++86B6                 ; ld a,(hl)
 124++86B6                 ; cp 5
 125++86B6                 ; jr nc, .nokey
 126++86B6                 ; add a,e
 127++86B6                 ; ld e,a
 128++86B6
 129++86B6                 ; ld hl,.table
 130++86B6                 ; add hl,de
 131++86B6
 132++86B6                 ; ld a,$fe
 133++86B6                 ; in a,($fe)
 134++86B6                 ; and $01
 135++86B6                 ; jr nz, .nocaps
 136++86B6                 ; ld e,40
 137++86B6                 ; add hl,de
 138++86B6
 139++86B6              ; .nocaps
 140++86B6
 141++86B6                 ; ld a,$7f
 142++86B6                 ; in a,($fe)
 143++86B6                 ; and $02
 144++86B6                 ; jr nz, .nosym
 145++86B6                 ; ld e,80
 146++86B6                 ; add hl,de
 147++86B6
 148++86B6              ; .nosym
 149++86B6
 150++86B6                 ; ld a,(hl)
 151++86B6                 ; ret
 152++86B6
 153++86B6              ; .rowtbl
 154++86B6                 ; defb 255,255,255,255,255,255,255
 155++86B6                 ; defb 255,255,255,255,255,255,255,255
 156++86B6                 ; defb 4,255,255,255,255,255,255
 157++86B6                 ; defb 255,3,255,255,255,2,255,1
 158++86B6                 ; defb 0,255
 159++86B6
 160++86B6              ; .table
 161++86B6                 ; db 0,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
 162++86B6                 ; db 'a','s','d','f','g'      ; A, S, D, F, G
 163++86B6                 ; db 'q','w','e','r','t'      ; Q, W, E, R, T
 164++86B6                 ; db '1','2','3','4','5'      ; 1, 2, 3, 4, 5
 165++86B6                 ; db '0','9','8','7','6'      ; 0, 9, 8, 7, 6
 166++86B6                 ; db 'p','o','i','u','y'      ; P, O, I, U, Y
 167++86B6                 ; db 13,'l','k','j','h'       ; ENTER, L, K, J, H
 168++86B6                 ; db ' ',0,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B
 169++86B6
 170++86B6                 ; ; the following are CAPS SHIFTed
 171++86B6
 172++86B6                 ; db 0,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
 173++86B6                 ; db 'A','S','D','F','G'      ; A, S, D, F, G
 174++86B6                 ; db 'Q','W','E','R','T'      ; Q, W, E, R, T
 175++86B6                 ; db 7,6,128,129,8            ; 1, 2, 3, 4, 5
 176++86B6                 ; db 12,0,9,11,10             ; 0, 9, 8, 7, 6
 177++86B6                 ; db 'P','O','I','U','Y'      ; P, O, I, U, Y
 178++86B6                 ; db 13,'L','K','J','H'       ; ENTER, L, K, J, H
 179++86B6                 ; db ' ',0,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B
 180++86B6
 181++86B6                 ; ; the following are SYM SHIFTed
 182++86B6
 183++86B6                 ; db 0,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
 184++86B6                 ; db '~','|',92,'{','}'       ; A, S, D, F, G
 185++86B6                 ; db 131,132,133,'<','>'      ; Q, W, E, R, T
 186++86B6                 ; db '!','@','#','$','%'      ; 1, 2, 3, 4, 5
 187++86B6                 ; db '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
 188++86B6                 ; db 34,';',130,']','['       ; P, O, I, U, Y
 189++86B6                 ; db 13,'=','+','-','^'       ; ENTER, L, K, J, H
 190++86B6                 ; db ' ',0,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B
 191++86B6
 192++86B6                 ; ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)
 193++86B6
 194++86B6                 ; db 0,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
 195++86B6                 ; db 1,19,4,6,7               ; A, S, D, F, G
 196++86B6                 ; db 17,23,5,18,20            ; Q, W, E, R, T
 197++86B6                 ; db 27,28,29,30,31           ; 1, 2, 3, 4, 5
 198++86B6                 ; db 127,0,134,'`',135      ; 0, 9, 8, 7, 6
 199++86B6                 ; db 16,15,9,21,25            ; P, O, I, U, Y
 200++86B6                 ; db 13,12,11,10,8            ; ENTER, L, K, J, H
 201++86B6                 ; db ' ',0,13,14,2          ; SPACE, SYM SHIFT, M, N, B
 202++86B6
 203++86B6                  endmodule
# file closed: dos/console.asm
# file closed: dos/index.asm
  19  86B6                  include "gopher/engine/history/index.asm"
# file opened: gopher/engine/history/index.asm
   1+ 86B6                  include "controler.asm"
# file opened: gopher/engine/history/controler.asm
   1++86B6                  module History
   2++86B6              back:
   3++86B6 3A EF 87         ld a, (depth)
   3++86B9 FE 01          cp 1
   3++86BB CA CD 86       jp z, load
   4++86BE 21 38 8B 11      ld hl, historyBlock + HistoryRecord, de, historyBlock, bc, (total - 1) * HistoryRecord
   4++86C2 F0 87 01 20
   4++86C6 0D
   4++86C7 ED B0          ldir ; Move history up
   5++86C9 21 EF 87         ld hl, depth
   5++86CC 35             dec (hl)
   6++86CD              ; Loads current resource
   7++86CD              load:
   8++86CD 21 EA 86         ld hl, .msg
   8++86D0 CD 30 86       call DialogBox.msgNoWait
   9++86D3 AF               xor a
   9++86D4 21 F1 A5 11    ld hl, outputBuffer, de, outputBuffer + 1
   9++86D8 F2 A5
  10++86DA 01 0D 5A         ld bc, #ffff - outputBuffer - 1
  11++86DD 77               ld (hl), a
  12++86DE ED B0            ldir
  13++86E0
  14++86E0 3A F0 87         ld a, (historyBlock.isFile)
  14++86E3 A7             and a
  14++86E4 C2 B5 9D       jp nz, Fetcher.fetchFromFS
  15++86E7 C3 68 9D         jp Fetcher.fetchFromNet
  16++86EA
  17++86EA 4C 6F 61 64  .msg db "Loading resource! Please wait! It will be here soon!", 0
  17++86EE 69 6E 67 20
  17++86F2 72 65 73 6F
  17++86F6 75 72 63 65
  17++86FA 21 20 50 6C
  17++86FE 65 61 73 65
  17++8702 20 77 61 69
  17++8706 74 21 20 49
  17++870A 74 20 77 69
  17++870E 6C 6C 20 62
  17++8712 65 20 68 65
  17++8716 72 65 20 73
  17++871A 6F 6F 6E 21
  17++871E 00
  18++871F
  19++871F              home:
  20++871F 21 D0 87         ld hl, homePage
  21++8722              ; HL - gopher row
  22++8722              navigate:
  23++8722 54 5D            ld de, hl
  24++8724 CD E1 9B         call UrlEncoder.isValidGopherRow
  25++8727 30 A4            jr nc, load ; Not valid - reload last
  26++8729 62 6B            ld hl, de
  27++872B E5               push hl
  28++872C
  29++872C E5               push hl
  30++872D 21 57 98 11      ld hl, HistoryEnd - HistoryRecord, de, HistoryEnd, bc,  HistoryRecord * total
  30++8731 9F 9B 01 68
  30++8735 10
  30++8736 ED B8          lddr
  31++8738
  32++8738 ED 5B 36 8B      ld de, (Render.position), (historyBlock.position + HistoryRecord), de
  32++873C ED 53 7E 8E
  33++8740                  ; Clean up struct
  34++8740 AF               xor a
  34++8741 21 F0 87 11    ld hl, historyBlock, de, historyBlock + 1, bc, historyBlockSize - 1, (hl), a
  34++8745 F1 87 01 47
  34++8749 03 77
  34++874B ED B0          ldir
  35++874D E1               pop hl
  36++874E
  37++874E                  ; Fill record
  38++874E 54 5D            ld de, hl
  39++8750 CD A0 9B         call UrlEncoder.isFile
  40++8753 EB               ex hl, de
  41++8754 11 F0 87         ld de, historyBlock
  42++8757 12               ld (de), a
  42++8758 13             inc de
  43++8759 7E               ld a, (hl)
  43++875A E5 D5          push hl, de
  43++875C CD 06 81       call Render.getIcon
  43++875F D1 E1          pop de, hl
  44++8761 12               ld (de), a
  44++8762 13             inc de
  45++8763 3E 09 01 FF      ld a, 9, bc, #fff
  45++8767 0F
  45++8768 ED B1          cpir
  46++876A              .locatorCopy
  47++876A 7E               ld a, (hl)
  47++876B FE 09          cp 9
  47++876D 28 05          jr z, 1f
  48++876F 12               ld (de), a
  48++8770 23 13          inc hl, de
  49++8772 18 F6            jr .locatorCopy
  50++8774              1
  51++8774 23               inc hl
  51++8775 AF             xor a
  51++8776 12             ld (de), a
  52++8777 11 F1 89         ld de, historyBlock.host
  53++877A              .hostCopy
  54++877A 7E               ld a, (hl)
  54++877B FE 09          cp 9
  54++877D 28 05          jr z, 1f
  55++877F 12               ld (de), a
  55++8780 23 13          inc hl, de
  56++8782 18 F6            jr .hostCopy
  57++8784              1
  58++8784 23               inc hl
  58++8785 AF             xor a
  58++8786 12             ld (de), a
  59++8787 11 31 8A         ld de, historyBlock.port
  60++878A              .portCopy
  61++878A 7E               ld a, (hl)
  62++878B FE 09            cp 9
  62++878D 28 11          jr z, 1f
  63++878F FE 0D            cp 13
  63++8791 28 0D          jr z, 1f
  64++8793 FE 0A            cp 10
  64++8795 28 09          jr z, 1f
  65++8797 FE 00            cp 0
  65++8799 28 05          jr z, 1f
  66++879B 12               ld (de), a
  66++879C 23 13          inc hl, de
  67++879E 18 EA            jr .portCopy
  68++87A0 AF           1   xor a
  68++87A1 12             ld (de), a
  69++87A2 21 D7 85 11      ld hl, DialogBox.inputBuffer, de, historyBlock.search, bc, #ff
  69++87A6 37 8A 01 FF
  69++87AA 00
  69++87AB ED B0          ldir
  70++87AD 11 00 00 ED      ld de, 0, (historyBlock.position), de
  70++87B1 53 36 8B
  71++87B4 E1               pop hl
  72++87B5 3A EF 87         ld a, (depth)
  72++87B8 FE 05          cp total
  72++87BA 30 04          jr nc, 1f
  73++87BC 3C               inc a
  73++87BD 32 EF 87       ld (depth), a
  74++87C0              1
  75++87C0 3A F1 87         ld a,(historyBlock.mediaType)
  75++87C3 FE 01          cp MIME_DOWNLOAD
  75++87C5 CA B8 9E       jp z, Gopher.download
  76++87C8
  77++87C8                  ifdef GS
  78++87C8 FE 07            cp MIME_MOD
  78++87CA CA 57 9E       jp z, Gopher.loadMod
  79++87CD                  endif
  80++87CD
  81++87CD C3 CD 86         jp load
  82++87D0
  83++87D0              homePage:
  84++87D0 31 48 6F 6D      db "1Home", TAB, "data/index.gph"
  84++87D4 65 09 64 61
  84++87D8 74 61 2F 69
  84++87DC 6E 64 65 78
  84++87E0 2E 67 70 68
  85++87E4 09 66 69 6C      db TAB, "file", TAB, "70", CR, LF, 0
  85++87E8 65 09 37 30
  85++87EC 0D 0A 00
  86++87EF                  endmodule
# file closed: gopher/engine/history/controler.asm
   2+ 87EF                  include "model.asm"
# file opened: gopher/engine/history/model.asm
   1++87EF              total   equ 5
   2++87EF 00           depth   db 0
   3++87F0
   4++87F0              historyBlock:
   5++87F0 00           .isFile    db  0
   6++87F1 00           .mediaType db  0
   7++87F2 00 00 00...  .locator   ds  #1ff
   8++89F1 00 00 00...  .host      ds  64
   9++8A31 00 00 00...  .port      ds  6
  10++8A37 00 00 00...  .search    ds  #ff
  11++8B36 00 00        .position  dw  #00
  12++8B38
  13++8B38              historyBlockSize = $ - historyBlock
  14++8B38
  15++8B38              HistoryRecord EQU $ - historyBlock
  16++8B38                  dup total
  17++8B38 00 00 00... >    ds HistoryRecord
  17++8E80 00 00 00... >    ds HistoryRecord
  17++91C8 00 00 00... >    ds HistoryRecord
  17++9510 00 00 00... >    ds HistoryRecord
  17++9858 00 00 00... >    ds HistoryRecord
  18++985C                  edup
  19++9BA0              HistoryEnd equ $ - 1
# file closed: gopher/engine/history/model.asm
# file closed: gopher/engine/history/index.asm
  20  9BA0                  include "gopher/engine/urlencoder.asm"
# file opened: gopher/engine/urlencoder.asm
   1+ 9BA0                  MODULE UrlEncoder
   2+ 9BA0              ; HL - pointer to line in gopher page
   3+ 9BA0              ; C - flag set when it's file
   4+ 9BA0              isFile:
   5+ 9BA0              .findServerLoop
   6+ 9BA0 7E               ld a, (hl)
   6+ 9BA1 A7             and a
   6+ 9BA2 28 3B          jr z, .notFile
   6+ 9BA4 23             inc hl
   7+ 9BA5 FE 0D            cp 13
   7+ 9BA7 28 36          jr z, .notFile
   8+ 9BA9 FE 09            cp 9
   8+ 9BAB 28 02          jr z, .skipPath
   9+ 9BAD 18 F1            jr .findServerLoop
  10+ 9BAF              .skipPath
  11+ 9BAF 7E               ld a, (hl)
  11+ 9BB0 A7             and a
  11+ 9BB1 28 2C          jr z, .notFile
  11+ 9BB3 23             inc hl
  12+ 9BB4 FE 0D            cp 13
  12+ 9BB6 28 27          jr z, .notFile
  13+ 9BB8 FE 09            cp 9
  13+ 9BBA 28 02          jr z, .compareServer
  14+ 9BBC 18 F1            jr .skipPath
  15+ 9BBE              .compareServer
  16+ 9BBE 7E               ld a, (hl)
  16+ 9BBF FE 66          cp "f"
  16+ 9BC1 20 1C          jr nz, .notFile
  16+ 9BC3 23             inc hl
  17+ 9BC4 7E               ld a, (hl)
  17+ 9BC5 FE 69          cp "i"
  17+ 9BC7 20 16          jr nz, .notFile
  17+ 9BC9 23             inc hl
  18+ 9BCA 7E               ld a, (hl)
  18+ 9BCB FE 6C          cp "l"
  18+ 9BCD 20 10          jr nz, .notFile
  18+ 9BCF 23             inc hl
  19+ 9BD0 7E               ld a, (hl)
  19+ 9BD1 FE 65          cp "e"
  19+ 9BD3 20 0A          jr nz, .notFile
  19+ 9BD5 23             inc hl
  20+ 9BD6 7E               ld a, (hl)
  20+ 9BD7 FE 09          cp 9
  20+ 9BD9 20 04          jr nz, .notFile
  20+ 9BDB 23             inc hl
  21+ 9BDC 3E 01            ld a, 1
  22+ 9BDE C9               ret
  23+ 9BDF              .notFile
  24+ 9BDF AF               xor a
  25+ 9BE0 C9               ret
  26+ 9BE1
  27+ 9BE1              ; Is enough fields to encode
  28+ 9BE1              ; HL - pointer to line in gopher page
  29+ 9BE1              ; C - flag set when there is enough fields
  30+ 9BE1              isValidGopherRow:
  31+ 9BE1 7E               ld a, (hl)
  31+ 9BE2 A7             and a
  31+ 9BE3 28 FA          jr z, isFile.notFile
  31+ 9BE5 23             inc hl
  32+ 9BE6 FE 0D            cp 13
  32+ 9BE8 28 F5          jr z, isFile.notFile
  33+ 9BEA FE 09            cp 9
  33+ 9BEC 28 02          jr z, .skipPath
  34+ 9BEE 18 F1            jr isValidGopherRow
  35+ 9BF0              .skipPath
  36+ 9BF0 7E               ld a, (hl)
  36+ 9BF1 A7             and a
  36+ 9BF2 28 EB          jr z, isFile.notFile
  36+ 9BF4 23             inc hl
  37+ 9BF5 FE 0D            cp 13
  37+ 9BF7 28 E6          jr z, isFile.notFile
  38+ 9BF9 FE 09            cp 9
  38+ 9BFB 28 02          jr z, .skipHost
  39+ 9BFD 18 F1            jr .skipPath
  40+ 9BFF              .skipHost
  41+ 9BFF 7E               ld a, (hl)
  41+ 9C00 A7             and a
  41+ 9C01 28 DC          jr z, isFile.notFile
  41+ 9C03 23             inc hl
  42+ 9C04 FE 0D            cp 13
  42+ 9C06 28 D7          jr z, isFile.notFile
  43+ 9C08 FE 09            cp 9
  43+ 9C0A 28 02           jr z, .isValid
  44+ 9C0C 18 F1            jr .skipHost
  45+ 9C0E              .isValid:
  46+ 9C0E 37               scf
  47+ 9C0F C9               ret
  48+ 9C10
  49+ 9C10              extractPath:
  50+ 9C10 21 F2 87 11      ld hl, historyBlock.locator, de, nameBuffer, bc, #ff
  50+ 9C14 28 9C 01 FF
  50+ 9C18 00
  50+ 9C19 ED B0          ldir
  51+ 9C1B C9               ret
  52+ 9C1C
  53+ 9C1C              extractHostName:
  54+ 9C1C 21 F1 89 11      ld hl, historyBlock.host, de, hostName, bc, 64
  54+ 9C20 28 9D 01 40
  54+ 9C24 00
  54+ 9C25 ED B0          ldir
  55+ 9C27 C9               ret
  56+ 9C28
  57+ 9C28                  ENDMODULE
  58+ 9C28
  59+ 9C28 00 00 00...  nameBuffer ds #ff, 0
  60+ 9D27
  61+ 9D27 00                    db 0
  62+ 9D28 00 00 00...  hostName ds 64
# file closed: gopher/engine/urlencoder.asm
  21  9D68                  include "gopher/engine/fetcher.asm"
# file opened: gopher/engine/fetcher.asm
   1+ 9D68                  MODULE Fetcher
   2+ 9D68
   3+ 9D68              fetchFromNet:
   4+ 9D68 CD 2C 9E         call Gopher.makeRequest
   4+ 9D6B 38 06          jr c, .error
   5+ 9D6D CD 44 9E         call Gopher.loadBuffer
   6+ 9D70 C3 C1 9D         jp MediaProcessor.processResource
   7+ 9D73              .error
   8+ 9D73 21 7C 9D         ld hl, .err
   8+ 9D76 CD 27 86       call DialogBox.msgBox
   9+ 9D79 C3 B6 86         jp History.back
  10+ 9D7C
  11+ 9D7C 44 6F 63 75  .err db "Document fetch error! Check your connection or hostname!", 0
  11+ 9D80 6D 65 6E 74
  11+ 9D84 20 66 65 74
  11+ 9D88 63 68 20 65
  11+ 9D8C 72 72 6F 72
  11+ 9D90 21 20 43 68
  11+ 9D94 65 63 6B 20
  11+ 9D98 79 6F 75 72
  11+ 9D9C 20 63 6F 6E
  11+ 9DA0 6E 65 63 74
  11+ 9DA4 69 6F 6E 20
  11+ 9DA8 6F 72 20 68
  11+ 9DAC 6F 73 74 6E
  11+ 9DB0 61 6D 65 21
  11+ 9DB4 00
  12+ 9DB5
  13+ 9DB5
  14+ 9DB5              fetchFromFS:
  15+ 9DB5 CD 10 9C         call UrlEncoder.extractPath
  16+ 9DB8              loadFile
  17+ 9DB8 21 28 9C         ld hl, nameBuffer
  18+ 9DBB CD 5E 86         call Dos.loadBuffer
  19+ 9DBE C3 C1 9D         jp MediaProcessor.processResource
  20+ 9DC1                  ENDMODULE
# file closed: gopher/engine/fetcher.asm
  22  9DC1                  include "gopher/engine/media-processor.asm"
# file opened: gopher/engine/media-processor.asm
   1+ 9DC1                  MODULE MediaProcessor
   2+ 9DC1              processResource:
   3+ 9DC1 CD 1C 9C         call UrlEncoder.extractHostName
   4+ 9DC4 3A F1 87         ld a, (historyBlock.mediaType)
   5+ 9DC7 FE 05            cp MIME_MUSIC
   5+ 9DC9 28 17          jr z, processPT
   6+ 9DCB FE 02            cp MIME_LINK
   6+ 9DCD 28 1F          jr z, processPage
   7+ 9DCF FE 04            cp MIME_INPUT
   7+ 9DD1 28 1B          jr z, processPage
   8+ 9DD3 FE 06            cp MIME_IMAGE
   8+ 9DD5 CA 21 A2       jp z, ScreenViewer.display
   9+ 9DD8              	ifdef GS
  10+ 9DD8 FE 07            cp MIME_MOD
  10+ 9DDA 28 0C          jr z, processMOD
  11+ 9DDC              	endif
  12+ 9DDC              ; Fallback to plain text
  13+ 9DDC              processText:
  14+ 9DDC CD E1 84         call Render.renderPlainTextScreen
  15+ 9DDF C3 1D 85         jp   Render.plainTextLoop
  16+ 9DE2
  17+ 9DE2              processPT:
  18+ 9DE2 CD 8C A1         call VortexProcessor.play
  19+ 9DE5 C3 B6 86         jp History.back
  20+ 9DE8
  21+ 9DE8                  ifdef GS
  22+ 9DE8              processMOD:
  23+ 9DE8 CD E0 A1         call ModProcessor.play
  24+ 9DEB C3 B6 86         jp History.back
  25+ 9DEE              	endif
  26+ 9DEE
  27+ 9DEE              processPage:
  28+ 9DEE 3A 81 85         ld a, (Render.play_next)
  28+ 9DF1 A7             and a
  28+ 9DF2 20 06          jr nz, .playNext
  29+ 9DF4 CD 85 83         call Render.renderGopherScreen
  30+ 9DF7 C3 CC 83         jp   Render.workLoop
  31+ 9DFA              .playNext
  32+ 9DFA 21 37 8B         ld hl, Render.cursor_position
  33+ 9DFD 34               inc (hl)
  34+ 9DFE C3 B6 83         jp Render.checkBorder
  35+ 9E01
  36+ 9E01
  37+ 9E01                  ENDMODULE
# file closed: gopher/engine/media-processor.asm
  23  9E01                  include "gopher/gopher.asm"
# file opened: gopher/gopher.asm
   1+ 9E01                  module Gopher
   2+ 9E01              extractRequest:
   3+ 9E01 21 F2 87         ld hl, historyBlock.locator
   4+ 9E04 11 8D 9F         ld de, requestbuffer
   5+ 9E07              .loop
   6+ 9E07 7E               ld a, (hl)
   7+ 9E08 12               ld (de), a
   8+ 9E09 23               inc hl
   9+ 9E0A 13               inc de
  10+ 9E0B FE 00            cp 0
  11+ 9E0D 28 02            jr z, .search
  12+ 9E0F 18 F6            jr .loop
  13+ 9E11              .search
  14+ 9E11 1B               dec de
  15+ 9E12 3A F1 87         ld a, (historyBlock.mediaType)
  16+ 9E15 FE 04            cp MIME_INPUT
  17+ 9E17 20 10            jr nz, .exit
  18+ 9E19 21 37 8A         ld hl, historyBlock.search
  19+ 9E1C 3E 09            ld a, TAB
  20+ 9E1E 12               ld (de), a
  21+ 9E1F 13               inc de
  22+ 9E20              .searchCopy
  23+ 9E20 7E               ld a, (hl)
  24+ 9E21 A7               and a
  24+ 9E22 28 05          jr z, .exit
  25+ 9E24 12               ld (de), a
  26+ 9E25 23               inc hl
  26+ 9E26 13             inc de
  27+ 9E27 18 F7            jr .searchCopy
  28+ 9E29              .exit
  29+ 9E29 AF               xor a
  30+ 9E2A 12               ld (de), a
  31+ 9E2B C9               ret
  32+ 9E2C
  33+ 9E2C
  34+ 9E2C              makeRequest:
  35+ 9E2C CD 01 9E         call extractRequest
  36+ 9E2F
  37+ 9E2F 21 F1 89         ld hl, historyBlock.host
  38+ 9E32 11 31 8A         ld de, historyBlock.port
  39+ 9E35 CD 96 A3         call Wifi.openTCP
  40+ 9E38 D8               ret c
  41+ 9E39
  42+ 9E39 21 8D 9F         ld hl, requestbuffer
  43+ 9E3C CD 77 A4         call Wifi.tcpSendZ
  44+ 9E3F AF               xor a
  44+ 9E40 32 BA A2       ld (Wifi.closed), a
  45+ 9E43 C9               ret
  46+ 9E44
  47+ 9E44
  48+ 9E44              loadBuffer:
  49+ 9E44 21 F1 A5         ld hl, outputBuffer
  50+ 9E47 22 B8 A2         ld (Wifi.buffer_pointer), hl
  51+ 9E4A              .loop
  52+ 9E4A CD C5 A4         call Wifi.getPacket
  53+ 9E4D 3A BA A2         ld a, (Wifi.closed)
  53+ 9E50 A7             and a
  53+ 9E51 C0             ret nz
  54+ 9E52 CD F4 A3         call Wifi.continue
  55+ 9E55 18 F3            jr .loop
  56+ 9E57
  57+ 9E57                  ifdef GS
  58+ 9E57              loadMod:
  59+ 9E57 AF               xor a
  59+ 9E58 CD 8E A5       call GeneralSound.init
  60+ 9E5B 21 98 9E         ld hl, .progress
  60+ 9E5E CD 30 86       call DialogBox.msgNoWait
  61+ 9E61 CD 2C 9E         call makeRequest
  61+ 9E64 DA 73 9D       jp c, Fetcher.fetchFromNet.error
  62+ 9E67 CD 9B A5         call GeneralSound.loadModule
  63+ 9E6A              .loop
  64+ 9E6A 21 F1 A5 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
  64+ 9E6E B8 A2
  65+ 9E70 CD C5 A4         call Wifi.getPacket
  66+ 9E73 3A BA A2         ld a, (Wifi.closed)
  66+ 9E76 A7             and a
  66+ 9E77 20 19          jr nz, .exit
  67+ 9E79 21 F1 A5 ED      ld hl, outputBuffer, bc, (Wifi.bytes_avail)
  67+ 9E7D 4B B6 A2
  68+ 9E80              .loadLoop
  69+ 9E80 78               ld a, b
  69+ 9E81 B1             or c
  69+ 9E82 A7             and a
  69+ 9E83 28 08          jr z, .nextFrame
  70+ 9E85 7E               ld a, (hl)
  70+ 9E86 CD AE A5       call GeneralSound.sendByte
  71+ 9E89 0B               dec bc
  72+ 9E8A 23               inc hl
  73+ 9E8B 18 F3            jr .loadLoop
  74+ 9E8D              .nextFrame
  75+ 9E8D CD F4 A3         call Wifi.continue
  76+ 9E90 18 D8            jr .loop
  77+ 9E92              .exit
  78+ 9E92 CD B6 A5         call GeneralSound.finishLoadingModule
  79+ 9E95                  ;jp History.back
  80+ 9E95 C3 C1 9D     	jp MediaProcessor.processResource
  81+ 9E98 4D 4F 44 20  .progress db "MOD downloading directly to GS!", 0
  81+ 9E9C 64 6F 77 6E
  81+ 9EA0 6C 6F 61 64
  81+ 9EA4 69 6E 67 20
  81+ 9EA8 64 69 72 65
  81+ 9EAC 63 74 6C 79
  81+ 9EB0 20 74 6F 20
  81+ 9EB4 47 53 21 00
  82+ 9EB8                  endif
  83+ 9EB8
  84+ 9EB8
  85+ 9EB8              download:
  86+ 9EB8
  87+ 9EB8 11 F2 87         ld de, historyBlock.locator
  88+ 9EBB 62 6B            ld hl, de
  89+ 9EBD              .findFileName
  90+ 9EBD 1A               ld a, (de)
  90+ 9EBE 13             inc de
  91+ 9EBF FE 2F            cp '/'
  91+ 9EC1 20 02          jr nz, .skip
  92+ 9EC3 62 6B            ld hl, de
  93+ 9EC5              .skip
  94+ 9EC5 A7               and a
  94+ 9EC6 20 F5          jr nz, .findFileName
  95+ 9EC8              .copy
  96+ 9EC8                  ;; HL - filename pointer
  97+ 9EC8 11 D7 85         ld de, DialogBox.inputBuffer
  98+ 9ECB              .copyFileName
  99+ 9ECB 7E               ld a, (hl)
  99+ 9ECC A7             and a
  99+ 9ECD 28 05          jr z, .finishCopy
 100+ 9ECF
 101+ 9ECF 12               ld (de), a
 101+ 9ED0 23 13          inc hl, de
 102+ 9ED2 18 F7            jr .copyFileName
 103+ 9ED4              .finishCopy
 104+ 9ED4 12               ld (de), a
 105+ 9ED5 CD 86 85         call DialogBox.inputBox.noclear
 106+ 9ED8 3A D7 85         ld a, (DialogBox.inputBuffer)
 106+ 9EDB A7             and a
 106+ 9EDC CA B6 86       jp z, History.back
 107+ 9EDF
 108+ 9EDF CD 2C 9E         call makeRequest
 108+ 9EE2 DA 73 9D       jp c, Fetcher.fetchFromNet.error
 109+ 9EE5
 110+ 9EE5 06 0E 21 D7      ld b, Dos.FMODE_CREATE, hl, DialogBox.inputBuffer
 110+ 9EE9 85
 111+ 9EEA CD 7A 86         call Dos.fopen
 112+ 9EED 32 8B 9F         ld (.fp), a
 113+ 9EF0
 114+ 9EF0 21 66 9F         ld hl, .progress
 114+ 9EF3 CD 30 86       call DialogBox.msgNoWait
 115+ 9EF6              .loop
 116+ 9EF6 21 F1 A5 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
 116+ 9EFA B8 A2
 117+ 9EFC CD C5 A4         call Wifi.getPacket
 118+ 9EFF 3A BA A2         ld a, (Wifi.closed)
 118+ 9F02 A7             and a
 118+ 9F03 20 12          jr nz, .exit
 119+ 9F05
 120+ 9F05 3A 8B 9F 21      ld a, (.fp), hl, outputBuffer, bc, (Wifi.bytes_avail)
 120+ 9F09 F1 A5 ED 4B
 120+ 9F0D B6 A2
 121+ 9F0F CD 99 86         call Dos.fwrite
 122+ 9F12
 123+ 9F12 CD F4 A3         call Wifi.continue
 124+ 9F15 18 DF            jr .loop
 125+ 9F17              .exit
 126+ 9F17 3A 8B 9F         ld a, (.fp)
 127+ 9F1A CD 8F 86         call Dos.fclose
 128+ 9F1D C3 B6 86         jp History.back
 129+ 9F20              .error
 130+ 9F20 3A 8B 9F         ld a, (.fp)
 131+ 9F23 CD 8F 86         call Dos.fclose
 132+ 9F26
 133+ 9F26 21 2F 9F         ld hl, .err
 134+ 9F29 CD 27 86         call DialogBox.msgBox
 135+ 9F2C C3 B6 86         jp History.back
 136+ 9F2F 4F 70 65 72  .err db "Operation failed! Sorry! Check filename or disk space!",0
 136+ 9F33 61 74 69 6F
 136+ 9F37 6E 20 66 61
 136+ 9F3B 69 6C 65 64
 136+ 9F3F 21 20 53 6F
 136+ 9F43 72 72 79 21
 136+ 9F47 20 43 68 65
 136+ 9F4B 63 6B 20 66
 136+ 9F4F 69 6C 65 6E
 136+ 9F53 61 6D 65 20
 136+ 9F57 6F 72 20 64
 136+ 9F5B 69 73 6B 20
 136+ 9F5F 73 70 61 63
 136+ 9F63 65 21 00
 137+ 9F66 44 6F 77 6E  .progress db "Downloading in progress! Wait a bit!", 0
 137+ 9F6A 6C 6F 61 64
 137+ 9F6E 69 6E 67 20
 137+ 9F72 69 6E 20 70
 137+ 9F76 72 6F 67 72
 137+ 9F7A 65 73 73 21
 137+ 9F7E 20 57 61 69
 137+ 9F82 74 20 61 20
 137+ 9F86 62 69 74 21
 137+ 9F8A 00
 138+ 9F8B 00           .fp db 0
 139+ 9F8C
 140+ 9F8C 00           socket db 0
 141+ 9F8D
 142+ 9F8D 00 00 00...  requestbuffer ds #1ff
 143+ A18C                  endmodule
 144+ A18C
# file closed: gopher/gopher.asm
  24  A18C                  include "player/vortex-processor.asm"
# file opened: player/vortex-processor.asm
   1+ A18C                  MODULE VortexProcessor
   2+ A18C              play:
   3+ A18C CD A0 86         call Console.waitForKeyUp
   4+ A18F
   5+ A18F 21 CB A1         ld hl, message
   5+ A192 CD 30 86       call DialogBox.msgNoWait
   6+ A195
   7+ A195 21 F1 A5         ld hl, outputBuffer
   7+ A198                OS_VTPL_INIT
   7+ A198 0E 15       >    ld c,#15
   7+ A19A E7          >    rst #20
   8+ A19B
   9+ A19B
  10+ A19B 3E 01 32 81      ld a, 1, (Render.play_next), a
  10+ A19F 85
  11+ A1A0                  ifdef GS
  12+ A1A0 CD D2 A5         call GeneralSound.stopModule
  13+ A1A3                  endif
  14+ A1A3              	OS_VTPL_PLAY
  14+ A1A3 0E 16       >    ld c,#16
  14+ A1A5 E7          >    rst #20
  15+ A1A6              .loop
  16+ A1A6 76               halt
  16+ A1A7               ; di : call VTPL.PLAY : ei
  17+ A1A7              	OS_GETCHAR
  17+ A1A7 0E 10       >    ld c,#10
  17+ A1A9 E7          >    rst #20
  18+ A1AA FE 20        	cp " " ;останов по пробелу
  19+ A1AC CA C5 A1     	jp z, .stopKey
  20+ A1AF CD 4D A2     	call printRTC
  21+ A1B2              	OS_GET_VTPL_SETUP
  21+ A1B2 0E 18       >    ld c,#18
  21+ A1B4 E7          >    rst #20
  22+ A1B5 7E               ld a, (hl)
  22+ A1B6
  23+ A1B6 17           	rla
  23+ A1B7 30 ED          jr nc, .loop
  24+ A1B9 3E 01 32 81      ld a, 1, (Render.play_next), a
  24+ A1BD 85
  25+ A1BE              .stop
  26+ A1BE              	OS_VTPL_MUTE
  26+ A1BE 0E 17       >    ld c,#17
  26+ A1C0 E7          >    rst #20
  27+ A1C1
  28+ A1C1                  IFDEF AY
  29+ A1C1 ~                call restoreAyState
  30+ A1C1                  ENDIF
  31+ A1C1
  32+ A1C1 CD A0 86         call Console.waitForKeyUp
  33+ A1C4 C9               ret
  34+ A1C5              .stopKey
  35+ A1C5 AF               xor a
  35+ A1C6 32 81 85       ld (Render.play_next), a
  36+ A1C9 18 F3            jr .stop
  37+ A1CB
  38+ A1CB                  IFDEF AY
  39+ A1CB ~            restoreAyState:
  40+ A1CB ~                ld a, #07
  41+ A1CB ~                ld bc, #fffd
  42+ A1CB ~                out (c), a
  43+ A1CB ~                ld a, #fc
  44+ A1CB ~                ld b, #bf
  45+ A1CB ~                out (c), a ; Enable read mode
  46+ A1CB ~
  47+ A1CB ~                ld a, #0e
  48+ A1CB ~                ld bc, #fffd
  49+ A1CB ~                out (c), a
  50+ A1CB ~                ret
  51+ A1CB                  ENDIF
  52+ A1CB
  53+ A1CB 50 72 65 73  message db "Press key to stop...", 0
  53+ A1CF 73 20 6B 65
  53+ A1D3 79 20 74 6F
  53+ A1D7 20 73 74 6F
  53+ A1DB 70 2E 2E 2E
  53+ A1DF 00
  54+ A1E0                  ENDMODULE
  55+ A1E0                  ;include "player.asm"
  56+ A1E0
# file closed: player/vortex-processor.asm
  25  A1E0                  include "player/mod-processor.asm"
# file opened: player/mod-processor.asm
   1+ A1E0                  MODULE ModProcessor
   2+ A1E0                  ifdef GS
   3+ A1E0
   4+ A1E0                  macro _WaitCommand2
   5+ A1E0 ~            .wait
   6+ A1E0 ~                in a, (CMD)
   7+ A1E0 ~                rrca
   8+ A1E0 ~                jr c, .wait
   9+ A1E0                  endm
  10+ A1E0
  11+ A1E0                  macro _SendCommand2 nn
  12+ A1E0 ~                ld a, nn
  12+ A1E0 ~              out (CMD), a
  13+ A1E0                  endm
  14+ A1E0
  15+ A1E0              play:
  16+ A1E0 CD A0 86         call Console.waitForKeyUp
  17+ A1E3
  18+ A1E3 21 8D 9F         ld hl, Gopher.requestbuffer
  18+ A1E6 CD 30 86       call DialogBox.msgNoWait
  19+ A1E9
  20+ A1E9                  ;ld a, 1, (Render.play_next), a
  21+ A1E9 AF           	xor a
  22+ A1EA 32 20 A2     	ld (last_song_position),a
  23+ A1ED
  24+ A1ED              .loop
  25+ A1ED 76               halt
  25+ A1EE
  26+ A1EE                  OS_GETCHAR
  26+ A1EE 0E 10       >    ld c,#10
  26+ A1F0 E7          >    rst #20
  27+ A1F1 FE FF        	cp 255
  28+ A1F3 C2 1A A2     	jp nz, .stopKey
  29+ A1F6 CD 4D A2     	call printRTC
  30+ A1F9                  ;проверка что MOD начал играть сначала
  31+ A1F9                  _SendCommand2 CMD_GET_SONG_POSITION
  31+ A1F9 3E 60       >    ld a, CMD_GET_SONG_POSITION
  31+ A1FB D3 BB       >  out (CMD), a
  32+ A1FD                  _WaitCommand2
  32+ A1FD             >.wait
  32+ A1FD DB BB       >    in a, (CMD)
  32+ A1FF 0F          >    rrca
  32+ A200 38 FB       >    jr c, .wait
  33+ A202 3A 20 A2     	ld a,(last_song_position) ;предыдущая позиция
  34+ A205 4F           	ld c,a
  35+ A206 DB B3        	in a,(DATA) ;текущая позиция
  36+ A208 32 20 A2     	ld (last_song_position),a
  37+ A20B B9           	cp c
  38+ A20C 30 DF        	jr nc, .loop ;если не меньше, продолжаем играть
  39+ A20E 3E 01 32 81      ld a, 1, (Render.play_next), a ;флаг что надо будет играть следующий файл
  39+ A212 85
  40+ A213              .stop
  41+ A213 CD D2 A5         call GeneralSound.stopModule
  42+ A216
  43+ A216 CD A0 86         call Console.waitForKeyUp
  44+ A219 C9               ret
  45+ A21A              .stopKey
  46+ A21A AF               xor a
  46+ A21B 32 81 85       ld (Render.play_next), a ;флаг что не надо играть следующий файл
  47+ A21E 18 F3            jr .stop
  48+ A220
  49+ A220
  50+ A220              ;message db "Press key to stop...", 0
  51+ A220
  52+ A220
  53+ A220              CMD_GET_SONG_POSITION     = #60
  54+ A220 00           last_song_position db 0
  55+ A221
  56+ A221              ;; Control ports
  57+ A221              CMD  = 187
  58+ A221              DATA = 179
  59+ A221
  60+ A221                  endif
  61+ A221                  ENDMODULE
  62+ A221
  63+ A221
# file closed: player/mod-processor.asm
  26  A221                  include "screen/screen.asm"
# file opened: screen/screen.asm
   1+ A221                  module ScreenViewer
   2+ A221              display:
   3+ A221 CD A0 86         call Console.waitForKeyUp
   4+ A224                  ;ld a, 7 : call Memory.setPage
   5+ A224 21 F1 C0 11      ld hl, outputBuffer+6912, de, #c000+6912, bc, 6912
   5+ A228 00 DB 01 00
   5+ A22C 1B
   5+ A22D ED B8          lddr
   6+ A22F              	OS_GET_MAIN_PAGES
   6+ A22F 0E 1E       >    ld c,#1e
   6+ A231 E7          >    rst #20
   7+ A232 79           	ld a,c
   8+ A233 06 07        	ld b,7
   9+ A235              	OS_PAGE_COPY
   9+ A235 0E 19       >    ld c,#19
   9+ A237 E7          >    rst #20
  10+ A238                  ;call TextMode.disable
  11+ A238 3E 07        	ld a,7
  12+ A23A              	OS_SET_SCR
  12+ A23A 0E 1D       >    ld c,#1d
  12+ A23C E7          >    rst #20
  13+ A23D              .wait
  14+ A23D 76           	halt
  15+ A23E              	OS_GETCHAR
  15+ A23E 0E 10       >    ld c,#10
  15+ A240 E7          >    rst #20
  16+ A241 FE FF        	cp 255
  17+ A243 28 F8        	jr z, .wait
  18+ A245 3E 39        	ld a,#39
  19+ A247              	OS_SET_SCR
  19+ A247 0E 1D       >    ld c,#1d
  19+ A249 E7          >    rst #20
  20+ A24A                  ;call TextMode.cls
  21+ A24A C3 B6 86         jp History.back
  22+ A24D
  23+ A24D                  endmodule
# file closed: screen/screen.asm
  27  A24D                  include "screen/rtc.asm"
# file opened: screen/rtc.asm
   1+ A24D              printRTC
   2+ A24D              	ifndef SMUCRTC
   3+ A24D C9           	ret
   4+ A24E              	endif
   5+ A24E              	ifdef SMUCRTC
   6+ A24E ~            	;печать текущего времени
   7+ A24E ~            	call Clock.readTime
   8+ A24E ~            	jr nc,read_time_ok
   9+ A24E ~            	; ld hl,mes_no_RTC
  10+ A24E ~            	; call print_mes
  11+ A24E ~            	; scf
  12+ A24E ~            	ret ;выход
  13+ A24E ~            read_time_ok
  14+ A24E ~            	push bc
  15+ A24E ~            	ld l,e ;часы
  16+ A24E ~            	ld h,0
  17+ A24E ~            	call toDecimal
  18+ A24E ~            	ld de,00 ;координаты
  19+ A24E ~            	call TextMode.gotoXY
  20+ A24E ~            	ld hl,decimalS+3
  21+ A24E ~            	call TextMode.printZ
  22+ A24E ~            	ld a,":"
  23+ A24E ~            	call TextMode.putC
  24+ A24E ~            	pop bc
  25+ A24E ~            	ld l,b ;минуты
  26+ A24E ~            	ld h,0
  27+ A24E ~            	call toDecimal
  28+ A24E ~            	ld hl,decimalS+3
  29+ A24E ~            	call TextMode.printZ
  30+ A24E ~            	; ld a,":"
  31+ A24E ~            	; call TextMode.putC
  32+ A24E ~            	; ld l,c ;секунды
  33+ A24E ~            	; ld h,0
  34+ A24E ~            	; call toDecimal
  35+ A24E ~            	; ld hl,decimalS+3
  36+ A24E ~            	; call TextMode.printZ
  37+ A24E ~            	; or a ;нет ошибки
  38+ A24E ~            	ret
  39+ A24E ~
  40+ A24E ~
  41+ A24E ~            toDecimal		;конвертирует 2 байта в 5 десятичных цифр
  42+ A24E ~            				;на входе в HL число
  43+ A24E ~            			ld de,10000 ;десятки тысяч
  44+ A24E ~            			ld a,255
  45+ A24E ~            toDecimal10k
  46+ A24E ~            			and a
  47+ A24E ~            			sbc hl,de
  48+ A24E ~            			inc a
  49+ A24E ~            			jr nc,toDecimal10k
  50+ A24E ~            			add hl,de
  51+ A24E ~            			add a,48
  52+ A24E ~            			ld (decimalS),a
  53+ A24E ~            			ld de,1000 ;тысячи
  54+ A24E ~            			ld a,255
  55+ A24E ~            toDecimal1k
  56+ A24E ~            			and a
  57+ A24E ~            			sbc hl,de
  58+ A24E ~            			inc a
  59+ A24E ~            			jr nc,toDecimal1k
  60+ A24E ~            			add hl,de
  61+ A24E ~            			add a,48
  62+ A24E ~            			ld (decimalS+1),a
  63+ A24E ~            			ld de,100 ;сотни
  64+ A24E ~            			ld a,255
  65+ A24E ~            toDecimal01k
  66+ A24E ~            			and a
  67+ A24E ~            			sbc hl,de
  68+ A24E ~            			inc a
  69+ A24E ~            			jr nc,toDecimal01k
  70+ A24E ~            			add hl,de
  71+ A24E ~            			add a,48
  72+ A24E ~            			ld (decimalS+2),a
  73+ A24E ~            			ld de,10 ;десятки
  74+ A24E ~            			ld a,255
  75+ A24E ~            toDecimal001k
  76+ A24E ~            			and a
  77+ A24E ~            			sbc hl,de
  78+ A24E ~            			inc a
  79+ A24E ~            			jr nc,toDecimal001k
  80+ A24E ~            			add hl,de
  81+ A24E ~            			add a,48
  82+ A24E ~            			ld (decimalS+3),a
  83+ A24E ~            			ld de,1 ;единицы
  84+ A24E ~            			ld a,255
  85+ A24E ~            toDecimal0001k
  86+ A24E ~            			and a
  87+ A24E ~            			sbc hl,de
  88+ A24E ~            			inc a
  89+ A24E ~            			jr nc,toDecimal0001k
  90+ A24E ~            			add hl,de
  91+ A24E ~            			add a,48
  92+ A24E ~            			ld (decimalS+4),a
  93+ A24E ~
  94+ A24E ~            			ret
  95+ A24E ~
  96+ A24E ~            decimalS	ds 6 ;десятичные цифры
  97+ A24E ~
  98+ A24E              	endif
# file closed: screen/rtc.asm
  28  A24E                  include "drivers/index.asm"
# file opened: drivers/index.asm
   1+ A24E                  IFDEF UNO
   2+ A24E ~                include "uno-uart.asm"
   3+ A24E                  ENDIF
   4+ A24E
   5+ A24E                  IFDEF MB03
   6+ A24E ~                include "mb03-uart.asm"
   7+ A24E                  ENDIF
   8+ A24E
   9+ A24E                  IFDEF AY
  10+ A24E ~                include "ay-uart.asm"
  11+ A24E                  ENDIF
  12+ A24E
  13+ A24E                  IFDEF ZW
  14+ A24E                  include "zx-wifi.asm"
# file opened: drivers/zx-wifi.asm
   1++A24E              ; This driver works with 16c550 uart that's support AFE
   2++A24E                  module Uart
   3++A24E              ; Make init shorter and readable:-)
   4++A24E                  macro outp port, value
   5++A24E ~            	ld b, port
   6++A24E ~            	ld c, #EF
   7++A24E ~                ld a, value
   8++A24E ~                out (c), a
   9++A24E                  endm
  10++A24E
  11++A24E              ; Internal port constants
  12++A24E              RBR_THR = #F8
  13++A24E              IER     = RBR_THR + 1
  14++A24E              IIR_FCR = RBR_THR + 2
  15++A24E              LCR     = RBR_THR + 3
  16++A24E              MCR     = RBR_THR + 4
  17++A24E              LSR     = RBR_THR + 5
  18++A24E              MSR     = RBR_THR + 6
  19++A24E              SR      = RBR_THR + 7
  20++A24E
  21++A24E              init:
  22++A24E                  outp MCR,     #0d  // Assert RTS
  22++A24E 06 FC       >	ld b, MCR
  22++A250 0E EF       >	ld c, #EF
  22++A252 3E 0D       >    ld a, #0d
  22++A254 ED 79       >    out (c), a
  23++A256                  outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  23++A256 06 FA       >	ld b, IIR_FCR
  23++A258 0E EF       >	ld c, #EF
  23++A25A 3E 87       >    ld a, #87
  23++A25C ED 79       >    out (c), a
  24++A25E                  outp LCR,     #83  // 8n1, DLAB=1
  24++A25E 06 FB       >	ld b, LCR
  24++A260 0E EF       >	ld c, #EF
  24++A262 3E 83       >    ld a, #83
  24++A264 ED 79       >    out (c), a
  25++A266                  outp RBR_THR, #01  // 115200 (divider 1)
  25++A266 06 F8       >	ld b, RBR_THR
  25++A268 0E EF       >	ld c, #EF
  25++A26A 3E 01       >    ld a, #01
  25++A26C ED 79       >    out (c), a
  26++A26E                  outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  26++A26E 06 F9       >	ld b, IER
  26++A270 0E EF       >	ld c, #EF
  26++A272 3E 00       >    ld a, #00
  26++A274 ED 79       >    out (c), a
  27++A276
  28++A276                  outp LCR,     #03 // 8n1, DLAB=0
  28++A276 06 FB       >	ld b, LCR
  28++A278 0E EF       >	ld c, #EF
  28++A27A 3E 03       >    ld a, #03
  28++A27C ED 79       >    out (c), a
  29++A27E                  outp IER,     #00 // Disable int
  29++A27E 06 F9       >	ld b, IER
  29++A280 0E EF       >	ld c, #EF
  29++A282 3E 00       >    ld a, #00
  29++A284 ED 79       >    out (c), a
  30++A286                  outp MCR,     #2f // Enable AFE
  30++A286 06 FC       >	ld b, MCR
  30++A288 0E EF       >	ld c, #EF
  30++A28A 3E 2F       >    ld a, #2f
  30++A28C ED 79       >    out (c), a
  31++A28E C9               ret
  32++A28F
  33++A28F              ;retry_rec_count_max equ %00011111 ;ждать столько прерываний
  34++A28F
  35++A28F              ; Flag C <- Data available
  36++A28F              ; isAvailable:
  37++A28F                  ; ld a, LSR
  38++A28F                  ; in a, (#EF)
  39++A28F                  ; rrca
  40++A28F                  ; ret
  41++A28F
  42++A28F              ; Non-blocking read
  43++A28F              ; Flag C <- is byte was readen
  44++A28F              ; A <- byte
  45++A28F              ; read1:
  46++A28F                  ; ld a, LSR
  47++A28F                  ; in a, (#EF)
  48++A28F                  ; rrca
  49++A28F                  ; ret nc
  50++A28F                  ; ld a, RBR_THR
  51++A28F                  ; in a, (#EF)
  52++A28F                  ; scf
  53++A28F                  ; ret
  54++A28F
  55++A28F              ; Tries read byte with timeout
  56++A28F              ; Flag C <- is byte read
  57++A28F              ; A <- byte
  58++A28F              read:
  59++A28F              	;xor a ;4
  60++A28F              	;ld (#5C78),a ;обнулить счётчик ожидания ;13
  61++A28F              .wait
  62++A28F 3E FD            ld a, LSR
  63++A291 DB EF            in a, (#EF)
  64++A293 0F               rrca
  65++A294 30 F9        	jr nc, .wait
  66++A296 3E F8            ld a, RBR_THR
  67++A298 DB EF            in a, (#EF)
  68++A29A C9           	ret
  69++A29B              ; .readW
  70++A29B              	; OS_GETTIMER
  71++A29B              	; ld a,e
  72++A29B              	; and retry_rec_count_max
  73++A29B              	; ;ld a,(#5C78)
  74++A29B              	; ;cp retry_rec_count_max
  75++A29B              	; jr nz, .wait ;ещё попытка
  76++A29B              	; xor a ;выключим флаг переноса если время вышло
  77++A29B              	; ret
  78++A29B
  79++A29B
  80++A29B
  81++A29B
  82++A29B              ; Blocking read
  83++A29B              ; A <- Byte
  84++A29B              ; readB:
  85++A29B                  ; ld a, LSR
  86++A29B                  ; in a, (#EF)
  87++A29B                  ; rrca
  88++A29B                  ; jr nc, readB
  89++A29B              	; ld a, RBR_THR
  90++A29B                  ; in a, (#EF)
  91++A29B                  ; ret
  92++A29B
  93++A29B              ; A -> byte to send
  94++A29B              write:
  95++A29B F5               push af
  96++A29C              .wait
  97++A29C 3E FD        	ld a, LSR
  98++A29E DB EF            in a, (#EF)
  99++A2A0 E6 20            and #20
 100++A2A2 28 F8            jr z, .wait
 101++A2A4 F1               pop af
 102++A2A5 06 F8        	ld b, RBR_THR
 103++A2A7 0E EF        	ld c, #EF
 104++A2A9 ED 79            out (c), a
 105++A2AB C9               ret
 106++A2AC
 107++A2AC                  endmodule
# file closed: drivers/zx-wifi.asm
  15+ A2AC                  ENDIF
  16+ A2AC
  17+ A2AC                  IFDEF SMUCRTC
  18+ A2AC ~                include "smuc-rtc.asm"
  19+ A2AC                  ENDIF
  20+ A2AC
  21+ A2AC                  include "utils.asm"
# file opened: drivers/utils.asm
   1++A2AC              ;;; Macroses!!!!
   2++A2AC                  MACRO EspSend Text
   3++A2AC ~                ld hl, .txtB
   4++A2AC ~                ld e, (.txtE - .txtB)
   5++A2AC ~                call espSend
   6++A2AC ~                jr .txtE
   7++A2AC ~            .txtB
   8++A2AC ~                db Text
   9++A2AC ~            .txtE
  10++A2AC                  ENDM
  11++A2AC
  12++A2AC                  MACRO EspCmd Text
  13++A2AC ~                ld hl, .txtB
  14++A2AC ~                ld e, (.txtE - .txtB)
  15++A2AC ~                call espSend
  16++A2AC ~                jr .txtE
  17++A2AC ~            .txtB
  18++A2AC ~                db Text
  19++A2AC ~                db 13, 10
  20++A2AC ~            .txtE
  21++A2AC                  ENDM
  22++A2AC
  23++A2AC                  MACRO EspCmdOkErr text
  24++A2AC ~                EspCmd text
  25++A2AC ~                call checkOkErr
  26++A2AC                  ENDM
  27++A2AC
  28++A2AC              ; IN DE - string pointer
  29++A2AC              ; OUT HL - string len
  30++A2AC              strLen:
  31++A2AC 21 00 00         ld hl, 0
  32++A2AF              .loop
  33++A2AF 1A               ld a, (de)
  33++A2B0 A7             and a
  33++A2B1 C8             ret z
  34++A2B2 13 23            inc de, hl
  35++A2B4 18 F9            jr .loop
# file closed: drivers/utils.asm
  22+ A2B6                  include "wifi.asm"
# file opened: drivers/wifi.asm
   1++A2B6                  MODULE Wifi
   2++A2B6 00 00        bytes_avail dw 0
   3++A2B8 00 00        buffer_pointer dw 0
   4++A2BA 01           closed db 1
   5++A2BB              ; Initialize Wifi chip to work
   6++A2BB              init:
   7++A2BB                  ; ld hl, .uartIniting : call TextMode.printZ
   8++A2BB                  ; call Uart.init
   9++A2BB 21 7F A3         ld hl, .chipIniting
   9++A2BE CD 1E 80       call TextMode.printZ
  10++A2C1                  EspCmdOkErr "ATE0"
  10++A2C1             >    EspCmd "ATE0"
  10++A2C1 21 CB A2    >    ld hl, .txtB
  10++A2C4 1E 06       >    ld e, (.txtE - .txtB)
  10++A2C6 CD 5C A4    >    call espSend
  10++A2C9 18 06       >    jr .txtE
  10++A2CB             >.txtB
  10++A2CB 41 54 45 30 >    db "ATE0"
  10++A2CF 0D 0A       >    db 13, 10
  10++A2D1             >.txtE
  10++A2D1 CD F5 A3    >    call checkOkErr
  11++A2D4 38 79            jr c, .initError
  12++A2D6
  13++A2D6                  EspCmdOkErr "AT+CIPSERVER=0"
  13++A2D6             >    EspCmd "AT+CIPSERVER=0"
  13++A2D6 21 E0 A2    >    ld hl, .txtB
  13++A2D9 1E 10       >    ld e, (.txtE - .txtB)
  13++A2DB CD 5C A4    >    call espSend
  13++A2DE 18 10       >    jr .txtE
  13++A2E0             >.txtB
  13++A2E0 41 54 2B 43 >    db "AT+CIPSERVER=0"
  13++A2E4 49 50 53 45 >
  13++A2E8 52 56 45 52 >
  13++A2EC 3D 30       >
  13++A2EE 0D 0A       >    db 13, 10
  13++A2F0             >.txtE
  13++A2F0 CD F5 A3    >    call checkOkErr
  14++A2F3                  EspCmdOkErr "AT+CIPCLOSE" ; Close if there some connection was. Don't care about result
  14++A2F3             >    EspCmd "AT+CIPCLOSE"
  14++A2F3 21 FD A2    >    ld hl, .txtB
  14++A2F6 1E 0D       >    ld e, (.txtE - .txtB)
  14++A2F8 CD 5C A4    >    call espSend
  14++A2FB 18 0D       >    jr .txtE
  14++A2FD             >.txtB
  14++A2FD 41 54 2B 43 >    db "AT+CIPCLOSE"
  14++A301 49 50 43 4C >
  14++A305 4F 53 45    >
  14++A308 0D 0A       >    db 13, 10
  14++A30A             >.txtE
  14++A30A CD F5 A3    >    call checkOkErr
  15++A30D                  EspCmdOkErr "AT+CIPMUX=0" ; Single connection mode
  15++A30D             >    EspCmd "AT+CIPMUX=0"
  15++A30D 21 17 A3    >    ld hl, .txtB
  15++A310 1E 0D       >    ld e, (.txtE - .txtB)
  15++A312 CD 5C A4    >    call espSend
  15++A315 18 0D       >    jr .txtE
  15++A317             >.txtB
  15++A317 41 54 2B 43 >    db "AT+CIPMUX=0"
  15++A31B 49 50 4D 55 >
  15++A31F 58 3D 30    >
  15++A322 0D 0A       >    db 13, 10
  15++A324             >.txtE
  15++A324 CD F5 A3    >    call checkOkErr
  16++A327 38 26            jr c, .initError
  17++A329
  18++A329                  EspCmdOkErr "AT+CIPDINFO=0" ; Disable additional info
  18++A329             >    EspCmd "AT+CIPDINFO=0"
  18++A329 21 33 A3    >    ld hl, .txtB
  18++A32C 1E 0F       >    ld e, (.txtE - .txtB)
  18++A32E CD 5C A4    >    call espSend
  18++A331 18 0F       >    jr .txtE
  18++A333             >.txtB
  18++A333 41 54 2B 43 >    db "AT+CIPDINFO=0"
  18++A337 49 50 44 49 >
  18++A33B 4E 46 4F 3D >
  18++A33F 30          >
  18++A340 0D 0A       >    db 13, 10
  18++A342             >.txtE
  18++A342 CD F5 A3    >    call checkOkErr
  19++A345 38 08            jr c, .initError
  20++A347
  21++A347 21 90 A3         ld hl, .doneInit
  21++A34A CD 1E 80       call TextMode.printZ
  22++A34D
  23++A34D B7               or a
  24++A34E C9               ret
  25++A34F              .initError
  26++A34F 21 57 A3         ld hl, .errMsg
  26++A352 CD 27 86       call DialogBox.msgBox
  27++A355 37               scf
  28++A356 C9               ret
  29++A357 57 69 46 69  .errMsg db "WiFi chip init failed!",0
  29++A35B 20 63 68 69
  29++A35F 70 20 69 6E
  29++A363 69 74 20 66
  29++A367 61 69 6C 65
  29++A36B 64 21 00
  30++A36E 55 61 72 74  .uartIniting db "Uart initing...",13,0
  30++A372 20 69 6E 69
  30++A376 74 69 6E 67
  30++A37A 2E 2E 2E 0D
  30++A37E 00
  31++A37F 43 68 69 70  .chipIniting db "Chip initing...",13,0
  31++A383 20 69 6E 69
  31++A387 74 69 6E 67
  31++A38B 2E 2E 2E 0D
  31++A38F 00
  32++A390 44 6F 6E 65  .doneInit    db "Done!",0
  32++A394 21 00
  33++A396                  IFNDEF PROXY
  34++A396              ; HL - host pointer in gopher row
  35++A396              ; DE - port pointer in gopher row
  36++A396              openTCP:
  37++A396 D5               push de
  38++A397 E5               push hl
  39++A398                  EspCmdOkErr "AT+CIPCLOSE" ; Don't care about result. Just close if it didn't happens before
  39++A398             >    EspCmd "AT+CIPCLOSE"
  39++A398 21 A2 A3    >    ld hl, .txtB
  39++A39B 1E 0D       >    ld e, (.txtE - .txtB)
  39++A39D CD 5C A4    >    call espSend
  39++A3A0 18 0D       >    jr .txtE
  39++A3A2             >.txtB
  39++A3A2 41 54 2B 43 >    db "AT+CIPCLOSE"
  39++A3A6 49 50 43 4C >
  39++A3AA 4F 53 45    >
  39++A3AD 0D 0A       >    db 13, 10
  39++A3AF             >.txtE
  39++A3AF CD F5 A3    >    call checkOkErr
  40++A3B2                  EspSend 'AT+CIPSTART="TCP","'
  40++A3B2 21 BC A3    >    ld hl, .txtB
  40++A3B5 1E 13       >    ld e, (.txtE - .txtB)
  40++A3B7 CD 5C A4    >    call espSend
  40++A3BA 18 13       >    jr .txtE
  40++A3BC             >.txtB
  40++A3BC 41 54 2B 43 >    db 'AT+CIPSTART="TCP","'
  40++A3C0 49 50 53 54 >
  40++A3C4 41 52 54 3D >
  40++A3C8 22 54 43 50 >
  40++A3CC 22 2C 22    >
  40++A3CF             >.txtE
  41++A3CF E1               pop hl
  42++A3D0 CD 65 A4         call espSendT
  43++A3D3                  EspSend '",'
  43++A3D3 21 DD A3    >    ld hl, .txtB
  43++A3D6 1E 02       >    ld e, (.txtE - .txtB)
  43++A3D8 CD 5C A4    >    call espSend
  43++A3DB 18 02       >    jr .txtE
  43++A3DD             >.txtB
  43++A3DD 22 2C       >    db '",'
  43++A3DF             >.txtE
  44++A3DF E1               pop hl
  45++A3E0 CD 65 A4         call espSendT
  46++A3E3 3E 0D            ld a, 13
  46++A3E5 CD 9B A2       call Uart.write
  47++A3E8 3E 0A            ld a, 10
  47++A3EA CD 9B A2       call Uart.write
  48++A3ED AF               xor a
  48++A3EE 32 BA A2       ld (closed), a
  49++A3F1 C3 F5 A3         jp checkOkErr
  50++A3F4
  51++A3F4              continue:
  52++A3F4 C9               ret
  53++A3F5                  ENDIF
  54++A3F5
  55++A3F5
  56++A3F5
  57++A3F5              checkOkErr:
  58++A3F5 CD 8F A2         call Uart.read
  59++A3F8 FE 4F            cp 'O'
  59++A3FA 28 0A          jr z, .okStart ; OK
  60++A3FC FE 45            cp 'E'
  60++A3FE 28 19          jr z, .errStart ; ERROR
  61++A400 FE 46            cp 'F'
  61++A402 28 36          jr z, .failStart ; FAIL
  62++A404 18 EF            jr checkOkErr
  63++A406              .okStart
  64++A406 CD 8F A2         call Uart.read
  64++A409 FE 4B          cp 'K'
  64++A40B 20 E8          jr nz, checkOkErr
  65++A40D CD 8F A2         call Uart.read
  65++A410 FE 0D          cp 13
  65++A412 20 E1          jr nz, checkOkErr
  66++A414 CD 54 A4         call .flushToLF
  67++A417 B7               or a
  68++A418 C9               ret
  69++A419              .errStart
  70++A419 CD 8F A2         call Uart.read
  70++A41C FE 52          cp 'R'
  70++A41E 20 D5          jr nz, checkOkErr
  71++A420 CD 8F A2         call Uart.read
  71++A423 FE 52          cp 'R'
  71++A425 20 CE          jr nz, checkOkErr
  72++A427 CD 8F A2         call Uart.read
  72++A42A FE 4F          cp 'O'
  72++A42C 20 C7          jr nz, checkOkErr
  73++A42E CD 8F A2         call Uart.read
  73++A431 FE 52          cp 'R'
  73++A433 20 C0          jr nz, checkOkErr
  74++A435 CD 54 A4         call .flushToLF
  75++A438 37               scf
  76++A439 C9               ret
  77++A43A              .failStart
  78++A43A CD 8F A2         call Uart.read
  78++A43D FE 41          cp 'A'
  78++A43F 20 B4          jr nz, checkOkErr
  79++A441 CD 8F A2         call Uart.read
  79++A444 FE 49          cp 'I'
  79++A446 20 AD          jr nz, checkOkErr
  80++A448 CD 8F A2         call Uart.read
  80++A44B FE 4C          cp 'L'
  80++A44D 20 A6          jr nz, checkOkErr
  81++A44F CD 54 A4         call .flushToLF
  82++A452 37               scf
  83++A453 C9               ret
  84++A454              .flushToLF
  85++A454 CD 8F A2         call Uart.read
  86++A457 FE 0A            cp 10
  86++A459 20 F9          jr nz, .flushToLF
  87++A45B C9               ret
  88++A45C
  89++A45C              ; Send buffer to UART
  90++A45C              ; HL - buff
  91++A45C              ; E - count
  92++A45C              espSend:
  93++A45C 7E               ld a, (hl)
  93++A45D CD 9B A2       call Uart.write
  94++A460 23               inc hl
  95++A461 1D               dec e
  96++A462 20 F8            jr nz, espSend
  97++A464 C9               ret
  98++A465
  99++A465              ; HL - string that ends with one of the terminator(CR/LF/TAB/NULL)
 100++A465              espSendT:
 101++A465 7E               ld a, (hl)
 102++A466
 103++A466 A7               and a
 103++A467 C8             ret z
 104++A468 FE 09            cp 9
 104++A46A C8             ret z
 105++A46B FE 0D            cp 13
 105++A46D C8             ret z
 106++A46E FE 0A            cp 10
 106++A470 C8             ret z
 107++A471
 108++A471 CD 9B A2         call Uart.write
 109++A474 23               inc hl
 110++A475 18 EE            jr espSendT
 111++A477
 112++A477              ; HL - stringZ to send
 113++A477              ; Adds CR LF
 114++A477              tcpSendZ:
 115++A477 E5               push hl
 116++A478                  EspSend "AT+CIPSEND="
 116++A478 21 82 A4    >    ld hl, .txtB
 116++A47B 1E 0B       >    ld e, (.txtE - .txtB)
 116++A47D CD 5C A4    >    call espSend
 116++A480 18 0B       >    jr .txtE
 116++A482             >.txtB
 116++A482 41 54 2B 43 >    db "AT+CIPSEND="
 116++A486 49 50 53 45 >
 116++A48A 4E 44 3D    >
 116++A48D             >.txtE
 117++A48D D1               pop de
 117++A48E D5             push de
 118++A48F CD AC A2         call strLen
 119++A492 23               inc hl
 119++A493 23             inc hl ; +CRLF
 120++A494 CD 52 A5         call hlToNumEsp
 121++A497 3E 0D            ld a, 13
 121++A499 CD 9B A2       call Uart.write
 122++A49C 3E 0A            ld a, 10
 122++A49E CD 9B A2       call Uart.write
 123++A4A1 CD F5 A3         call checkOkErr
 123++A4A4 D8             ret c
 124++A4A5              .wait
 125++A4A5 CD 8F A2         call Uart.read
 125++A4A8 FE 3E          cp '>'
 125++A4AA 20 F9          jr nz, .wait
 126++A4AC E1               pop hl
 127++A4AD              .loop
 128++A4AD 7E               ld a, (hl)
 128++A4AE A7             and a
 128++A4AF 28 07          jr z, .exit
 129++A4B1 CD 9B A2         call Uart.write
 130++A4B4 23               inc hl
 131++A4B5 C3 AD A4         jp .loop
 132++A4B8              .exit
 133++A4B8 3E 0D            ld a, 13
 133++A4BA CD 9B A2       call Uart.write
 134++A4BD 3E 0A            ld a, 10
 134++A4BF CD 9B A2       call Uart.write
 135++A4C2 C3 F5 A3         jp checkOkErr
 136++A4C5
 137++A4C5              getPacket:
 138++A4C5 CD 8F A2         call Uart.read
 139++A4C8 FE 2B            cp '+'
 139++A4CA 28 28          jr z, .ipdBegun    ; "+IPD," packet
 140++A4CC FE 4F            cp 'O'
 140++A4CE 28 02          jr z, .closedBegun ; It enough to check "OSED\n" :-)
 141++A4D0 18 F3            jr getPacket
 142++A4D2              .closedBegun
 143++A4D2 CD 8F A2         call Uart.read
 143++A4D5 FE 53          cp 'S'
 143++A4D7 20 EC          jr nz, getPacket
 144++A4D9 CD 8F A2         call Uart.read
 144++A4DC FE 45          cp 'E'
 144++A4DE 20 E5          jr nz, getPacket
 145++A4E0 CD 8F A2         call Uart.read
 145++A4E3 FE 44          cp 'D'
 145++A4E5 20 DE          jr nz, getPacket
 146++A4E7 CD 8F A2         call Uart.read
 146++A4EA FE 0D          cp 13
 146++A4EC 20 D7          jr nz, getPacket
 147++A4EE 3E 01 32 BA      ld a, 1, (closed), a
 147++A4F2 A2
 148++A4F3 C9               ret
 149++A4F4              .ipdBegun
 150++A4F4 CD 8F A2         call Uart.read
 150++A4F7 FE 49          cp 'I'
 150++A4F9 20 CA          jr nz, getPacket
 151++A4FB CD 8F A2         call Uart.read
 151++A4FE FE 50          cp 'P'
 151++A500 20 C3          jr nz, getPacket
 152++A502 CD 8F A2         call Uart.read
 152++A505 FE 44          cp 'D'
 152++A507 20 BC          jr nz, getPacket
 153++A509 CD 8F A2         call Uart.read ; Comma
 154++A50C CD 39 A5         call .count_ipd_lenght
 154++A50F 22 B6 A2       ld (bytes_avail), hl
 155++A512 44 4D            ld bc, hl
 156++A514 2A B8 A2         ld hl, (buffer_pointer)
 157++A517              .readp
 158++A517 7C               ld a, h
 158++A518 FE FF          cp #ff
 158++A51A 30 12          jr nc, .skipbuff
 159++A51C C5 E5            push bc, hl
 160++A51E CD 8F A2         call Uart.read
 161++A521 E1 C1            pop hl, bc
 162++A523 77               ld (hl), a
 163++A524 0B               dec bc
 163++A525 23             inc hl
 164++A526 78               ld a, b
 164++A527 B1             or c
 164++A528 20 ED          jr nz, .readp
 165++A52A 22 B8 A2         ld (buffer_pointer), hl
 166++A52D C9               ret
 167++A52E              .skipbuff
 168++A52E C5               push bc
 169++A52F CD 8F A2         call Uart.read
 170++A532 C1               pop bc
 171++A533 0B               dec bc
 171++A534 78             ld a, b
 171++A535 B1             or c
 171++A536 20 F6          jr nz, .skipbuff
 172++A538 C9               ret
 173++A539              .count_ipd_lenght
 174++A539 21 00 00     		ld hl,0			; count lenght
 175++A53C E5           .cil1	push  hl
 176++A53D CD 8F A2             call Uart.read
 177++A540 E1                   pop hl
 178++A541 FE 3A        		cp ':'
 178++A543 C8             ret z
 179++A544 D6 30        		sub 0x30
 179++A546 4D             ld c,l
 179++A547 44             ld b,h
 179++A548 29             add hl,hl
 179++A549 29             add hl,hl
 179++A54A 09             add hl,bc
 179++A54B 29             add hl,hl
 179++A54C 4F             ld c,a
 179++A54D 06 00          ld b,0
 179++A54F 09             add hl,bc
 180++A550 18 EA        		jr .cil1
 181++A552
 182++A552              ; Based on: https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
 183++A552              ; HL - number
 184++A552              ; It will be written to UART
 185++A552              hlToNumEsp:
 186++A552 01 F0 D8     	ld	bc,-10000
 187++A555 CD 6B A5     	call	.n1
 188++A558 01 18 FC     	ld	bc,-1000
 189++A55B CD 6B A5     	call	.n1
 190++A55E 01 9C FF     	ld	bc,-100
 191++A561 CD 6B A5     	call	.n1
 192++A564 0E F6        	ld	c,-10
 193++A566 CD 6B A5     	call	.n1
 194++A569 0E FF        	ld	c,-1
 195++A56B 3E 2F        .n1	ld	a,'0'-1
 196++A56D 3C           .n2	inc	a
 197++A56E 09           	add	hl,bc
 198++A56F 38 FC        	jr	c, .n2
 199++A571 ED 42        	sbc	hl,bc
 200++A573 C5               push bc
 201++A574 CD 9B A2     	call Uart.write
 202++A577 C1               pop bc
 203++A578 C9               ret
 204++A579
 205++A579                  ENDMODULE
# file closed: drivers/wifi.asm
  23+ A579                  include "proxy.asm"
# file opened: drivers/proxy.asm
   1++A579                  IFDEF PROXY
   2++A579 ~                MODULE Wifi
   3++A579 ~            ; Same singature as wifi.openTCP
   4++A579 ~            ; HL - host pointer in gopher row
   5++A579 ~            ; DE - port pointer in gopher row
   6++A579 ~            openTCP:
   7++A579 ~                push de
   8++A579 ~                push hl
   9++A579 ~
  10++A579 ~                xor a
  10++A579 ~              ld hl, hostBuff, de, hostBuff + 1, bc, 102, (hl), a
  10++A579 ~              ldir
  11++A579 ~
  12++A579 ~                EspCmdOkErr "AT+CIPCLOSE"
  13++A579 ~                EspCmdOkErr 'AT+CIPSTART="TCP","138.68.76.243",6912' // Replace here for yourown proxy. If you wish
  14++A579 ~                jr c, .error
  15++A579 ~                pop hl
  15++A579 ~              ld de, hostBuff
  16++A579 ~            .copyHost
  17++A579 ~                ld a, (hl)
  17++A579 ~              and a
  17++A579 ~              jr z, 1F
  17++A579 ~              and a
  17++A579 ~              jr z, 1F
  18++A579 ~                ld (de), a
  18++A579 ~              inc hl, de
  19++A579 ~                jr .copyHost
  20++A579 ~            1   xor a
  20++A579 ~              ld (de), a
  21++A579 ~                pop hl
  21++A579 ~              ld de, portBuff
  22++A579 ~            .copyPort
  23++A579 ~                ld a, (hl)
  23++A579 ~              and a
  23++A579 ~              jr z, 1F
  23++A579 ~              and a
  23++A579 ~              jr z, 1F
  24++A579 ~                ld (de), a
  24++A579 ~              inc hl, de
  25++A579 ~                jr .copyPort
  26++A579 ~            1   ld hl, hostBuff
  26++A579 ~              call tcpSendZ
  27++A579 ~                ld hl, portBuff
  27++A579 ~              call tcpSendZ
  28++A579 ~                xor a
  28++A579 ~              ld (closed), a
  29++A579 ~                ret
  30++A579 ~            .error
  31++A579 ~                pop hl
  31++A579 ~              pop de
  32++A579 ~                ret
  33++A579 ~
  34++A579 ~            continue:
  35++A579 ~                EspCmdOkErr "AT+CIPSEND=1"
  36++A579 ~                ret c
  37++A579 ~            .wait
  38++A579 ~                call Uart.read
  38++A579 ~              cp '>'
  38++A579 ~              jr nz, .wait
  39++A579 ~                ld a, 'c'
  39++A579 ~              call Uart.write
  40++A579 ~                jp checkOkErr
  41++A579 ~
  42++A579 ~            hostBuff ds 96
  43++A579 ~            portBuff ds 7
  44++A579 ~                ENDMODULE
  45++A579                  ENDIF
# file closed: drivers/proxy.asm
  24+ A579                  include "memory.asm"
# file opened: drivers/memory.asm
   1++A579                  module Memory
   2++A579              BANKM = #5b5c
   3++A579              MEM_PORT = #7ffd
   4++A579
   5++A579              init:
   6++A579 F3               di
   7++A57A FD CB 01 A6      res 4, (iy + 1)
   8++A57E
   9++A57E AF               xor a
   9++A57F CD 83 A5       call setPage
  10++A582 C9               ret
  11++A583
  12++A583              ; a - page
  13++A583              setPage:
  14++A583 F6 18            or #18
  14++A585 32 5C 5B       ld (BANKM), a
  15++A588 01 FD 7F         ld bc, MEM_PORT
  15++A58B ED 79          out (c), a
  16++A58D C9               ret
  17++A58E
  18++A58E                  endmodule
# file closed: drivers/memory.asm
  25+ A58E                  include "general-sound.asm"
# file opened: drivers/general-sound.asm
   1++A58E                  ifdef GS
   2++A58E                  macro _WaitCommand
   3++A58E ~            .wait
   4++A58E ~                in a, (GeneralSound.CMD)
   5++A58E ~                rrca
   6++A58E ~                jr c, .wait
   7++A58E                  endm
   8++A58E
   9++A58E                  macro _WaitData
  10++A58E ~            .wait
  11++A58E ~                in a, (GeneralSound.CMD)
  12++A58E ~                rlca
  13++A58E ~                jr c, .wait
  14++A58E                  endm
  15++A58E
  16++A58E                  macro _SendCommand nn
  17++A58E ~                ld a, nn
  17++A58E ~              out (GeneralSound.CMD), a
  18++A58E                  endm
  19++A58E
  20++A58E                  module GeneralSound
  21++A58E              ;; Control ports
  22++A58E              CMD  = 187
  23++A58E              DATA = 179
  24++A58E
  25++A58E              ;; Commands
  26++A58E              CMD_WARM_RESET      = #F3
  27++A58E              CMD_COLD_RESET      = #F4
  28++A58E              CMD_LOAD_MODULE     = #30
  29++A58E              CMD_PLAY_MODULE     = #31
  30++A58E              CMD_STOP_MODULE     = #32
  31++A58E              CMD_CONTINUE_MODULE = #33
  32++A58E              CMD_OPEN_STREAM     = #D1
  33++A58E              CMD_CLOSE_STREAM    = #D2
  34++A58E
  35++A58E              ; A - 0 warm reset, other - cold
  36++A58E              init:
  37++A58E A7               and a
  37++A58F 20 05          jr nz, .cold
  38++A591                  _SendCommand CMD_WARM_RESET
  38++A591 3E F3       >    ld a, CMD_WARM_RESET
  38++A593 D3 BB       >  out (GeneralSound.CMD), a
  39++A595 C9               ret
  40++A596              .cold
  41++A596                  _SendCommand CMD_COLD_RESET
  41++A596 3E F4       >    ld a, CMD_COLD_RESET
  41++A598 D3 BB       >  out (GeneralSound.CMD), a
  42++A59A C9               ret
  43++A59B
  44++A59B              ;; Initializes loading module
  45++A59B              loadModule:
  46++A59B                  _SendCommand CMD_LOAD_MODULE
  46++A59B 3E 30       >    ld a, CMD_LOAD_MODULE
  46++A59D D3 BB       >  out (GeneralSound.CMD), a
  47++A59F                  _WaitCommand
  47++A59F             >.wait
  47++A59F DB BB       >    in a, (GeneralSound.CMD)
  47++A5A1 0F          >    rrca
  47++A5A2 38 FB       >    jr c, .wait
  48++A5A4                  _SendCommand CMD_OPEN_STREAM
  48++A5A4 3E D1       >    ld a, CMD_OPEN_STREAM
  48++A5A6 D3 BB       >  out (GeneralSound.CMD), a
  49++A5A8                  _WaitCommand
  49++A5A8             >.wait
  49++A5A8 DB BB       >    in a, (GeneralSound.CMD)
  49++A5AA 0F          >    rrca
  49++A5AB 38 FB       >    jr c, .wait
  50++A5AD C9               ret
  51++A5AE
  52++A5AE              ;; Use it for streaming mod file
  53++A5AE              sendByte:
  54++A5AE D3 B3            out (DATA), a
  55++A5B0                  _WaitData
  55++A5B0             >.wait
  55++A5B0 DB BB       >    in a, (GeneralSound.CMD)
  55++A5B2 07          >    rlca
  55++A5B3 38 FB       >    jr c, .wait
  56++A5B5 C9               ret
  57++A5B6
  58++A5B6              ;; Call it when module was loaded
  59++A5B6              finishLoadingModule:
  60++A5B6                  _SendCommand CMD_CLOSE_STREAM
  60++A5B6 3E D2       >    ld a, CMD_CLOSE_STREAM
  60++A5B8 D3 BB       >  out (GeneralSound.CMD), a
  61++A5BA                  _WaitCommand
  61++A5BA             >.wait
  61++A5BA DB BB       >    in a, (GeneralSound.CMD)
  61++A5BC 0F          >    rrca
  61++A5BD 38 FB       >    jr c, .wait
  62++A5BF              rewind:
  63++A5BF 3E 01            ld a, 1
  63++A5C1 D3 B3          out (DATA), a
  64++A5C3                  _SendCommand CMD_PLAY_MODULE
  64++A5C3 3E 31       >    ld a, CMD_PLAY_MODULE
  64++A5C5 D3 BB       >  out (GeneralSound.CMD), a
  65++A5C7                  _WaitCommand
  65++A5C7             >.wait
  65++A5C7 DB BB       >    in a, (GeneralSound.CMD)
  65++A5C9 0F          >    rrca
  65++A5CA 38 FB       >    jr c, .wait
  66++A5CC 3E 01 32 F0      ld a, 1, (state),a
  66++A5D0 A5
  67++A5D1 C9               ret
  68++A5D2
  69++A5D2              ;; Works like pause too
  70++A5D2              stopModule:
  71++A5D2 AF               xor a
  71++A5D3 32 F0 A5       ld (state), a
  72++A5D6                  _SendCommand CMD_STOP_MODULE
  72++A5D6 3E 32       >    ld a, CMD_STOP_MODULE
  72++A5D8 D3 BB       >  out (GeneralSound.CMD), a
  73++A5DA C9               ret
  74++A5DB
  75++A5DB              continueModule:
  76++A5DB 3E 01            ld a, 1
  76++A5DD 32 F0 A5       ld (state), a
  77++A5E0                  _SendCommand CMD_CONTINUE_MODULE
  77++A5E0 3E 33       >    ld a, CMD_CONTINUE_MODULE
  77++A5E2 D3 BB       >  out (GeneralSound.CMD), a
  78++A5E4 C9               ret
  79++A5E5
  80++A5E5              ; Pauses resumes
  81++A5E5              toggleModule:
  82++A5E5 CD A0 86         call Console.waitForKeyUp
  83++A5E8 3A F0 A5         ld a, (state)
  83++A5EB A7             and a
  84++A5EC 28 ED            jr z, continueModule
  85++A5EE 18 E2            jr stopModule
  86++A5F0
  87++A5F0 00           state db 0
  88++A5F1                  endmodule
  89++A5F1
  90++A5F1                  endif
# file closed: drivers/general-sound.asm
  26+ A5F1
# file closed: drivers/index.asm
  29  A5F1              start:
  30  A5F1              	; IFDEF TRD
  31  A5F1              	; align 256 ;временно
  32  A5F1              	; ENDIF
  33  A5F1              outputBuffer: ;equ #c000
  34  A5F1                  ;di
  35  A5F1                  ;xor a : ld (#5c6a), a  ; Thank you, Mario Prato, for feedback
  36  A5F1                  ;ld (#5c00),a
  37  A5F1                  ;ld sp, asmOrg
  38  A5F1                  ;call Memory.init
  39  A5F1                  ;xor a : out (#fe),a
  40  A5F1                  ;ei
  41  A5F1
  42  A5F1                  ;ld a, 7 : call Memory.setPage
  43  A5F1                  ;; Logo
  44  A5F1                  ; ld hl, logo, b, Dos.FMODE_READ : call Dos.fopen
  45  A5F1                  ; push af
  46  A5F1                  ; ld hl, #c000, bc, 6912 : call Dos.fread
  47  A5F1                  ; pop af
  48  A5F1                  ; call Dos.fclose
  49  A5F1
  50  A5F1              	; ifdef ZSGMX
  51  A5F1              	; call TextMode.disable
  52  A5F1              	; endif
  53  A5F1
  54  A5F1                  ; ld b, 50
  55  A5F1              ; 1   halt
  56  A5F1                  ; djnz 1b
  57  A5F1                  ;; End of logo :-)
  58  A5F1
  59  A5F1 CD 03 80         call TextMode.init
  60  A5F4
  61  A5F4 21 00 A6         ld hl, initing
  61  A5F7 CD 1E 80       call TextMode.printZ
  62  A5FA                  IFNDEF EMU
  63  A5FA CD BB A2         call Wifi.init
  64  A5FD                  ENDIF
  65  A5FD
  66  A5FD C3 1F 87         jp History.home
  67  A600
  68  A600 49 6E 69 74  initing db "Initing Wifi...",13,0
  68  A604 69 6E 67 20
  68  A608 57 69 66 69
  68  A60C 2E 2E 2E 0D
  68  A610 00
  69  A611 64 61 74 61  logo    db  "data/logo.scr", 0
  69  A615 2F 6C 6F 67
  69  A619 6F 2E 73 63
  69  A61D 72 00
  70  A61F                  display "ENDS: ", $
  71  A61F                  display "Buff size", #ffff - $
  72  A61F
  73  A61F                  ;IFDEF ESX
  74  A61F                  ;save3dos "moon.bin", asmOrg, $ - asmOrg
  75  A61F                  savebin "moonr.com", asmOrg, $ - asmOrg
  76  A61F              	;ELSE
  77  A61F                  ;SAVETRD "MOONR.TRD",|"moon.C",asmOrg, $ - asmOrg
  78  A61F                  ;ENDIF
# file closed: main.asm
