# file opened: main.asm
   1  0000                  device	zxspectrum128
   2  0000              	include "../os_defs.asm"
# file opened: ../os_defs.asm
   1+ 0000              ;Список всех вызовов (функций) ОС GMX
   2+ 0000
   3+ 0000              ;Включить в свой код (в начале файла):
   4+ 0000              	; include os_defs.asm
   5+ 0000
   6+ 0000              ;Использовать только имена функций, коды могут поменяться
   7+ 0000
   8+ 0000              ;например:
   9+ 0000              	; org PROGSTART
  10+ 0000              	; ../include os_defs.asm
  11+ 0000              	; ld hl,text
  12+ 0000              	; OS_PRINTZ ;печать	до кода 0
  13+ 0000
  14+ 0000              ;сохранность регистров не гарантируется
  15+ 0000              ;на выходе обычно (но не всегда) CY=1 = ошибка
  16+ 0000
  17+ 0000              PROGSTART equ #8000 ;адрес старта приложений
  18+ 0000
  19+ 0000
  20+ 0000              ;короткие вызовы (именные RST) -------------------------
  21+ 0000
  22+ 0000              ;печать символа в консоль (ускоренная)
  23+ 0000              	MACRO OS_PRINT_CHARF ;a=char
  24+ 0000 ~            	rst #10
  25+ 0000              	ENDM
  26+ 0000
  27+ 0000
  28+ 0000              ;передача управления ОС до следующего прерывания (когда придёт очередь процесса в следующий раз);
  29+ 0000              ;все регистры сохраняются
  30+ 0000              ;рекомендуется использовать вместо обычного halt
  31+ 0000              	MACRO OS_WAIT
  32+ 0000 ~            	rst #18
  33+ 0000              	ENDM
  34+ 0000
  35+ 0000              	; MACRO OS_
  36+ 0000              	; rst #28
  37+ 0000              	; ENDM
  38+ 0000
  39+ 0000              	; MACRO OS_
  40+ 0000              	; rst #30
  41+ 0000              	; ENDM
  42+ 0000
  43+ 0000
  44+ 0000
  45+ 0000              ;вызовы через единую точку входа RST #20 ----------------
  46+ 0000
  47+ 0000              ;вывод в консоль --------------------
  48+ 0000
  49+ 0000              ;очистить консоль
  50+ 0000              	macro OS_CLS ;clear visible area of terminal
  51+ 0000 ~                ld c,#00
  52+ 0000 ~                rst #20
  53+ 0000                  endm
  54+ 0000
  55+ 0000              ;установить позицию курсора в консоли
  56+ 0000                  macro OS_SET_XY ;de=yx ;SET CURSOR POSITION
  57+ 0000 ~                ld c,#01
  58+ 0000 ~                rst #20
  59+ 0000                  endm
  60+ 0000
  61+ 0000              ;печать символа в консоль
  62+ 0000                  macro OS_PRINT_CHAR ;a=char
  63+ 0000 ~                ld c,#02
  64+ 0000 ~                rst #20
  65+ 0000                  endm
  66+ 0000
  67+ 0000              ;заполнение строки одним символом
  68+ 0000                  macro OS_FILL_LINE ;; H - line ; A - char
  69+ 0000 ~                ld c,#03
  70+ 0000 ~                rst #20
  71+ 0000                  endm
  72+ 0000
  73+ 0000              ;покрасить строку цветом
  74+ 0000                  macro OS_PAINT_LINE ;a - line, b - color
  75+ 0000 ~                ld c,#04
  76+ 0000 ~                rst #20
  77+ 0000                  endm
  78+ 0000
  79+ 0000
  80+ 0000                  ; macro OS_ ;
  81+ 0000                  ; ld c,#05
  82+ 0000                  ; rst #20
  83+ 0000                  ; endm
  84+ 0000
  85+ 0000              ;установить цвет текста в консоли;
  86+ 0000                  macro OS_SET_COLOR ;a = color, b = color 2 (highlight)
  87+ 0000 ~                ld c,#06
  88+ 0000 ~                rst #20
  89+ 0000                  endm
  90+ 0000
  91+ 0000                  ; macro OS_ ;
  92+ 0000                  ; ld c,#07
  93+ 0000                  ; rst #20
  94+ 0000                  ; endm
  95+ 0000
  96+ 0000                  ; macro OS_ ;
  97+ 0000                  ; ld c,#08
  98+ 0000                  ; rst #20
  99+ 0000                  ; endm
 100+ 0000
 101+ 0000
 102+ 0000
 103+ 0000              ;печать в консоль до кода 0
 104+ 0000                  macro OS_PRINTZ ;hl=text ;PRINT to 0
 105+ 0000 ~                ld c,#09
 106+ 0000 ~                rst #20
 107+ 0000                  endm
 108+ 0000
 109+ 0000
 110+ 0000              ;прочитать байт из порта uart
 111+ 0000              ;вх:
 112+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart или нет данных для приёма
 113+ 0000              ;вых: A - считанный байт
 114+ 0000                  macro OS_UART_READ
 115+ 0000 ~                ld c,#0a
 116+ 0000 ~                rst #20
 117+ 0000                  endm
 118+ 0000
 119+ 0000              ;записать байт в порт uart
 120+ 0000              ;вх: A -байт
 121+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 122+ 0000                  macro OS_UART_WRITE
 123+ 0000 ~                ld c,#0b
 124+ 0000 ~                rst #20
 125+ 0000                  endm
 126+ 0000
 127+ 0000              ;закрыть соединение ESP
 128+ 0000              ;вх:
 129+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 130+ 0000                  macro OS_ESP_CLOSE
 131+ 0000 ~                ld c,#0c
 132+ 0000 ~                rst #20
 133+ 0000                  endm
 134+ 0000
 135+ 0000              ;установить соединение ESP (CIPSTART);
 136+ 0000              ;вх: a - тип соединения 0-tcp, 1-udp, 2-ssl; 3-прямое соединение с портом; hl - строка адрес, de - строка порт
 137+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 138+ 0000              ;вых: ix - адрес в таблице соединений (ix+2 - флаг открытия =1 - открыто, 255 - ошибка);
 139+ 0000                  macro OS_ESP_OPEN
 140+ 0000 ~                ld c,#0d
 141+ 0000 ~                rst #20
 142+ 0000                  endm
 143+ 0000
 144+ 0000              ;послать запрос ESP (CIPSEND);
 145+ 0000              ;вх: hl - адрес данных, de - длина данных
 146+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 147+ 0000              ;вых: ix - адрес в таблице соединений (ix+4 - флаг =1 - отправлено, 255 - ошибка)
 148+ 0000                  macro OS_ESP_SEND
 149+ 0000 ~                ld c,#0e
 150+ 0000 ~                rst #20
 151+ 0000                  endm
 152+ 0000
 153+ 0000              ;получить пакет ESP (+IPD);
 154+ 0000              ;вх: hl - адрес для данных
 155+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 156+ 0000              ;вых: ix - адрес в таблице соединений (ix+6 - флаг =1 - принято, 255 - ошибка)
 157+ 0000                  macro OS_ESP_GET
 158+ 0000 ~                ld c,#0f
 159+ 0000 ~                rst #20
 160+ 0000                  endm
 161+ 0000
 162+ 0000              ;ввод с консоли ----------------------
 163+ 0000
 164+ 0000              ;получить код нажатой клавиши
 165+ 0000                  macro OS_GET_CHAR ;read char from stdin (out: A=char, 255-no char)
 166+ 0000 ~                ld c,#10
 167+ 0000 ~                rst #20
 168+ 0000                  endm
 169+ 0000
 170+ 0000
 171+ 0000              ;процессы ----------------------------
 172+ 0000
 173+ 0000              ;запустить процесс
 174+ 0000              ;вх: hl - имя файла (заканчивается на 0)
 175+ 0000                  macro OS_PROC_RUN ;
 176+ 0000 ~                ld c,#11
 177+ 0000 ~                rst #20
 178+ 0000                  endm
 179+ 0000
 180+ 0000              ;установить фокус
 181+ 0000              ;вх: a - id процесса
 182+ 0000                  macro OS_PROC_SET_FOCUS ;
 183+ 0000 ~                ld c,#12
 184+ 0000 ~                rst #20
 185+ 0000                  endm
 186+ 0000
 187+ 0000              ;закрыть процесс
 188+ 0000              ;вх: A - ID процесса. Если A=0, закрыть текущий (себя)
 189+ 0000              ;останавливается процесс и освобождаются все его страницы памяти, файлы, соединения
 190+ 0000                  macro OS_PROC_CLOSE ;
 191+ 0000 ~                ld c,#13
 192+ 0000 ~                rst #20
 193+ 0000                  endm
 194+ 0000
 195+ 0000
 196+ 0000              ;прерывания --------------------------
 197+ 0000
 198+ 0000              ;установка адреса обработчика прерываний процесса;
 199+ 0000                  ; macro OS_SET_INTER ;(HL - address, A = 1 - On, A = 0 - Off)
 200+ 0000                  ; ld c,#14
 201+ 0000                  ; rst #20
 202+ 0000                  ; endm
 203+ 0000
 204+ 0000
 205+ 0000              ;плеер AY ----------------------------
 206+ 0000
 207+ 0000              ;инициализация плеера AY;
 208+ 0000                  macro OS_VTPL_INIT ;(HL - address music)
 209+ 0000 ~                ld c,#15
 210+ 0000 ~                rst #20
 211+ 0000                  endm
 212+ 0000
 213+ 0000              ;запустить плеер AY (система будет сама вызывать его каждое прерывание);
 214+ 0000                  macro OS_VTPL_PLAY ;()
 215+ 0000 ~                ld c,#16
 216+ 0000 ~                rst #20
 217+ 0000                  endm
 218+ 0000
 219+ 0000              ;заглушить плеер AY;
 220+ 0000                  macro OS_VTPL_MUTE ;()
 221+ 0000 ~                ld c,#17
 222+ 0000 ~                rst #20
 223+ 0000                  endm
 224+ 0000
 225+ 0000              ;получить значение переменной плеера;
 226+ 0000                  macro OS_GET_VTPL_SETUP ;(out: HL - setup address)
 227+ 0000 ~                ld c,#18
 228+ 0000 ~                rst #20
 229+ 0000                  endm
 230+ 0000
 231+ 0000
 232+ 0000              ;прочие ------------------------------
 233+ 0000
 234+ 0000
 235+ 0000              ;скопировать данные из страницы в страницу
 236+ 0000              ;вх: hl - откуда (абсолютный адрес 0-ffff); de - куда; ix - длина; a - страница слот2; b - страница слот3;
 237+ 0000                  macro OS_RAM_COPY
 238+ 0000 ~                ld c,#19
 239+ 0000 ~                rst #20
 240+ 0000                  endm
 241+ 0000
 242+ 0000              ;получить дополнительную страницу памяти;
 243+ 0000                  macro OS_GET_PAGE ;(out A - number page)
 244+ 0000 ~                ld c,#1a
 245+ 0000 ~                rst #20
 246+ 0000                  endm
 247+ 0000
 248+ 0000              ;включить страницу в слот 2 (#8000); предварительно зарезервировать страницу OS_GET_PAGE
 249+ 0000                  macro OS_SET_PAGE_SLOT2 ;(A - page number)
 250+ 0000 ~                ld c,#1b
 251+ 0000 ~                rst #20
 252+ 0000                  endm
 253+ 0000
 254+ 0000              ;включить страницу в слот 3 (#C000); предварительно зарезервировать страницу OS_GET_PAGE
 255+ 0000                  macro OS_SET_PAGE_SLOT3 ;(A - page number)
 256+ 0000 ~                ld c,#1c
 257+ 0000 ~                rst #20
 258+ 0000                  endm
 259+ 0000
 260+ 0000              ;включить экран N;
 261+ 0000              ;вх: A - номер экрана (5, 7, #39, #3a; 0 = текстовый)
 262+ 0000              ;переключать может только приложение в фокусе
 263+ 0000              ;если режим не текстовый, то приложение работает только когда в фокусе. Иначе временно останавливается.
 264+ 0000              ;при переключении процессов сохраняется только экран #39
 265+ 0000                  macro OS_SET_SCREEN ;
 266+ 0000 ~                ld c,#1d
 267+ 0000 ~                rst #20
 268+ 0000                  endm
 269+ 0000
 270+ 0000
 271+ 0000              ;получить номера страниц процесса;
 272+ 0000              ;вх:
 273+ 0000              ;вых: b, c - страницы в слотах 2, 3
 274+ 0000                  macro OS_GET_MAIN_PAGES ;
 275+ 0000 ~                ld c,#1e
 276+ 0000 ~                rst #20
 277+ 0000                  endm
 278+ 0000
 279+ 0000              ;получить значение системного таймера
 280+ 0000                  macro OS_GET_TIMER ;(out: HL, DE - timer)
 281+ 0000 ~                ld c,#1F
 282+ 0000 ~                rst #20
 283+ 0000                  endm
 284+ 0000
 285+ 0000
 286+ 0000
 287+ 0000                  ; macro OS_ ;
 288+ 0000                  ; ld c,#20
 289+ 0000                  ; rst #20
 290+ 0000                  ; endm
 291+ 0000
 292+ 0000
 293+ 0000              ;дисковые операции -------------------
 294+ 0000
 295+ 0000              ; менять напрямую что-то в таблице fcb из приложения не рекомендуется, только для чтения
 296+ 0000
 297+ 0000              ; fcbFAT (из руководства к монитору)
 298+ 0000              ; формат fcb для работы с FAT
 299+ 0000
 300+ 0000              ; +#00 8 имя файла
 301+ 0000              ; +#08 3 расширение файла
 302+ 0000              ; +#0B 1 атрибуты файла
 303+ 0000              ; +#0C 4 номер первого кластера файла/каталога
 304+ 0000              ; +#10 4 номер первого кластера каталога с этим файлом/каталогом
 305+ 0000              ; +#14 4 размер файла/каталога в байтах
 306+ 0000              ; +#18 4 указатель в файле
 307+ 0000              ; +#1C 1 для внутренних нужд
 308+ 0000              ; +#1D 1 для внутренних нужд
 309+ 0000              ; +#1E 1 резерв
 310+ 0000              ; +#1F 1 номер винчестера и раздела на нем
 311+ 0000              	; 1-0,nn номер раздела
 312+ 0000              	; 3-2,=00/01/10 HDD master/HDD slave/SD
 313+ 0000              	    ; значение %11 недопустимо
 314+ 0000
 315+ 0000              ;открыть файл для чтения или записи
 316+ 0000                  macro OS_FILE_OPEN ;HL - File name (out: A - id file, bc, de - size, IX - fcb)
 317+ 0000 ~                ld c,#21
 318+ 0000 ~                rst #20
 319+ 0000                  endm
 320+ 0000
 321+ 0000              ;создать файл
 322+ 0000                  macro OS_FILE_CREATE ;HL - File name  (out: A - id file, IX - fcb)
 323+ 0000 ~                ld c,#22
 324+ 0000 ~                rst #20
 325+ 0000                  endm
 326+ 0000
 327+ 0000              ;прочитать из файла
 328+ 0000                  macro OS_FILE_READ ;HL - address, A - id file, DE - length (out: bc - size readed)
 329+ 0000 ~                ld c,#23
 330+ 0000 ~                rst #20
 331+ 0000                  endm
 332+ 0000
 333+ 0000              ;записать в файл
 334+ 0000                  macro OS_FILE_WRITE ;HL - address, A - id file, DE - length (out: bc - size writed)
 335+ 0000 ~                ld c,#24
 336+ 0000 ~                rst #20
 337+ 0000                  endm
 338+ 0000
 339+ 0000              ;закрыть файл
 340+ 0000                  macro OS_FILE_CLOSE ;A - id file
 341+ 0000 ~                ld c,#25
 342+ 0000 ~                rst #20
 343+ 0000                  endm
 344+ 0000
 345+ 0000              ;чтение секторов текущего каталога
 346+ 0000              ; вх:
 347+ 0000                   ; hl - буфер для чтения
 348+ 0000                   ; de - относительный номер первого сектора каталога для чтения [0..nn]
 349+ 0000                   ; b - максимальное количество секторов для чтения
 350+ 0000              ; вых: cy=1, если были ошибки, код ошибки возвращается в аккумуляторе
 351+ 0000                     ; a=errRWnum
 352+ 0000                     ; a=errInvalidPart
 353+ 0000                     ; a=errFileEmpty
 354+ 0000                   ; cy=0, a=errEoF - каталог закончился
 355+ 0000                     ; hl - следующий адрес в буфере
 356+ 0000                     ; de - номер первого непрочитанного сектора
 357+ 0000                     ; b - не прочитано секторов
 358+ 0000                   ; cy=0 - считано успешно
 359+ 0000                     ; hl - следующий адрес в буфере
 360+ 0000                     ; de - номер первого непрочитанного сектора
 361+ 0000                     ; b=#00
 362+ 0000                  macro OS_DIR_READ ;
 363+ 0000 ~                ld c,#26
 364+ 0000 ~                rst #20
 365+ 0000                  endm
 366+ 0000
 367+ 0000              ;вход в каталог/выход в родительский каталог
 368+ 0000              	; Если путь не указан производится только настройка переменных драйвера,
 369+ 0000              	; при этом если передан дескриптор файла, текущий каталог не изменится)
 370+ 0000              	; Если пусть указан, в конец пути добавится название каталога (если это
 371+ 0000              	; переход в родительский, последнее имя в пути удалится).
 372+ 0000              	; Если передан дескриптор файла, текущий каталог не изменится, к пути
 373+ 0000              	; добавится имя файла
 374+ 0000              ; вх:
 375+ 0000                   ; hl - адрес пути (=#0000 - путь отсутствует)
 376+ 0000                   ; de - адрес дескриптора директории/файла
 377+ 0000              ; вых: a - если путь был указан, новая длина пути
 378+ 0000                  macro OS_DIR_OPEN ;
 379+ 0000 ~                ld c,#27
 380+ 0000 ~                rst #20
 381+ 0000                  endm
 382+ 0000
 383+ 0000              ;установка/чтение указателя в файле (Переменная +#18-#1b fcb)
 384+ 0000              ;проверки на допустимость значений не производится
 385+ 0000              ;вх: CY = 1 - установка; CY = 0 - чтение
 386+ 0000              ;вх: A - id файла
 387+ 0000              ;вх: de, hl - значения старшие быйты, младшие
 388+ 0000              ;вых: de, hl - значения старшие быйты, младшие
 389+ 0000                  macro OS_FILE_POSITION ;
 390+ 0000 ~                ld c,#28
 391+ 0000 ~                rst #20
 392+ 0000                  endm
 393+ 0000
 394+ 0000              ; поиск файла или каталога по заданному пути, начиная от корневого, со входом в подкаталоги
 395+ 0000              ;вх: hl - путь к файлу в формате ASCIZ (не более 250 байт, заканчивается нулем)
 396+ 0000              	 ;формат пути: \[DIR\DIR\..\DIR\]filename.ext	(можно без имени файла, только каталоги)
 397+ 0000              ;вх: a=#00/#FF - без установки каталога/с установкой найденного каталога текущим
 398+ 0000                  macro OS_FIND_PATH ;
 399+ 0000 ~                ld c,#29
 400+ 0000 ~                rst #20
 401+ 0000                  endm
 402+ 0000
 403+ 0000
# file closed: ../os_defs.asm
   3  0000                  org PROGSTART
   4  8000              asmOrg:
   5  8000 C3 8B A3         jp start
   6  8003
   7  8003              ; Generate version string
   8  8003                  LUA ALLPASS
   9  8003 ~                v = tostring(sj.get_define("V"))
  10  8003 ~                maj = string.sub(v, 1,1)
  11  8003 ~                min = string.sub(v, 2,2)
  12  8003 ~                sj.insert_define("VERSION_STRING", "\"" .. maj .. "." .. min .. "\"")
  13  8003                  ENDLUA
  14  8003
  15  8003                  include "vdp/index.asm"
# file opened: vdp/index.asm
   1+ 8003                  IFDEF TIMEX
   2+ 8003 ~                include "timex.asm"
   3+ 8003                  ENDIF
   4+ 8003
   5+ 8003                  IFDEF TIMEX80
   6+ 8003 ~                include "timex80.asm"
   7+ 8003                  ENDIF
   8+ 8003
   9+ 8003                  IFDEF ZXSCR
  10+ 8003 ~                include "zx.asm"
  11+ 8003                  ENDIF
  12+ 8003
  13+ 8003                  IFDEF ZSGMX
  14+ 8003                  include "zsgmx.asm"
# file opened: vdp/zsgmx.asm
   1++8003              COLOR=1
   2++8003              ;; ZS GMX screen driver (izzx)
   3++8003              	;define LINE_LIMIT 80
   4++8003                  module TextMode
   5++8003              init:
   6++8003                  ; ld hl, font_file, b, Dos.FMODE_READ
   7++8003                  ; call Dos.fopen
   8++8003                  ; push af
   9++8003                  ; ld bc, 2048, hl, font
  10++8003                  ; call Dos.fread
  11++8003                  ; pop af
  12++8003                  ; call Dos.fclose
  13++8003              	; xor a : out (#fe), a
  14++8003              	; call cls
  15++8003              	; ret
  16++8003              cls:
  17++8003              	OS_CLS
  17++8003 0E 00       >    ld c,#00
  17++8005 E7          >    rst #20
  18++8006 C9           	ret
  19++8007                  ; ld de, 0 : call gotoXY
  20++8007                  ; ;ld a, 7 : call Memory.setPage
  21++8007              	; ld a,#3b
  22++8007              	; call PageSlot3 ;включить страницу пикселей
  23++8007                  ; xor a : out (#fe), a
  24++8007                  ; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  25++8007              	; ld a,#7b
  26++8007              	; call PageSlot3 ;включить страницу атрибутов
  27++8007              	; ld a,(attr_screen) ;цвет
  28++8007              	; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  29++8007              	; call gmxscron ;включить расширенный экран
  30++8007              	; xor a
  31++8007              	; jp PageSlot3 ;вернуть страницу 0
  32++8007                  ;jp Memory.setPage
  33++8007
  34++8007
  35++8007              ; Set console coordinates
  36++8007              ; d = row(0..23), e = column (0..79)
  37++8007              gotoXY:
  38++8007              	OS_SET_XY
  38++8007 0E 01       >    ld c,#01
  38++8009 E7          >    rst #20
  39++800A              	;rr e
  40++800A              	; ld a, 0
  41++800A              	; ld (half_tile_screen), a
  42++800A                  ;ld (col_screen), de
  43++800A C9               ret
  44++800B
  45++800B              disable:
  46++800B                  ; Nothing to disable
  47++800B              	;call gmxscroff ;выключить расширенный экран
  48++800B C9               ret
  49++800C
  50++800C              ; H - line
  51++800C              ; A - char
  52++800C              fillLine: ;заполнение строки одним символом
  53++800C              	OS_FILL_LINE
  53++800C 0E 03       >    ld c,#03
  53++800E E7          >    rst #20
  54++800F C9           	ret
  55++8010                  ; push af
  56++8010                  ; ld d, h, e, 0 : call gotoXY
  57++8010                  ; pop af
  58++8010                  ; ld hl, fill_buff, de, fill_buff + 1, bc, 80-1, (hl), a : ldir
  59++8010                  ; ld hl, fill_buff : jp printZ
  60++8010
  61++8010              usualLine: ;на входе в A номер строки, которую надо покрасить обычным цветом
  62++8010 06 07        	ld b,#07 ;цвет
  63++8012              	OS_PAINT_LINE
  63++8012 0E 04       >    ld c,#04
  63++8014 E7          >    rst #20
  64++8015 C9           	ret
  65++8016                  ; ld b, a
  66++8016                  ; ld c, 0
  67++8016                  ; call bc_to_attr
  68++8016                  ; ;ld a, 7 : call Memory.setPage
  69++8016              	; push hl
  70++8016              	; ld a,#7b ;атрибуты
  71++8016              	; call PageSlot3
  72++8016              	; pop hl
  73++8016              	; ld a,(attr_screen) ;цвет
  74++8016                  ; ld (hl), a
  75++8016                  ; ld de, hl
  76++8016                  ; inc de
  77++8016                  ; ld bc, (80*8)-1
  78++8016                  ; ldir
  79++8016                  ; xor a : ;jp Memory.setPage
  80++8016              	; jp PageSlot3 ;вернуть страницу 0
  81++8016
  82++8016              highlightLine: ;на входе в A номер строки, которую надо покрасить другим цветом
  83++8016 06 0C        	ld b,#0c ;цвет
  84++8018              	OS_PAINT_LINE
  84++8018 0E 04       >    ld c,#04
  84++801A E7          >    rst #20
  85++801B C9           	ret
  86++801C                  ; ld b, a
  87++801C                  ; ld c, 0
  88++801C                  ; call bc_to_attr
  89++801C                  ; ;ld a, 7 : call Memory.setPage
  90++801C              	; push hl
  91++801C              	; ld a,#7b ;атрибуты
  92++801C              	; call PageSlot3
  93++801C              	; pop hl
  94++801C              	; ld a,(attr_screen2) ;цвет
  95++801C                  ; ld (hl), a
  96++801C                  ; ld de, hl
  97++801C                  ; inc de
  98++801C                  ; ld bc, (80*8)-1
  99++801C                  ; ldir
 100++801C                  ; xor a : ;jp Memory.setPage
 101++801C              	; jp PageSlot3 ;вернуть страницу 0
 102++801C
 103++801C              ; mvCR ;каретка вниз
 104++801C              	; ld de, (col_screen)
 105++801C              	; inc d
 106++801C              	; ld e, 0
 107++801C              	; ; ld a, 0
 108++801C              	; ; ld (half_tile_screen), a
 109++801C              	; jp gotoXY
 110++801C
 111++801C              ; Print just one symbol
 112++801C              ; A - symbol
 113++801C              putC
 114++801C              	OS_PRINT_CHARF
 114++801C D7          >	rst #10
 115++801D C9           	ret
 116++801E                  ; cp 13 : jp z, mvCR
 117++801E
 118++801E              	; ld hl, single_symbol
 119++801E              	; ld (hl), a
 120++801E              	; ;ld a, 7 : call Memory.setPage
 121++801E              	; ld a,#3b ;пиксели
 122++801E              	; call PageSlot3
 123++801E                  ; ld hl, single_symbol_print
 124++801E                  ; call printL
 125++801E                  ; xor a : ;jp Memory.setPage
 126++801E              	; jp PageSlot3 ;вернуть страницу 0
 127++801E
 128++801E              ; Put string
 129++801E              ; hl - string pointer that's begins from symbol count
 130++801E              printZ
 131++801E              	OS_PRINTZ
 131++801E 0E 09       >    ld c,#09
 131++8020 E7          >    rst #20
 132++8021 C9           	ret
 133++8022                  ; ld a, (hl) : and a : ret z
 134++8022                  ; push hl
 135++8022                  ; call putC
 136++8022                  ; pop hl
 137++8022                  ; inc hl
 138++8022                  ; jr printZ
 139++8022
 140++8022              ; printL
 141++8022                      ; ld	a, (hl)
 142++8022              		; and	a
 143++8022              		; ret	z
 144++8022
 145++8022              		; ; push	hl
 146++8022              		; ; call	calc_addr_scr
 147++8022              		; ; ld	a,(attr_screen)
 148++8022              		; ; ;ld	(hl),a ;покрасить символ
 149++8022              		; ; pop	hl
 150++8022
 151++8022              		; ;call	calc_addr_scr
 152++8022
 153++8022              		; ; ld	a,(half_tile_screen)
 154++8022              		; ; bit	0,a
 155++8022              		; ; ld	a,(hl)
 156++8022              		; ; jp	nz,print64_4
 157++8022              ; ;print80_3
 158++8022                      ; push    af
 159++8022              		; push	hl
 160++8022              		; ; ld a,#7b ;атрибуты
 161++8022              		; ; call PageSlot3
 162++8022              		; call	calc_addr_scr
 163++8022              		; ; ld	a,(attr_screen)
 164++8022              		; ; ld	(hl),a ;покрасить символ
 165++8022              		; ld d,h ;координаты экрана в DE
 166++8022              		; ld e,l
 167++8022              		; ; ld a,#3b ;пиксели
 168++8022              		; ; call PageSlot3
 169++8022              		; pop	hl
 170++8022
 171++8022                      ; inc     hl
 172++8022                      ; push    hl
 173++8022
 174++8022                      ; ld      a,(hl)
 175++8022              		; ld	l,a
 176++8022              		; ld	h,0
 177++8022              		; add	hl,hl
 178++8022              		; add	hl,hl
 179++8022              		; add	hl,hl
 180++8022                      ; ld      bc,font
 181++8022                      ; add     hl,bc
 182++8022
 183++8022                      ; ;push    de
 184++8022
 185++8022                      ; ld      b,8
 186++8022              		; ; xor	a
 187++8022              		; ; ld	(de),a
 188++8022              ; print80_1
 189++8022              	; ;inc     d
 190++8022
 191++8022              	; ld      a,(hl)
 192++8022              	; ;and	#f0
 193++8022              	; ld      (de),a
 194++8022              	; inc     hl
 195++8022
 196++8022              	; push hl ;на строку пикселей вниз
 197++8022              	; ld hl,80
 198++8022              	; add hl,de
 199++8022              	; ex de,hl
 200++8022              	; pop hl
 201++8022
 202++8022              	; djnz    print80_1
 203++8022
 204++8022              	; ;inc	d
 205++8022              	; ; push hl
 206++8022              	; ; ld hl,80
 207++8022              	; ; add hl,de
 208++8022              	; ; ex de,hl
 209++8022              	; ; pop hl
 210++8022
 211++8022              	; ; xor	a
 212++8022              	; ; ld	(de),a
 213++8022
 214++8022              	; ; ld	a,1
 215++8022              	; ; ld	(half_tile_screen),a
 216++8022
 217++8022              	; ;pop     de
 218++8022              	; pop     hl
 219++8022              	; pop     af
 220++8022
 221++8022              	; ;dec     a
 222++8022              	; ; ret     ;z
 223++8022
 224++8022              ; ; print64_4
 225++8022              	; ; push    af
 226++8022
 227++8022              	; ; inc     hl
 228++8022              	; ; push    hl
 229++8022
 230++8022              	; ; ld      a,(hl)
 231++8022              	; ; ld	l,a
 232++8022              	; ; ld	h,0
 233++8022              	; ; add	hl,hl
 234++8022              	; ; add	hl,hl
 235++8022              	; ; add	hl,hl
 236++8022              	; ; ld      bc,font
 237++8022              	; ; add     hl,bc
 238++8022
 239++8022              	; ; push    de
 240++8022
 241++8022              	; ; ld      b,6
 242++8022              	; ; xor	a
 243++8022              	; ; ld	(de),a
 244++8022              ; ; print64_2
 245++8022              	; ; ;inc     d
 246++8022              	; ; push hl
 247++8022              	; ; ld hl,80
 248++8022              	; ; add hl,de
 249++8022              	; ; ex de,hl
 250++8022              	; ; pop hl
 251++8022              	; ; ld      a,(hl)
 252++8022              	; ; ;and     #0f
 253++8022              	; ; ld      c,a
 254++8022              	; ; ld      a,(de)
 255++8022              	; ; or      c
 256++8022              	; ; ld      (de),a
 257++8022              	; ; inc     hl
 258++8022              	; ; djnz    print64_2
 259++8022
 260++8022              	; ; ;inc	d
 261++8022              	; ; push hl
 262++8022              	; ; ld hl,80
 263++8022              	; ; add hl,de
 264++8022              	; ; ex de,hl
 265++8022              	; ; pop hl
 266++8022              	; ; xor	a
 267++8022              	; ; ld	(de),a
 268++8022
 269++8022              	; ; ld	(half_tile_screen),a
 270++8022
 271++8022              	; ; pop     de
 272++8022
 273++8022              	; ; call	move_cr64
 274++8022
 275++8022              	; ; pop     hl
 276++8022              	; ; pop     af
 277++8022              	; ; dec     a
 278++8022
 279++8022              	; ; jp      nz,print64_3
 280++8022
 281++8022              	; ; ret
 282++8022
 283++8022              ; ; move cursor на одну позицию вперёд
 284++8022              ; move_cr80
 285++8022              	; ;inc	de
 286++8022
 287++8022              	; ld	hl,col_screen
 288++8022              	; inc	(hl) ;увеличить столбец
 289++8022              	; ld	a,(hl)
 290++8022
 291++8022              	; cp	80
 292++8022              	; ret	c
 293++8022
 294++8022              	; xor	a
 295++8022              	; ;ld	(half_tile_screen),a
 296++8022              	; ld	(hl),a
 297++8022              	; ld	c,a
 298++8022
 299++8022              	; inc	hl ;на переменную row
 300++8022              	; inc	(hl)
 301++8022              	; ld	a,(hl)
 302++8022              	; ld	b,a
 303++8022
 304++8022              	; cp	24
 305++8022              	; jp	c,move_cr80_01
 306++8022
 307++8022              	; ld	a,23
 308++8022              	; ld	(hl),a
 309++8022              	; ld	b,a
 310++8022
 311++8022              	; ; push	bc
 312++8022              	; ; call	scroll_up8
 313++8022              	; ; pop	bc
 314++8022
 315++8022              ; move_cr80_01
 316++8022              	; ; call	calc_addr_scr
 317++8022              	; ; ret
 318++8022
 319++8022              ; calc_addr_scr	;определение адреса экрана по координатам символа
 320++8022              	; ld	bc,(col_screen)
 321++8022              ; bc_to_attr:
 322++8022              	; ld h,0
 323++8022              	; ld l,b ;строка
 324++8022              	; add hl,hl ;*2
 325++8022              	; ld de,table_addr_scr
 326++8022              	; add hl,de
 327++8022              	; ld e,(hl)
 328++8022              	; inc hl
 329++8022              	; ld d,(hl) ;узнали координаты строки
 330++8022              	; ld h,0
 331++8022              	; ld l,c ;колонка
 332++8022              	; add hl,de ;узнали адрес символа
 333++8022              	; ; ld      a,b
 334++8022              	; ; ld      d,a
 335++8022              	; ; rrca
 336++8022              	; ; rrca
 337++8022              	; ; rrca
 338++8022              	; ; and     a,224
 339++8022              	; ; add     a,c
 340++8022              	; ; ld      e,a
 341++8022              	; ; ld      a,d
 342++8022              	; ; and     24
 343++8022              	; ; or      #c0
 344++8022              	; ; ld      d,a
 345++8022              	; ret
 346++8022
 347++8022              ; ; calc_addr_attr
 348++8022              	; ; ld	bc,(col_screen)
 349++8022              ; ; bc_to_attr:
 350++8022              	; ; ld	a,b
 351++8022              	; ; rrca
 352++8022              	; ; rrca
 353++8022              	; ; rrca
 354++8022              	; ; ld	l,a
 355++8022              	; ; and	31
 356++8022              	; ; or	#d8
 357++8022              	; ; ld	h,a
 358++8022              	; ; ld	a,l
 359++8022              	; ; and	252
 360++8022              	; ; or	c
 361++8022              	; ; ld	l,a
 362++8022              	; ; ret
 363++8022
 364++8022              ; ; scroll_up8	;
 365++8022              	; ; ld	hl,table_addr_scr
 366++8022              	; ; ld	b,184
 367++8022
 368++8022              ; ; scroll_up8_01
 369++8022              	; ; push	bc
 370++8022
 371++8022              	; ; ld	e,(hl)
 372++8022              	; ; inc	hl
 373++8022              	; ; ld	d,(hl)
 374++8022              	; ; inc	hl
 375++8022
 376++8022              	; ; push	hl
 377++8022
 378++8022              	; ; ld	bc,14
 379++8022              	; ; add	hl,bc
 380++8022              	; ; ld	c,(hl)
 381++8022              	; ; inc	hl
 382++8022              	; ; ld	b,(hl)
 383++8022
 384++8022              	; ; ld	h,b
 385++8022              	; ; ld	l,c
 386++8022
 387++8022              	; ; ld	bc,32
 388++8022              	; ; ldir
 389++8022
 390++8022              	; ; pop	hl
 391++8022              	; ; pop	bc
 392++8022              	; ; djnz	scroll_up8_01
 393++8022
 394++8022              	; ; ld	b,8
 395++8022
 396++8022              ; ; scroll_up8_02
 397++8022              	; ; push	bc
 398++8022
 399++8022              	; ; ld	e,(hl)
 400++8022              	; ; inc	hl
 401++8022              	; ; ld	d,(hl)
 402++8022              	; ; inc	hl
 403++8022
 404++8022              	; ; push	hl
 405++8022
 406++8022              	; ; ld	h,d
 407++8022              	; ; ld	l,e
 408++8022              	; ; inc	de
 409++8022              	; ; ld	(hl),0
 410++8022              	; ; ld	bc,31
 411++8022              	; ; ldir
 412++8022
 413++8022              	; ; pop	hl
 414++8022              	; ; pop	bc
 415++8022              	; ; djnz	scroll_up8_02
 416++8022              	; ; ld	de,#D800, hl,#D820, bc,736
 417++8022              	; ; ldir
 418++8022              	; ; ld	a,(de)
 419++8022              	; ; ld	hl,#dae0, de,#dae1, (hl),a, bc,31
 420++8022              	; ; ldir
 421++8022
 422++8022              	; ; ret
 423++8022
 424++8022
 425++8022              ; gmxscron
 426++8022                          ; ld      bc,#7efd
 427++8022                          ; ld      a,#c8
 428++8022                          ; out     (c),a
 429++8022                          ; ; ld      bc,#7ffd
 430++8022                          ; ; ld      a,#10    ;5 screen
 431++8022                          ; ; out     (c),a
 432++8022                          ; ret
 433++8022
 434++8022              ; ; gmxscron2
 435++8022                          ; ; ld      bc,#7efd
 436++8022                          ; ; ld      a,#c8
 437++8022                          ; ; out     (c),a
 438++8022                          ; ; ld      bc,#7ffd
 439++8022                          ; ; ld      a,#18    ;7 screen
 440++8022                          ; ; out     (c),a
 441++8022                          ; ; ret
 442++8022
 443++8022              ; gmxscroff
 444++8022                          ; ld      bc,#7efd
 445++8022                          ; ld      a,#c0
 446++8022                          ; out     (c),a
 447++8022                          ; ; ld      bc,#7ffd
 448++8022                          ; ; ld      a,#10    ;5 screen
 449++8022                          ; ; out     (c),a
 450++8022                          ; ret
 451++8022
 452++8022
 453++8022              ; PageSlot3
 454++8022              ; ; драйвер памяти для TR-DOS Navigator
 455++8022              ; ; и Scorpion GMX 2Mb
 456++8022                       ; ; org  #5b00
 457++8022                       ; ; jr   pag_on
 458++8022                       ; ; jr   clock
 459++8022                       ; ; db   #00
 460++8022                       ; ; db   #00
 461++8022
 462++8022                       ; ;push hl
 463++8022                       ; ld   hl,table
 464++8022                       ; add  a,l
 465++8022                       ; jr   nc,PageSlot3_1
 466++8022                       ; inc  h          ;коррекция
 467++8022              ; PageSlot3_1  ld   l,a
 468++8022                       ; ld   a,(hl)
 469++8022                       ; ;pop  hl
 470++8022                       ; ;cp   #ff
 471++8022                       ; ;scf
 472++8022                       ; ;ret  z
 473++8022                       ; ;push bc
 474++8022                       ; push af
 475++8022                       ; rlca
 476++8022                       ; and  #10
 477++8022                       ; ld   bc,#1ffd
 478++8022              ; PageSlot3DOS
 479++8022              		 ; ;or #00 ; #04 тут выбор ПЗУ TRDOS
 480++8022                       ; out  (c),a
 481++8022                       ; pop  af
 482++8022                       ; push af
 483++8022                       ; and  #07
 484++8022              ; PageSlot3Scr ;тут выбор экрана и ПЗУ
 485++8022                       ; or   #18 ;#0 ;#18
 486++8022                       ; ld   b,#7f
 487++8022                       ; out  (c),a
 488++8022                       ; pop  af
 489++8022                       ; rrca
 490++8022                       ; rrca
 491++8022                       ; rrca
 492++8022                       ; rrca
 493++8022                       ; and  #07
 494++8022                       ; ld   b,#df
 495++8022                       ; out  (c),a
 496++8022                       ; ;pop  hl
 497++8022                       ; ret
 498++8022              ; ; clock    ld   d,%00100000
 499++8022                       ; ; rst  8
 500++8022                       ; ; db   #89
 501++8022                       ; ; ret
 502++8022
 503++8022                       ; ; org  #5b5c ; здесь системная переменая
 504++8022                       ; ; db   #10
 505++8022              ; ;все страницы
 506++8022              ; table    db   #00,#01,#02,#03,#04,#05,#06,#07,#08,#09
 507++8022                       ; db   #0a,#0b,#0c,#0d,#0e
 508++8022                       ; db   #0f,#10,#11,#12,#13,#14
 509++8022                       ; db   #15,#16,#17,#18,#19,#1a
 510++8022                       ; db   #1b,#1c,#1d,#1e,#1f,#20
 511++8022                       ; db   #21,#22,#23,#24,#25,#26
 512++8022                       ; db   #27,#28,#29,#2a,#2b,#2c
 513++8022                       ; db   #2d,#2e,#2f,#30,#31,#32
 514++8022                       ; db   #33,#34,#35,#36,#37,#38,#39
 515++8022                       ; db   #3a,#3b,#3c,#3d,#3e,#3f,#40
 516++8022                       ; db   #41,#42,#43,#44,#45,#46
 517++8022                       ; db   #47,#48,#49,#4a,#4b,#4c
 518++8022
 519++8022                       ; db   #4d,#4e,#4f,#50,#51,#52
 520++8022                       ; db   #53,#54,#55,#56,#57,#58
 521++8022                       ; db   #59,#5a,#5b,#5c,#5d,#5e
 522++8022                       ; db   #5f,#60,#61,#62,#63,#64
 523++8022                       ; db   #65,#66,#67,#68,#69,#6a
 524++8022                       ; db   #6b,#6c,#6d,#6e,#6f,#70
 525++8022                       ; db   #71,#72,#73,#74,#75,#76
 526++8022                       ; db   #77,#78,#79,#7a,#7b,#7c,#7d,#7e
 527++8022                       ; db   #7f
 528++8022
 529++8022                       ; db   #ff ;конец таблицы
 530++8022
 531++8022
 532++8022
 533++8022              ; font equ #4000 ; Using ZX-Spectrum screen as font buffer
 534++8022              ; font_file db "data/font.bin", 0
 535++8022
 536++8022
 537++8022              ; table_addr_scr	;адреса строк текста
 538++8022              	; defw	#c000 ;0
 539++8022              	; defw	#c280
 540++8022              	; defw	#c500
 541++8022              	; defw	#c780
 542++8022              	; defw	#ca00
 543++8022              	; defw	#cc80
 544++8022              	; defw	#cf00
 545++8022              	; defw	#d180
 546++8022
 547++8022              	; defw	#d400 ;8
 548++8022              	; defw	#d680
 549++8022              	; defw	#d900
 550++8022              	; defw	#db80
 551++8022              	; defw	#de00
 552++8022              	; defw	#e080
 553++8022              	; defw	#e300
 554++8022              	; defw	#e580
 555++8022
 556++8022              	; defw	#e800 ;16
 557++8022              	; defw	#ea80
 558++8022              	; defw	#ed00
 559++8022              	; defw	#ef80
 560++8022              	; defw	#f200
 561++8022              	; defw	#f480
 562++8022              	; defw	#f700
 563++8022              	; defw	#f980
 564++8022
 565++8022              	; defw	#fc00 ;24
 566++8022              	; defw	#fe80 ;25 вне экрана
 567++8022
 568++8022
 569++8022              ; col_screen			db	0	;столбец
 570++8022              ; row_screen			db	0	;строка
 571++8022              ; ;half_tile_screen	db	0
 572++8022              ; attr_screen			db	07	;основной цвет
 573++8022              ; attr_screen2		db	#c	;другой цвет
 574++8022
 575++8022              ; ;col_screen_temp			dw	0
 576++8022              ; ;half_tile_screen_temp	db	0
 577++8022
 578++8022              ; single_symbol_print db 1
 579++8022              ; single_symbol 		db 0
 580++8022
 581++8022              ; fill_buff ds 80+1
 582++8022
 583++8022                  endmodule
# file closed: vdp/zsgmx.asm
  15+ 8022                  ENDIF
# file closed: vdp/index.asm
  16  8022                  include "utils/index.asm"
# file opened: utils/index.asm
   1+ 8022                  include "atoi.asm"
# file opened: utils/atoi.asm
   1++8022              ; DE - buffer
   2++8022              ; HL - output
   3++8022              atohl:
   4++8022 21 00 00         ld hl, 0
   5++8025              .loop
   6++8025 1A               ld a, (de)
   7++8026 13               inc de
   8++8027                  ; Sepparators
   9++8027 C5 E5            push bc, hl
  10++8029 01 05 00             ld bc, sepparators_len
  11++802C 21 44 80             ld hl, sepparators
  12++802F ED B1                cpir
  13++8031 E1 C1            pop hl, bc
  14++8033 C8               ret z
  15++8034
  16++8034 D6 30            sub '0'
  17++8036
  18++8036 C5               push bc
  19++8037 4D                   ld c, l
  20++8038 44                   ld b, h
  21++8039
  22++8039 29                   add hl, hl
  23++803A 29                   add hl, hl
  24++803B 09                   add hl, bc
  25++803C 29                   add hl, hl
  26++803D 4F                   ld c, a
  27++803E 06 00                ld b, 0
  28++8040 09                   add hl, bc
  29++8041 C1               pop bc
  30++8042 18 E1            jr .loop
  31++8044
# file closed: utils/atoi.asm
   2+ 8044                  include "constants.asm"
# file opened: utils/constants.asm
   1++8044              TAB = 9
   2++8044              CR = 13
   3++8044              LF = 10
   4++8044              NULL = 0
   5++8044              SPACE = ' '
   6++8044              ESC = 27
   7++8044
   8++8044                  IFNDEF TIMEX80
   9++8044              MIME_DOWNLOAD = 1
  10++8044              MIME_LINK     = 2
  11++8044              MIME_TEXT     = 3
  12++8044              MIME_IMAGE    = 6
  13++8044              MIME_MUSIC    = 5
  14++8044              MIME_INPUT    = 4
  15++8044              MIME_MOD      = 7
  16++8044
  17++8044              BORDER_TOP    = 9
  18++8044              BORDER_BOTTOM = 8
  19++8044                  ELSE
  20++8044 ~            MIME_DOWNLOAD = #19
  21++8044 ~            MIME_LINK = #1A
  22++8044 ~            MIME_TEXT = #10
  23++8044 ~            MIME_IMAGE = #01
  24++8044 ~            MIME_MUSIC = #0e
  25++8044 ~            MIME_INPUT = #b3
  26++8044 ~            MIME_MOD = #0d
  27++8044 ~
  28++8044 ~            BORDER_TOP = #b2
  29++8044 ~            BORDER_BOTTOM = #b1
  30++8044 ~
  31++8044                  ENDIF
  32++8044
  33++8044 0D 0A 09 00  sepparators db CR, LF, TAB, NULL, SPACE
  33++8048 20
  34++8049              sepparators_len = $ - sepparators
# file closed: utils/constants.asm
   3+ 8049                  include "strutils.asm"
# file opened: utils/strutils.asm
   1++8049              ; de - pointer
   2++8049              ; hl - count
   3++8049              strlen:
   4++8049 21 00 00         ld hl, 0
   5++804C              .loop
   6++804C 1A               ld a, (de)
   7++804D A7               and a
   7++804E 28 04          jr z, .exit
   8++8050 23               inc hl
   9++8051 13               inc de
  10++8052 18 F8            jr .loop
  11++8054              .exit
  12++8054 C9               ret
  13++8055
  14++8055                  module CompareBuff
  15++8055
  16++8055              ; Pushes A to buffer
  17++8055              push
  18++8055 F5               push af
  19++8056 06 20            ld b, 32
  19++8058 21 A1 80       ld hl, buffer + 1
  19++805B 11 A0 80       ld de, buffer
  20++805E              .loop
  21++805E 7E               ld a, (hl)
  21++805F 12             ld (de), a
  21++8060 23             inc hl
  21++8061 13             inc de
  21++8062 10 FA          djnz .loop
  22++8064 F1               pop af
  23++8065 21 BF 80         ld hl, buffer + 31
  23++8068 77             ld (hl), a
  24++8069 C9               ret
  25++806A
  26++806A              ; HL - Compare string(null terminated)
  27++806A              ; A - 0 NOT Found
  28++806A              ;     1 Found
  29++806A              search:
  30++806A 06 00            ld b, 0
  30++806C E5             push hl
  31++806D              .loop:
  32++806D 7E               ld a, (hl)
  32++806E 23             inc hl
  32++806F 04             inc b
  32++8070 A7             and a
  32++8071 C2 6D 80       jp nz, .loop
  33++8074 05               dec b
  33++8075 E1             pop hl
  33++8076 C5             push bc
  33++8077 E5             push hl
  34++8078 E1               pop hl
  35++8079 11 C0 80         ld de, buffer + 32
  36++807C              .sourceLoop
  37++807C 1B               dec de
  37++807D 10 FD          djnz .sourceLoop
  38++807F C1               pop bc
  39++8080              .compare
  40++8080 C5               push bc
  40++8081 F5             push af
  41++8082 1A               ld a, (de)
  41++8083 47             ld b, a
  42++8084 F1               pop af
  42++8085 7E             ld a, (hl)
  42++8086 B8             cp b
  42++8087 C1             pop bc
  42++8088 3E 00          ld a, 0
  42++808A C0             ret nz
  43++808B 13               inc de
  43++808C 23             inc hl
  44++808D 10 F1            djnz .compare
  45++808F 3E 01            ld a, 1
  46++8091 C9               ret
  47++8092
  48++8092              clear:
  49++8092 AF               xor a
  49++8093 21 A0 80       ld hl, buffer
  49++8096 11 A1 80       ld de, buffer + 1
  49++8099 01 20 00       ld bc, 32
  49++809C 77             ld (hl), a
  49++809D ED B0          ldir
  50++809F C9               ret
  51++80A0
  52++80A0 00 00 00...  buffer ds 32
  53++80C0
  54++80C0                  endmodule
# file closed: utils/strutils.asm
   4+ 80C0                  include "screen.asm"
# file opened: utils/screen.asm
   1++80C0                  IFNDEF LINE_LIMIT
   2++80C0              LINE_LIMIT = 60
   3++80C0                  ENDIF
   4++80C0              ; HL - string pointer
   5++80C0              print70Text:
   6++80C0 06 3C            ld b, LINE_LIMIT
   7++80C2              .loop
   8++80C2 7E               ld a, (hl)
   9++80C3 A7               and a
   9++80C4 C8             ret z
  10++80C5 FE 0D            cp 13
  10++80C7 C8             ret z
  11++80C8 FE 0A            cp 10
  11++80CA C8             ret z
  12++80CB C5               push bc
  13++80CC E5               push hl
  14++80CD CD 1C 80         call TextMode.putC
  15++80D0 E1               pop hl
  16++80D1 23               inc hl
  17++80D2 C1               pop bc
  18++80D3 05               dec b
  19++80D4 78               ld a, b
  19++80D5 A7             and a
  19++80D6 C8             ret z
  20++80D7 C3 C2 80         jp .loop
  21++80DA
  22++80DA              ; HL - string pointer
  23++80DA              print70Goph:
  24++80DA 06 3C            ld b, LINE_LIMIT
  25++80DC              .loop
  26++80DC 7E               ld a, (hl)
  26++80DD FE 09          cp 09
  26++80DF C8             ret z
  27++80E0 A7               and a
  27++80E1 C8             ret z
  28++80E2 C5               push bc
  29++80E3 E5               push hl
  30++80E4 CD 1C 80         call TextMode.putC
  31++80E7 E1               pop hl
  32++80E8 23               inc hl
  33++80E9 C1               pop bc
  34++80EA 05               dec b
  35++80EB 78               ld a, b
  35++80EC A7             and a
  35++80ED C8             ret z
  36++80EE C3 DC 80         jp .loop
# file closed: utils/screen.asm
# file closed: utils/index.asm
  17  80F1                  include "gopher/render/index.asm"
# file opened: gopher/render/index.asm
   1+ 80F1                  MODULE Render
   2+ 80F1              PER_PAGE = 19
   3+ 80F1              CURSOR_OFFSET = 3
   4+ 80F1                  include "row.asm"
# file opened: gopher/render/row.asm
   1++80F1              ; A - row number
   2++80F1              ; HL - pointer to row
   3++80F1              renderRow:
   4++80F1 C6 03            add CURSOR_OFFSET
   5++80F3 57 1E 00         ld d, a, e, 0
   5++80F6 CD 07 80       call TextMode.gotoXY
   6++80F9 7E               ld a, (hl)
   7++80FA E5               push hl
   8++80FB CD 06 81         call getIcon
   9++80FE CD 1C 80         call TextMode.putC
  10++8101 E1               pop hl
  11++8102 23               inc hl
  12++8103 C3 DA 80         jp print70Goph
  13++8106
  14++8106              ; A - gopher id char
  15++8106              getIcon:
  16++8106 FE 69            cp 'i'
  16++8108 CA 22 81       jp z, .info
  17++810B FE 39            cp '9'
  17++810D CA 25 81       jp z, .down
  18++8110 FE 31            cp '1'
  18++8112 CA A5 81       jp z, .page
  19++8115 FE 30            cp '0'
  19++8117 CA A8 81       jp z, .text
  20++811A FE 37            cp '7'
  20++811C CA AB 81       jp z, .input
  21++811F 3E 20            ld a, ' '
  22++8121 C9               ret
  23++8122              .info
  24++8122 3E 20            ld a, SPACE
  24++8124 C9             ret
  25++8125              .down
  26++8125 54 5D            ld de, hl
  27++8127 01 FF 00 3E      ld bc, #ff, a, TAB
  27++812B 09
  27++812C ED B1          cpir
  28++812E 78               ld a, b
  28++812F B1             or c
  28++8130 28 70          jr z, .downExit
  29++8132 D5               push de
  30++8133              .nameLoop
  31++8133 7E               ld a, (hl)
  31++8134 A7             and a
  31++8135 28 10          jr z, .check
  32++8137 FE 09            cp TAB
  32++8139 28 0C          jr z, .check
  33++813B FE 0D            cp CR
  33++813D 28 08          jr z, .check
  34++813F E5               push hl
  35++8140 CD 55 80         call CompareBuff.push
  36++8143 E1               pop hl
  37++8144 23               inc hl
  38++8145 18 EC            jr .nameLoop
  39++8147              .check
  40++8147 3A E7 81     	ld a,(saveMode+1);фикс обход открытия файлов, чтобы их скачать по кнопке Caps
  41++814A B7           	or a
  42++814B 20 54        	jr nz,.checkExit
  43++814D 21 BA 81         ld hl, scrExt1
  43++8150 CD 6A 80       call CompareBuff.search
  43++8153 A7             and a
  43++8154 20 58          jr nz, .image
  44++8156 21 BF 81         ld hl, scrExt2
  44++8159 CD 6A 80       call CompareBuff.search
  44++815C A7             and a
  44++815D 20 4F          jr nz, .image
  45++815F              	OS_GET_VTPL_SETUP
  45++815F 0E 18       >    ld c,#18
  45++8161 E7          >    rst #20
  46++8162 3E 03            ld a, 3
  46++8164
  47++8164 77           	ld (hl), a ; 0 bit - looping, 1 bit - pt2 file
  48++8165 21 CE 81         ld hl, pt2Ext1
  48++8168 CD 6A 80       call CompareBuff.search
  48++816B A7             and a
  48++816C 20 44          jr nz, .music
  49++816E 21 D3 81         ld hl, pt2Ext2
  49++8171 CD 6A 80       call CompareBuff.search
  49++8174 A7             and a
  49++8175 20 3B          jr nz, .music
  50++8177              	OS_GET_VTPL_SETUP
  50++8177 0E 18       >    ld c,#18
  50++8179 E7          >    rst #20
  51++817A 3E 01            ld a, 1
  51++817C
  52++817C 77           	ld (hl), a
  53++817D 21 C4 81         ld hl, pt3Ext1
  53++8180 CD 6A 80       call CompareBuff.search
  53++8183 A7             and a
  53++8184 20 2C          jr nz, .music
  54++8186 21 C9 81         ld hl, pt3Ext2
  54++8189 CD 6A 80       call CompareBuff.search
  54++818C A7             and a
  54++818D 20 23          jr nz, .music
  55++818F
  56++818F                  ; General Sound support
  57++818F                  ifdef GS
  58++818F 21 D8 81         ld hl, modExt1
  58++8192 CD 6A 80       call CompareBuff.search
  58++8195 A7             and a
  58++8196 20 1E          jr nz, .mod
  59++8198 21 DD 81         ld hl, modExt2
  59++819B CD 6A 80       call CompareBuff.search
  59++819E A7             and a
  59++819F 20 15          jr nz, .mod
  60++81A1                  endif
  61++81A1              .checkExit
  62++81A1 E1               pop hl
  63++81A2              .downExit
  64++81A2 3E 01            ld a, MIME_DOWNLOAD
  64++81A4 C9             ret
  65++81A5              .page
  66++81A5 3E 02            ld a, MIME_LINK
  66++81A7 C9             ret
  67++81A8              .text
  68++81A8 3E 03            ld a, MIME_TEXT
  68++81AA C9             ret
  69++81AB              .input
  70++81AB 3E 04            ld a, MIME_INPUT
  70++81AD C9             ret
  71++81AE              .image
  72++81AE E1               pop hl
  72++81AF 3E 06          ld a, MIME_IMAGE
  72++81B1 C9             ret
  73++81B2              .music
  74++81B2 E1               pop hl
  74++81B3 3E 05          ld a, MIME_MUSIC
  74++81B5 C9             ret
  75++81B6              .mod
  76++81B6 E1               pop hl
  76++81B7 3E 07          ld a, MIME_MOD
  76++81B9 C9             ret
  77++81BA
  78++81BA 2E 73 63 72  scrExt1 db ".scr", 0
  78++81BE 00
  79++81BF 2E 53 43 52  scrExt2 db ".SCR", 0
  79++81C3 00
  80++81C4
  81++81C4 2E 70 74 33  pt3Ext1 db ".pt3", 0
  81++81C8 00
  82++81C9 2E 50 54 33  pt3Ext2 db ".PT3", 0
  82++81CD 00
  83++81CE 2E 70 74 32  pt2Ext1 db ".pt2", 0
  83++81D2 00
  84++81D3 2E 50 54 32  pt2Ext2 db ".PT2", 0
  84++81D7 00
  85++81D8
  86++81D8 2E 6D 6F 64  modExt1 db ".mod", 0
  86++81DC 00
  87++81DD 2E 4D 4F 44  modExt2 db ".MOD", 0
  87++81E1 00
  88++81E2
  89++81E2              toggleSaveMode
  90++81E2 F5           			push af
  91++81E3 CD D1 86     			call Console.waitForKeyUp
  92++81E6 3E 00        saveMode	ld a,0 ; Флаг Open/Save files
  93++81E8 EE 01        			xor 1
  94++81EA 32 E7 81     			ld (saveMode+1),a
  95++81ED F1           			pop af
  96++81EE C9           			ret
# file closed: gopher/render/row.asm
   5+ 81EF                  include "buffer.asm"
# file opened: gopher/render/buffer.asm
   1++81EF              ; B - line count
   2++81EF              findLine:
   3++81EF 21 8B A3         ld hl, outputBuffer
   4++81F2              findLine2:
   5++81F2 AF               xor a
   5++81F3 B0             or b
   5++81F4 28 1D          jr z, .checkEmpty
   6++81F6              .loop
   7++81F6 7E               ld a, (hl)
   7++81F7 A7             and a
   7++81F8 28 1C          jr z, .nope
   8++81FA FE 0D            cp 13
   8++81FC 23             inc hl
   8++81FD 28 0C          jr z, .checkLF
   9++81FF FE 0A            cp 10
   9++8201 28 02          jr z, .nextCheck
  10++8203 18 F1            jr .loop
  11++8205              .nextCheck
  12++8205 A7               and a
  12++8206 28 0E          jr z, .nope
  13++8208 10 EC            djnz .loop
  14++820A C9               ret
  15++820B              .checkLF
  16++820B 7E               ld a, (hl)
  17++820C FE 0A            cp 10
  17++820E 20 F5          jr nz, .nextCheck
  18++8210 23               inc hl
  19++8211 18 F2            jr  .nextCheck
  20++8213              .checkEmpty
  21++8213 7E               ld a, (hl)
  21++8214 A7             and a
  21++8215 C0             ret nz
  22++8216              .nope
  23++8216 21 00 00         ld hl, 0
  23++8219 C9             ret
# file closed: gopher/render/buffer.asm
   6+ 821A                  include "ui.asm"
# file opened: gopher/render/ui.asm
   1++821A              prepareScreen:
   2++821A CD 03 80         call TextMode.cls
   3++821D 21 46 83         ld hl, header
   3++8220 CD 1E 80       call TextMode.printZ
   4++8223 21 4A 82         ld hl, toolbox
   4++8226 CD 1E 80       call TextMode.printZ
   5++8229 21 59 9D         ld hl, hostName
   5++822C CD 1E 80       call TextMode.printZ
   6++822F 11 00 17         ld de, #1700
   6++8232 CD 07 80       call TextMode.gotoXY
   6++8235 21 56 82       ld hl, footer
   6++8238 CD 1E 80       call TextMode.printZ
   7++823B
   8++823B AF               xor a
   8++823C CD 16 80       call TextMode.highlightLine
   9++823F 3E 01            ld a, 1
   9++8241 CD 16 80       call TextMode.highlightLine
  10++8244 3E 17            ld a, #17
  10++8246 CD 16 80       call TextMode.highlightLine
  11++8249 C9               ret
  12++824A
  13++824A
  14++824A 20 5B 44 5D  toolbox db " [D]omain: ", 0
  14++824E 6F 6D 61 69
  14++8252 6E 3A 20 00
  15++8256 20 20 43 75  footer db "  Cursor - movement  [B]ack to prev. page  [H]ome page", 0
  15++825A 72 73 6F 72
  15++825E 20 2D 20 6D
  15++8262 6F 76 65 6D
  15++8266 65 6E 74 20
  15++826A 20 5B 42 5D
  15++826E 61 63 6B 20
  15++8272 74 6F 20 70
  15++8276 72 65 76 2E
  15++827A 20 70 61 67
  15++827E 65 20 20 5B
  15++8282 48 5D 6F 6D
  15++8286 65 20 70 61
  15++828A 67 65 00
  16++828D
  17++828D              inputHost:
  18++828D CD D1 86         call Console.waitForKeyUp
  19++8290              .loop
  20++8290 11 0B 01         ld de, #010B
  20++8293 CD 07 80       call TextMode.gotoXY
  20++8296 21 59 9D       ld hl, hostName
  20++8299 CD 1E 80       call TextMode.printZ
  21++829C 3E 04            ld a, MIME_INPUT
  21++829E CD 1C 80       call TextMode.putC
  22++82A1 3E 20            ld a, ' '
  22++82A3 CD 1C 80       call TextMode.putC
  23++82A6              .wait
  24++82A6 CD DA 86         call Console.getC
  25++82A9 5F               ld e, a
  26++82AA FE 0C            cp Console.BACKSPACE
  26++82AC 28 17          jr z, .removeChar
  27++82AE FE 0D            cp CR
  27++82B0 CA D3 82       jp z, inputNavigate
  28++82B3 FE 20            cp 32
  28++82B5 38 EF          jr c, .wait
  29++82B7              .putC
  30++82B7 AF               xor a
  30++82B8 21 59 9D 01    ld hl, hostName, bc, 48
  30++82BC 30 00
  30++82BE ED B1          cpir
  31++82C0 77               ld (hl), a
  31++82C1 2B             dec hl
  31++82C2 73             ld (hl), e
  32++82C3 18 CB            jr .loop
  33++82C5              .removeChar
  34++82C5 AF               xor a
  35++82C6 21 59 9D 01      ld hl, hostName, bc, 48
  35++82CA 30 00
  35++82CC ED B1          cpir
  36++82CE 2B               dec hl
  36++82CF 2B             dec hl
  36++82D0 77             ld (hl), a
  37++82D1 18 BD            jr .loop
  38++82D3
  39++82D3              inputNavigate:
  40++82D3 21 59 9D 11      ld hl, hostName, de, domain
  40++82D7 06 83
  41++82D9 7E               ld a,(hl)
  42++82DA A7               and a
  43++82DB CA FE 86         jp z, History.load
  44++82DE              .loop
  45++82DE 7E               ld a, (hl)
  45++82DF A7             and a
  45++82E0 28 05          jr z, .complete
  46++82E2 12               ld (de), a
  46++82E3 23 13          inc hl, de
  47++82E5 18 F7            jr .loop
  48++82E7              .complete
  49++82E7 3E 09            ld a, TAB
  49++82E9 12             ld (de), a
  49++82EA 13             inc de
  50++82EB 3E 37            ld a, '7'
  50++82ED 12             ld (de), a
  50++82EE 13             inc de
  51++82EF 3E 30            ld a, '0'
  51++82F1 12             ld (de), a
  51++82F2 13             inc de
  52++82F3 3E 0D            ld a, CR
  52++82F5 12             ld (de), a
  52++82F6 13             inc de
  53++82F7 3E 0A            ld a, LF
  53++82F9 12             ld (de), a
  53++82FA 13             inc de
  54++82FB 21 01 83         ld hl, navRow
  54++82FE C3 53 87       jp History.navigate
  55++8301
  56++8301 31 20 09 2F  navRow db "1 ", TAB, "/", TAB
  56++8305 09
  57++8306 6E 69 68 69  domain db "nihirash.net"
  57++830A 72 61 73 68
  57++830E 2E 6E 65 74
  58++8312 00 00 00...      ds 64 - ($ - domain)
  59++8346
  60++8346                  IFDEF MB03
  61++8346 ~            header db "      Moon Rabbit "
  62++8346 ~                   db VERSION_STRING
  63++8346 ~                   db " for MB03+  (c) 2021 Alexander Nihirash",13, 0
  64++8346                  ENDIF
  65++8346
  66++8346                  IFDEF UNO
  67++8346 ~            header db "      Moon Rabbit "
  68++8346 ~                   db VERSION_STRING
  69++8346 ~                   db " for ZX-Uno (c) 2021 Alexander Nihirash",13, 0
  70++8346                  ENDIF
  71++8346
  72++8346                  IFDEF AY
  73++8346 ~            header db "      Moon Rabbit "
  74++8346 ~                   db VERSION_STRING
  75++8346 ~                   db " for AYWIFI (c) 2021 Alexander Nihirash",13, 0
  76++8346                  ENDIF
  77++8346
  78++8346                  IFDEF ZW
  79++8346 20 20 20 20  header db "      Moon Rabbit "
  79++834A 20 20 4D 6F
  79++834E 6F 6E 20 52
  79++8352 61 62 62 69
  79++8356 74 20
  80++8358 31 2E 36            db "1.6"
  81++835B 20 66 6F 72         db " for ZX WiFi (c) 2021 Alexander Nihirash",13, 0
  81++835F 20 5A 58 20
  81++8363 57 69 46 69
  81++8367 20 28 63 29
  81++836B 20 32 30 32
  81++836F 31 20 41 6C
  81++8373 65 78 61 6E
  81++8377 64 65 72 20
  81++837B 4E 69 68 69
  81++837F 72 61 73 68
  81++8383 0D 00
  82++8385                  ENDIF
# file closed: gopher/render/ui.asm
   7+ 8385                  include "gopher-page.asm"
# file opened: gopher/render/gopher-page.asm
   1++8385              renderGopherScreen:
   2++8385 CD 1A 82         call Render.prepareScreen
   3++8388
   4++8388              	;поиск и печать первой нужной строки
   5++8388 3A 67 8B         ld a, (page_offset)
   5++838B 47             ld b, a
   5++838C CD EF 81       call findLine ;поиск с начала буфера
   6++838F 7C               ld a, h
   6++8390 B5             or l
   6++8391 28 1F          jr z, .exit2
   7++8393 AF               xor a
   7++8394 E5             push hl
   7++8395 CD F1 80       call renderRow
   7++8398 E1             pop hl ;печать строки 0
   8++8399              	;теперь поиск продолжается
   9++8399
  10++8399 06 12            ld b, PER_PAGE-1 ;одну строку уже обработали
  11++839B              .loop
  12++839B C5               push bc
  13++839C 3E 13            ld a, PER_PAGE
  13++839E 90             sub b
  14++839F 5F               ld e, a
  14++83A0 06 01          ld b, 1
  14++83A2 CD F2 81       call findLine2 ;поиск одной следующей
  15++83A5 7C               ld a, h
  15++83A6 B5             or l
  15++83A7 28 06          jr z, .exit
  16++83A9 7B               ld a, e
  16++83AA E5             push hl
  16++83AB CD F1 80       call renderRow
  16++83AE E1             pop hl ;указатель hl надо сохранить
  17++83AF              .exit
  18++83AF C1               pop bc
  19++83B0 10 E9            djnz .loop
  20++83B2              .exit2
  21++83B2 CD 8C 84         call showCursor
  22++83B5 C9               ret
  23++83B6
  24++83B6              checkBorder:
  25++83B6 3A 68 8B         ld a, (cursor_position)
  25++83B9 FE FF          cp #ff
  25++83BB CA B0 84       jp z, pageUp
  26++83BE 3A 68 8B         ld a, (cursor_position)
  26++83C1 FE 13          cp PER_PAGE
  26++83C3 CA D3 84       jp z, pageDn
  27++83C6 CD 8C 84         call showCursor
  28++83C9 C3 CC 83         jp workLoop
  29++83CC
  30++83CC              workLoop:
  31++83CC 3A 81 85         ld a, (play_next)
  31++83CF A7             and a
  31++83D0 C2 45 84       jp nz, navigate
  32++83D3
  33++83D3                  ; dup 4
  34++83D3                  ; halt
  35++83D3                  ; edup
  36++83D3              .nothing
  37++83D3              	OS_WAIT
  37++83D3 DF          >	rst #18
  38++83D4 CD 7B A2     	call printRTC
  39++83D7 CD E3 86         call Console.peekC
  40++83DA FE FF            cp 255
  40++83DC 28 F5          jr z, .nothing
  41++83DE
  42++83DE FE 0A            cp Console.KEY_DN
  42++83E0 CA 9C 84       jp z, cursorDown
  43++83E3 FE 61            cp 'a'
  43++83E5 CA 9C 84       jp z, cursorDown
  44++83E8 FE 0B            cp Console.KEY_UP
  44++83EA CA A6 84       jp z, cursorUp
  45++83ED FE 71            cp 'q'
  45++83EF CA A6 84       jp z, cursorUp
  46++83F2 FE 08            cp Console.KEY_LT
  46++83F4 CA B0 84       jp z, pageUp
  47++83F7 FE 6F            cp 'o'
  47++83F9 CA B0 84       jp z, pageUp
  48++83FC FE 09            cp Console.KEY_RT
  48++83FE CA D3 84       jp z, pageDn
  49++8401 FE 70            cp 'p'
  49++8403 CA D3 84       jp z, pageDn
  50++8406
  51++8406 FE 68            cp 'h'
  51++8408 CA 50 87       jp z, History.home
  52++840B FE 48            cp 'H'
  52++840D CA 50 87       jp z, History.home
  53++8410
  54++8410 FE 62            cp 'b'
  54++8412 CA E7 86       jp z, History.back
  55++8415 FE 42            cp 'B'
  55++8417 CA E7 86       jp z, History.back
  56++841A FE 0C            cp Console.BACKSPACE
  56++841C CA E7 86       jp z, History.back
  57++841F
  58++841F FE 64            cp 'd'
  58++8421 CA 8D 82       jp z, inputHost
  59++8424 FE 44            cp 'D'
  59++8426 CA 8D 82       jp z, inputHost
  60++8429
  61++8429 FE 0D            cp CR
  61++842B CA 45 84       jp z, navigate
  62++842E
  63++842E                  ifdef GS
  64++842E FE 4D            cp 'M'
  64++8430 CC 7F A3       call z, GeneralSound.toggleModule
  65++8433 FE 6D            cp 'm'
  65++8435 CC 7F A3       call z, GeneralSound.toggleModule
  66++8438                  endif
  67++8438
  68++8438 FE 53        	cp 'S'
  68++843A CC E2 81       call z, toggleSaveMode
  69++843D FE 73        	cp 's'
  69++843F CC E2 81       call z, toggleSaveMode
  70++8442
  71++8442 C3 CC 83         jp workLoop
  72++8445
  73++8445              navigate:
  74++8445 CD D1 86         call Console.waitForKeyUp
  75++8448 AF               xor a
  75++8449 32 81 85       ld (play_next), a
  76++844C
  77++844C CD 94 84         call hideCursor
  78++844F 3A 67 8B 47      ld a, (page_offset), b, a, a, (cursor_position)
  78++8453 3A 68 8B
  78++8456 80             add b
  78++8457 47             ld b, a
  78++8458 CD EF 81       call Render.findLine
  79++845B 7E               ld a, (hl)
  80++845C FE 31            cp '1'
  80++845E CA 76 84       jp z, .load
  81++8461 FE 30            cp '0'
  81++8463 CA 76 84       jp z, .load
  82++8466 FE 39            cp '9'
  82++8468 CA 76 84       jp z, .load
  83++846B FE 37            cp '7'
  83++846D CA 7E 84       jp z, .input
  84++8470 CD 8C 84         call showCursor
  85++8473 C3 CC 83         jp workLoop
  86++8476              .load
  87++8476 E5               push hl
  88++8477 CD 06 81         call getIcon
  89++847A E1               pop hl
  90++847B C3 53 87         jp History.navigate
  91++847E              .input
  92++847E E5               push hl
  93++847F CD 82 85         call DialogBox.inputBox
  94++8482 E1               pop hl
  95++8483 3A D7 85         ld a, (DialogBox.inputBuffer)
  95++8486 A7             and a
  95++8487 CA FE 86       jp z, History.load
  96++848A 18 EA            jr .load
  97++848C
  98++848C              showCursor:
  99++848C 3A 68 8B         ld a, (cursor_position)
  99++848F C6 03          add CURSOR_OFFSET
 100++8491 C3 16 80         jp TextMode.highlightLine
 101++8494
 102++8494              hideCursor:
 103++8494 3A 68 8B         ld a, (cursor_position)
 103++8497 C6 03          add CURSOR_OFFSET
 104++8499 C3 10 80         jp TextMode.usualLine
 105++849C
 106++849C              cursorDown:
 107++849C CD 94 84         call hideCursor
 108++849F 21 68 8B         ld hl, cursor_position
 109++84A2 34               inc (hl)
 110++84A3 C3 B6 83         jp checkBorder
 111++84A6
 112++84A6              cursorUp:
 113++84A6 CD 94 84         call hideCursor
 114++84A9 21 68 8B         ld hl, cursor_position
 115++84AC 35               dec (hl)
 116++84AD C3 B6 83         jp checkBorder
 117++84B0
 118++84B0              pageUp:
 119++84B0 3A 67 8B         ld a, (page_offset)
 119++84B3 A7             and a
 119++84B4 28 13          jr z, .skip
 120++84B6 3E 12            ld a, PER_PAGE - 1
 120++84B8 32 68 8B       ld (cursor_position), a
 121++84BB 3A 67 8B         ld a, (page_offset)
 121++84BE D6 13          sub PER_PAGE
 121++84C0 32 67 8B       ld (page_offset), a
 122++84C3              .exit
 123++84C3 CD 85 83         call renderGopherScreen
 124++84C6 C3 CC 83         jp workLoop
 125++84C9              .skip
 126++84C9 AF               xor a
 126++84CA 32 68 8B       ld (cursor_position), a
 126++84CD CD 85 83       call renderGopherScreen
 126++84D0 C3 CC 83       jp workLoop
 127++84D3
 128++84D3              pageDn:
 129++84D3 AF               xor a
 129++84D4 32 68 8B       ld (cursor_position), a
 130++84D7 3A 67 8B         ld a, (page_offset)
 130++84DA C6 13          add PER_PAGE
 130++84DC 32 67 8B       ld (page_offset), a
 131++84DF 18 E2            jr pageUp.exit
# file closed: gopher/render/gopher-page.asm
   8+ 84E1                  include "plaintext.asm"
# file opened: gopher/render/plaintext.asm
   1++84E1              renderPlainTextScreen:
   2++84E1 CD 1A 82         call prepareScreen
   3++84E4
   4++84E4              	;поиск и печать первой нужной строки
   5++84E4 3A 67 8B         ld a, (page_offset)
   5++84E7 47             ld b, a
   5++84E8 CD EF 81       call findLine ;поиск с начала буфера
   6++84EB 7C               ld a, h
   6++84EC B5             or l
   6++84ED 28 2D          jr z, .exit2
   7++84EF AF               xor a
   8++84F0 C6 03            add CURSOR_OFFSET
   8++84F2 57 1E 01       ld d, a, e, 1
   8++84F5 CD 07 80       call TextMode.gotoXY
   9++84F8 CD C0 80         call print70Text
  10++84FB              	;теперь поиск продолжается
  11++84FB
  12++84FB 06 12            ld b, PER_PAGE-1
  13++84FD              .loop
  14++84FD C5               push bc
  15++84FE 3E 13            ld a, PER_PAGE
  15++8500 90             sub b
  16++8501 5F               ld e, a
  16++8502 06 01          ld b, 1
  16++8504 CD F2 81       call Render.findLine2
  17++8507 7C               ld a, h
  17++8508 B5             or l
  17++8509 28 10          jr z, .exit
  18++850B 7B               ld a, e
  19++850C C6 03            add CURSOR_OFFSET
  19++850E 57 1E 01       ld d, a, e, 1
  19++8511 CD 07 80       call TextMode.gotoXY
  20++8514 CD C0 80         call print70Text
  21++8517 C1               pop bc
  22++8518 10 E3            djnz .loop
  23++851A C9               ret
  24++851B              .exit
  25++851B C1               pop bc
  26++851C              .exit2
  27++851C C9               ret
  28++851D
  29++851D              plainTextLoop:
  30++851D CD DA 86         call Console.getC
  31++8520
  32++8520 FE 0A            cp Console.KEY_DN
  32++8522 CA 63 85       jp z, textDown
  33++8525 FE 61            cp 'a'
  33++8527 CA 63 85       jp z, textDown
  34++852A
  35++852A FE 0B            cp Console.KEY_UP
  35++852C CA 71 85       jp z, textUp
  36++852F FE 71            cp 'q'
  36++8531 CA 71 85       jp z, textUp
  37++8534
  38++8534 FE 68            cp 'h'
  38++8536 CA 50 87       jp z, History.home
  39++8539 FE 48            cp 'H'
  39++853B CA 50 87       jp z, History.home
  40++853E
  41++853E FE 62            cp 'b'
  41++8540 CA E7 86       jp z, History.back
  42++8543 FE 42            cp 'B'
  42++8545 CA E7 86       jp z, History.back
  43++8548
  44++8548 FE 0C            cp Console.BACKSPACE
  44++854A CA E7 86       jp z, History.back
  45++854D
  46++854D                  ifdef GS
  47++854D FE 4D            cp 'M'
  47++854F CC 7F A3       call z, GeneralSound.toggleModule
  48++8552 FE 6D            cp 'm'
  48++8554 CC 7F A3       call z, GeneralSound.toggleModule
  49++8557                  endif
  50++8557
  51++8557 FE 53            cp 'S'
  51++8559 CC E2 81       call z, toggleSaveMode
  52++855C FE 73        	cp 's'
  52++855E CC E2 81       call z, toggleSaveMode
  53++8561
  54++8561 18 BA            jr plainTextLoop
  55++8563
  56++8563
  57++8563              textDown:
  58++8563 3A 67 8B         ld a, (page_offset)
  58++8566 C6 13          add PER_PAGE
  58++8568 32 67 8B       ld (page_offset), a
  59++856B CD E1 84         call renderPlainTextScreen
  60++856E C3 1D 85         jp plainTextLoop
  61++8571
  62++8571              textUp:
  63++8571 21 67 8B         ld hl, page_offset
  64++8574 7E               ld a, (hl)
  64++8575 A7             and a
  64++8576 28 A5          jr z, plainTextLoop
  65++8578 D6 13            sub PER_PAGE
  65++857A 77             ld (hl), a
  66++857B CD E1 84         call renderPlainTextScreen
  67++857E C3 1D 85         jp plainTextLoop
# file closed: gopher/render/plaintext.asm
   9+ 8581
  10+ 8581 00           play_next       db  0
  11+ 8582              position        EQU historyBlock.position
  12+ 8582              cursor_position EQU position + 1
  13+ 8582              page_offset     EQU position
  14+ 8582                  ENDMODULE
  15+ 8582
  16+ 8582                  include "dialogbox.asm"
# file opened: gopher/render/dialogbox.asm
   1++8582                  module DialogBox
   2++8582
   3++8582              inputBox:
   4++8582 AF               xor a
   4++8583 32 D7 85       ld (inputBuffer), a
   5++8586              .noclear
   6++8586 CD 38 86         call drawBox
   7++8589              .loop
   8++8589 11 05 0B         ld de, #0B05
   8++858C CD 07 80       call TextMode.gotoXY
   9++858F 21 D7 85         ld hl, inputBuffer
   9++8592 CD 1E 80       call TextMode.printZ
  10++8595 3E 04            ld a, MIME_INPUT
  10++8597 CD 1C 80       call TextMode.putC
  10++859A 3E 20          ld a, ' '
  10++859C CD 1C 80       call TextMode.putC
  11++859F              .checkkey
  12++859F CD DA 86         call Console.getC
  13++85A2 FE 0C            cp Console.BACKSPACE
  13++85A4 28 16          jr z, .removeChar
  14++85A6 FE 0D            cp CR
  14++85A8 C8             ret z
  15++85A9 FE 20            cp SPACE
  15++85AB 38 F2          jr c, .checkkey
  16++85AD              .putC
  17++85AD 5F               ld e, a
  18++85AE AF               xor a
  18++85AF 21 D7 85 01    ld hl, inputBuffer, bc, #ff
  18++85B3 FF 00
  18++85B5 ED B1          cpir
  19++85B7 77               ld (hl), a
  19++85B8 2B             dec hl
  19++85B9 73             ld (hl), e
  20++85BA 18 CD            jr .loop
  21++85BC              .removeChar
  22++85BC AF               xor a
  23++85BD 21 D7 85 01      ld hl, inputBuffer, bc, #ff
  23++85C1 FF 00
  23++85C3 ED B1          cpir
  24++85C5 E5               push hl
  25++85C6 11 D8 85             ld de, inputBuffer + 1
  26++85C9 B7                   or a
  26++85CA ED 52          sbc hl, de
  27++85CC 7C                   ld a, h
  27++85CD B5             or l
  28++85CE E1               pop hl
  29++85CF 28 B8            jr z, .loop
  30++85D1 AF               xor a
  31++85D2 2B               dec hl
  31++85D3 2B             dec hl
  31++85D4 77             ld (hl), a
  32++85D5 18 B2            jr .loop
  33++85D7
  34++85D7 00 00 00...  inputBuffer ds 80
  35++8627
  36++8627              msgBox:
  37++8627 CD 30 86         call msgNoWait
  38++862A 06 96            ld b, 150
  39++862C              .loop
  40++862C                  OS_WAIT
  40++862C DF          >	rst #18
  41++862D 10 FD            djnz .loop
  42++862F C9               ret
  43++8630
  44++8630              msgNoWait:
  45++8630 E5               push hl
  46++8631 CD 38 86         call drawBox
  47++8634 E1               pop hl
  48++8635 C3 1E 80         jp TextMode.printZ
  49++8638
  50++8638              drawBox:
  51++8638 26 0A 3E 09      ld h, #0A, a, BORDER_TOP
  51++863C CD 0C 80       call TextMode.fillLine
  52++863F 26 0B 3E 20      ld h, #0B, a, ' '
  52++8643 CD 0C 80       call TextMode.fillLine
  53++8646 26 0C 3E 08      ld h, #0C, a, BORDER_BOTTOM
  53++864A CD 0C 80       call TextMode.fillLine
  54++864D
  55++864D                  IFNDEF TIMEX80
  56++864D 3E 0A            ld a, #0a
  56++864F CD 16 80       call TextMode.highlightLine
  57++8652 3E 0C            ld a, #0c
  57++8654 CD 16 80       call TextMode.highlightLine
  58++8657                  ENDIF
  59++8657
  60++8657 11 05 0B         ld de, #0B05
  60++865A CD 07 80       call TextMode.gotoXY
  61++865D C9               ret
  62++865E                  endmodule
  63++865E
# file closed: gopher/render/dialogbox.asm
# file closed: gopher/render/index.asm
  18  865E                  include "dos/index.asm"
# file opened: dos/index.asm
   1+ 865E                  IFDEF ESX
   2+ 865E ~                include "esxdos.asm"
   3+ 865E              	ENDIF
   4+ 865E                  IFDEF TRD
   5+ 865E ~                include "trdos.asm"
   6+ 865E              	ENDIF
   7+ 865E                  IFDEF ZSFAT
   8+ 865E                  include "zsfat.asm"
# file opened: dos/zsfat.asm
   1++865E              ;trdos driver (izzx)
   2++865E                  MODULE Dos
   3++865E              ; API methods
   4++865E              ESX_GETSETDRV = #89
   5++865E              ESX_FOPEN = #9A
   6++865E              ESX_FCLOSE = #9B
   7++865E              ESX_FSYNC = #9C
   8++865E              ESX_FREAD = #9D
   9++865E              ESX_FWRITE = #9E
  10++865E
  11++865E              ; File modes
  12++865E              FMODE_READ = #01
  13++865E              FMODE_WRITE = #06
  14++865E              FMODE_CREATE = #0E
  15++865E
  16++865E                  ; MACRO esxCall func
  17++865E                  ; rst #8 : db func
  18++865E                  ; ENDM
  19++865E
  20++865E              ;макросы модуля
  21++865E              ;
  22++865E              ;R8DOS			вызов функции R8DOS
  23++865E              ;R8FAT			вызов функции R8FAT
  24++865E              ;R8DOSc			вызов функции R8DOS
  25++865E              ;
  26++865E              ;------------------------------------------------------------------------------
  27++865E              ;вызов функции R8DOS
  28++865E              ;вх: =0 номер функции
  29++865E              ;
  30++865E              	; MACRO	R8DOS nFunc
  31++865E              	; ld	c,nFunc
  32++865E              	; rst	#08
  33++865E              	; db	#81
  34++865E              	; ENDM
  35++865E
  36++865E              ; ;------------------------------------------------------------------------------
  37++865E              ; ;вызов функции R8FAT
  38++865E              ; ;вх: =0 номер функции
  39++865E              ; ;
  40++865E              	; MACRO	R8FAT nFunc
  41++865E              	; ld	c,nFunc
  42++865E              	; rst	#08
  43++865E              	; db	#91
  44++865E              	; ENDM
  45++865E
  46++865E              ; ;------------------------------------------------------------------------------
  47++865E              ; ;вызов функции R8DOS
  48++865E              ; ;вх: c - номер функции
  49++865E              ; ;
  50++865E              	; MACRO	R8DOSc
  51++865E              	; rst	#08
  52++865E              	; db	#81
  53++865E              	; ENDM
  54++865E
  55++865E              ; ;------------------------------------------------------------------------------
  56++865E              ; ;вызов функции #02 (FileMan) R8CONF
  57++865E              ; ;вх: =#00 - номер функции файл менеджера
  58++865E              ; ;
  59++865E              	; MACRO	R8C02FM nFunct
  60++865E              	; ld	bc,#100*nFunct+#02
  61++865E              	; rst	#08
  62++865E              	; db	#8E
  63++865E              	; ENDM
  64++865E
  65++865E              ;==============================================================================
  66++865E              ; r8f00_DeinitFAT		equ #00
  67++865E              ; r8f01_InitFAT		equ #01
  68++865E              ; r8f04_FindPath		equ #04
  69++865E              ; r8f07_FileOpen		equ #07 ;открыть файл для последующих операций с ним
  70++865E              ; r8f09_FileWrite		equ #09	;запись данных из памяти в файл
  71++865E              ; r8f0E_CreateFileLFN	equ #0E ;создание файла с длинным именем в текущем каталоге
  72++865E              ; r8f0F_CreateFileSFN	equ #0F
  73++865E
  74++865E              ; r8d2D_FindPart		equ #2D
  75++865E              ; r8d2E_CngHDD		equ #2E
  76++865E
  77++865E
  78++865E              ;id = 0 файл не открыт
  79++865E              ;id = 1 файл для чтения trdos
  80++865E              ;id = 2 файл для записи trdos
  81++865E              ;id = 3 файл для записи тип TRD trdos
  82++865E              ;id = 4 файл для записи тип SCL trdos
  83++865E              ;id = 5 файл для чтения fat32 (пока не сделано)
  84++865E              ;id = 6 файл для записи fat32
  85++865E
  86++865E              ; HL - filename in ASCIIZ
  87++865E              loadBuffer:
  88++865E 06 01            ld b, Dos.FMODE_READ
  88++8660 CD 7A 86       call Dos.fopen
  89++8663 F5               push af
  90++8664 21 8B A3 01          ld hl, outputBuffer, bc, #ffff - outputBuffer
  90++8668 74 5C
  90++866A CD AB 86       call Dos.fread
  91++866D 21 8B A3             ld hl, outputBuffer
  91++8670 09             add hl, bc
  91++8671 AF             xor a
  91++8672 77             ld (hl), a
  91++8673 23             inc hl
  91++8674 77             ld (hl), a
  92++8675 F1               pop af
  93++8676 CD A7 86         call Dos.fclose
  94++8679 C9               ret
  95++867A
  96++867A
  97++867A              ; Returns:
  98++867A              ;  A - current drive
  99++867A              ; getDefaultDrive: ;нигде не используется
 100++867A                  ; ld a, 0 : esxCall ESX_GETSETDRV
 101++867A                  ; ret
 102++867A
 103++867A
 104++867A
 105++867A              ; Opens file on default drive
 106++867A              ; B - File mode
 107++867A              ; HL - File name
 108++867A              ; Returns:
 109++867A              ;  A - file stream id
 110++867A              fopen:
 111++867A                  ; push bc : push hl
 112++867A                  ; call getDefaultDrive
 113++867A                  ; pop ix : pop bc
 114++867A                  ; esxCall ESX_FOPEN
 115++867A                  ; ret
 116++867A 78           	ld a,b
 117++867B FE 01        	cp FMODE_READ ;если режим открытие файла
 118++867D 28 06        	jr z,fopen_r
 119++867F FE 0E        	cp FMODE_CREATE
 120++8681 28 12        	jr z,fopen_c ;если режим создание файла
 121++8683 18 0E        	jr fopen_err ;иначе выход
 122++8685
 123++8685              fopen_r	;открытие существующего файла на чтение (id=1)
 124++8685
 125++8685              	;call format_name ;
 126++8685
 127++8685              	;открыть папку системы по умолчанию
 128++8685 E5           	push hl ;сохранить имя файла
 129++8686 21 B7 86     	ld hl,path_os ;папка системы
 130++8689 AF           	xor	a
 131++868A 3D           	dec	a ;установить текущим
 132++868B              	OS_FIND_PATH ;найти папку
 132++868B 0E 29       >    ld c,#29
 132++868D E7          >    rst #20
 133++868E E1           	pop hl
 134++868F
 135++868F              	OS_FILE_OPEN
 135++868F 0E 21       >    ld c,#21
 135++8691 E7          >    rst #20
 136++8692 C9           	ret
 137++8693              	; ld a,(#5D19) ;номер дисковода по умолчанию
 138++8693              	; ld 	(prev_drive),a ;запомним
 139++8693              			;call format_name ;
 140++8693              			; ld      c,#13 ;move file info to syst var
 141++8693                          ; call    call3d13
 142++8693                          ; ld      c,#0a ;find file
 143++8693                          ; call    call3d13
 144++8693                          ; ld      a,c
 145++8693              			; cp 		#ff
 146++8693              			; jr 		z,fopen_err ;если не нашли файла
 147++8693                          ; ld      c,#08 ;read file title
 148++8693                          ; call    call3d13
 149++8693                          ; ;ld      hl,loadadr ;куда
 150++8693                          ; ld      de,(#5ceb) ;начало файла сектор дорожка
 151++8693                          ; ld      (f_r_cur_trk),de
 152++8693
 153++8693                          ; ld      a,(#5cea)
 154++8693                          ; ld      (f_r_len_sec),a ;длина в секторах
 155++8693                          ; ;or      a
 156++8693                          ; ;ret     z    ;выход если пустой
 157++8693
 158++8693              			; ld de,(#5CE8) ; длина файла или программной части для BASIC
 159++8693              			; ld      (f_r_len),de
 160++8693
 161++8693                          ; ; ld      de,(fcurtrk) ;текущие сектор дорожка
 162++8693                          ; ; ld      (#5cf4),de ;восстановим
 163++8693              			; xor a
 164++8693              			; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 165++8693              			; ld 		a,1
 166++8693              			; ld (f_r_flag),a ;флаг что файл для чтения открыт
 167++8693              			; ;id канала будет 1
 168++8693              	;ret
 169++8693
 170++8693              fopen_err
 171++8693              	; ld a,1
 172++8693              	; ld (com_file_err_flag),a
 173++8693              	; xor a ;если никакой файл не открыли, то id = 0
 174++8693 37           	scf ;флаг ошибки
 175++8694 C9           	ret
 176++8695
 177++8695
 178++8695              fopen_c	;создание нового файла (id=2-4,6)
 179++8695              	; ld a,(#5D19) ;номер дисковода по умолчанию
 180++8695              	; ld 	(prev_drive),a ;запомним
 181++8695
 182++8695              	;открыть папку загрузок, если есть
 183++8695 E5           	push hl ;сохранить имя файла
 184++8696 21 BC 86     	ld hl,path_download
 185++8699 AF           	xor	a
 186++869A 3D           	dec	a ;установить текущим
 187++869B              	OS_FIND_PATH ;найти папку
 187++869B 0E 29       >    ld c,#29
 187++869D E7          >    rst #20
 188++869E E1           	pop hl
 189++869F
 190++869F              	;call format_name ;
 191++869F              	OS_FILE_OPEN ;если есть, откроем
 191++869F 0E 21       >    ld c,#21
 191++86A1 E7          >    rst #20
 192++86A2 D0           	ret nc
 193++86A3
 194++86A3              	OS_FILE_CREATE ;или создадим
 194++86A3 0E 22       >    ld c,#22
 194++86A5 E7          >    rst #20
 195++86A6 C9           	ret
 196++86A7
 197++86A7              	; call select_drive
 198++86A7              	; cp "y"
 199++86A7              	; jr nz,fopen_err
 200++86A7
 201++86A7              	; ld a,(curr_drive)
 202++86A7              	; cp 4
 203++86A7              	; jp nc,fopen_c_fat ;если выбран FAT
 204++86A7
 205++86A7              	; ;выясним, не образ ли это для разворачивания
 206++86A7                  ; ld hl, trdExt1 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 207++86A7                  ; ld hl, trdExt2 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 208++86A7              	; ld hl, sclExt1 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 209++86A7                  ; ld hl, sclExt2 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 210++86A7
 211++86A7
 212++86A7              	; ;создание произвольного файла (id=2)
 213++86A7              	; call cat_buf_cls
 214++86A7
 215++86A7              	; ld hl,cat_buf ;считаем каталог диска
 216++86A7              	; ld de,0
 217++86A7                  ; ld      bc,#0905 ;
 218++86A7                  ; call    call3d13
 219++86A7
 220++86A7              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 221++86A7              	; cp 128
 222++86A7              	; jp c,fopen_c2 ;если уже максимум
 223++86A7                  ; ld hl, file_err
 224++86A7                  ; call DialogBox.msgBox ;предуреждение
 225++86A7              	; jr fopen_err
 226++86A7
 227++86A7              ; fopen_c2
 228++86A7              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 229++86A7              	; ld a,h
 230++86A7              	; or l
 231++86A7              	; jr nz,fopen_c3 ;если ещё есть место
 232++86A7                  ; ld hl, file_err
 233++86A7                  ; call DialogBox.msgBox ;предуреждение
 234++86A7              	; jr fopen_err
 235++86A7
 236++86A7              ; fopen_c3
 237++86A7              	; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 238++86A7                  ; ld   (#5cf4),de ;отсюда будем писать файл
 239++86A7
 240++86A7              	; xor a
 241++86A7              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 242++86A7              	; ld (sec_shift),a ;переменная
 243++86A7              	; ld hl,0
 244++86A7              	; ld (f_w_len+0),hl
 245++86A7              	; ld (f_w_len+2),hl
 246++86A7              	; ld a,2 ;id канала
 247++86A7              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 248++86A7              	; ret
 249++86A7
 250++86A7
 251++86A7              ; cat_buf_cls ;очистка буфера каталога
 252++86A7              	; ld hl,cat_buf ;очистить место для каталога дискеты
 253++86A7              	; ld de,cat_buf+1
 254++86A7              	; ld (hl),0
 255++86A7              	; ld bc,9*256-1
 256++86A7              	; ldir
 257++86A7              	; ret
 258++86A7
 259++86A7
 260++86A7
 261++86A7              ; fopen_c_trd	;открытие файла для разворачивания образа trd (id=3)
 262++86A7              	; call select_drive
 263++86A7              	; cp "y"
 264++86A7              	; jp nz,fopen_err
 265++86A7
 266++86A7              	; ld      de,0 ;начало сектор дорожка
 267++86A7                  ; ld      (#5cf4),de
 268++86A7
 269++86A7              	; xor a
 270++86A7              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 271++86A7              	; ld (sec_shift),a ;переменная
 272++86A7              	; ld hl,0
 273++86A7              	; ld (f_w_len+0),hl
 274++86A7              	; ld (f_w_len+2),hl
 275++86A7              	; ld a,3 ;id канала
 276++86A7              	; ld (f_w_flag),a ;флаг что trd для записи открыт
 277++86A7              	; ret
 278++86A7
 279++86A7
 280++86A7
 281++86A7              ; fopen_c_scl	;открытие файла для разворачивания образа scl (id=4)
 282++86A7              	; call select_drive
 283++86A7              	; cp "y"
 284++86A7              	; jp nz,fopen_err
 285++86A7
 286++86A7              	; ld      de,0 ;начало сектор дорожка
 287++86A7                  ; ld      (#5cf4),de
 288++86A7
 289++86A7              	; call cat_buf_cls ;почистить место
 290++86A7
 291++86A7              	; call scl_parse ;запуск цикла сборки образа
 292++86A7
 293++86A7              	; xor a
 294++86A7              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 295++86A7              	; ld (sec_shift),a ;переменная
 296++86A7              	; ;ld (scl_que),a
 297++86A7              	; ld hl,0
 298++86A7              	; ld (f_w_len+0),hl
 299++86A7              	; ld (f_w_len+2),hl
 300++86A7              	; ld a,4 ;id канала
 301++86A7              	; ld (f_w_flag),a ;флаг что scl для записи открыт
 302++86A7              	; ret
 303++86A7
 304++86A7
 305++86A7
 306++86A7
 307++86A7              ; fopen_c_fat	;создание файла FAT (id=6)
 308++86A7
 309++86A7              ; ;переинициализация FAT раздела
 310++86A7              	; R8FAT	r8f00_DeinitFAT
 311++86A7              	; jp 		c,fopen_err
 312++86A7
 313++86A7              	; ld a,(curr_drive)
 314++86A7              	; ld bc,typeDrive-4
 315++86A7              	; ld l,a
 316++86A7              	; ld h,0
 317++86A7              	; add hl,bc
 318++86A7              	; ld a,(hl) ;получили код раздела из списка
 319++86A7              	; rlca
 320++86A7              	; rlca
 321++86A7              	; rlca
 322++86A7              	; rlca
 323++86A7              	; and %11110000
 324++86A7                  ; ;         ld      a,%0000????
 325++86A7                                     ; ; ││└┴─── номер раздела
 326++86A7                                     ; ; │└───── master/slave для Hdd
 327++86A7                                     ; ; └────── SD/Hdd
 328++86A7              	; R8FAT	r8f01_InitFAT
 329++86A7                  ; jp      c,fopen_err
 330++86A7
 331++86A7              ; ;поиск пути в разделе
 332++86A7              	; ld	hl,ActPathFAT		;путь к каталогу Download
 333++86A7              	; ld	de,fcb
 334++86A7              	; xor	a
 335++86A7              	; dec	a
 336++86A7              	; R8FAT	r8f04_FindPath
 337++86A7                  ; ;jp      c,fopen_err ;если не нашли, файл будет в корне
 338++86A7
 339++86A7              	; ld	hl,(temp_hl)		;строка с именем
 340++86A7              	; ld	de,fcb
 341++86A7              	; R8FAT r8f07_FileOpen
 342++86A7              	; jp 	nc,fopen_c_fat2 ;если файл есть, откроем
 343++86A7
 344++86A7              ; ;создание файла, если нет
 345++86A7              	; ld	hl,(temp_hl)		;строка с именем
 346++86A7              	; xor	a
 347++86A7              	; ld	(fcb+#14+0),a
 348++86A7              	; ld	(fcb+#14+1),a
 349++86A7              	; ld	(fcb+#14+2),a	;установим размер
 350++86A7              	; ld	(fcb+#14+3),a
 351++86A7              	; ld	de,fcb
 352++86A7              	; R8FAT	r8f0E_CreateFileLFN	;создание файла
 353++86A7              	; jp 	c,fopen_err
 354++86A7
 355++86A7              ; fopen_c_fat2
 356++86A7
 357++86A7              	; ld hl,0
 358++86A7              	; ld (f_w_len+0),hl
 359++86A7              	; ld (f_w_len+2),hl
 360++86A7              	; xor a
 361++86A7              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 362++86A7              	; ld a,6 ;id канала
 363++86A7              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 364++86A7              	; ret
 365++86A7
 366++86A7
 367++86A7
 368++86A7
 369++86A7
 370++86A7              ; select_drive	;запрос номера дисковода
 371++86A7              	; ld a,(hdd_init_flag) ;если в первый раз
 372++86A7              	; or a
 373++86A7              	; jr nz,select_drive2
 374++86A7              	; ld a,(#5D19) ;номер дисковода по умолчанию
 375++86A7              	; ld (curr_drive),a
 376++86A7              	; call GetNumPart ;узнаем какая буква последняя, сколько разделов ФАТ
 377++86A7              	; add "D"
 378++86A7              	; ld (write_ima_e),a	;выбор до этой буквы
 379++86A7              	; sub "D"
 380++86A7              	; inc a
 381++86A7              	; add "d"
 382++86A7              	; ld (next_lett),a ;эта буква первая свободная
 383++86A7              	; ld a,1
 384++86A7              	; ld (hdd_init_flag),a
 385++86A7              ; select_drive2
 386++86A7              	; ld a,(curr_drive) ;номер дисковода по умолчанию
 387++86A7              	; add a,"A"
 388++86A7              	; ld (write_ima_d),a ;подставим букву в запросе
 389++86A7                  ; ld hl, write_ima
 390++86A7                  ; call DialogBox.msgNoWait ;текст запроса
 391++86A7              ; select_drive_wait
 392++86A7              	; ;halt
 393++86A7              	; call Console.getC
 394++86A7              	; cp 255
 395++86A7              	; JR Z,select_drive_wait	;ждём любую клавишу
 396++86A7              	; cp "y"
 397++86A7              	; jr z,select_drive_ex
 398++86A7              	; cp "n"
 399++86A7              	; ret z
 400++86A7              	; cp "a" ;от буквы A
 401++86A7              	; jr c,select_drive_wait
 402++86A7              	; ld hl,next_lett
 403++86A7              	; cp (hl) ;до первой свободной буквы
 404++86A7              	; jr nc,select_drive_wait
 405++86A7              	; sub "a"
 406++86A7              	; ld (curr_drive),a ;новый номер диска
 407++86A7              	; jr select_drive2 ;обновить строку
 408++86A7              ; select_drive_ex ;выход
 409++86A7              	; ld a,(curr_drive)
 410++86A7              	; cp 4 ;начиная с буквы E идёт HDD
 411++86A7              	; jr nc,select_drive3
 412++86A7                  ; ld      (#5d19) ,a ;если дискета, настроим trdos
 413++86A7                  ; ld      c,1
 414++86A7                  ; call    call3d13
 415++86A7                  ; ld      c,#18
 416++86A7                  ; call    call3d13
 417++86A7              ; select_drive3
 418++86A7              	; ld a,"y"
 419++86A7              	; ret
 420++86A7
 421++86A7
 422++86A7              ; ; restore_drive ;восстановить дисковод по умолчанию
 423++86A7              	; ; ld 	a,(prev_drive)
 424++86A7                  ; ; ld      (#5d19) ,a
 425++86A7                  ; ; ld      c,1
 426++86A7                  ; ; call    call3d13
 427++86A7                  ; ; ld      c,#18
 428++86A7                  ; ; call    call3d13
 429++86A7              	; ; ret
 430++86A7
 431++86A7
 432++86A7              ; call3d13 ;фикс для GMX
 433++86A7              	; ifndef ZSGMX
 434++86A7                  ; jp    #3d13
 435++86A7              	; endif
 436++86A7
 437++86A7              	; ; ifdef ZSGMX
 438++86A7                  ; ; call    #3d13
 439++86A7              	; ; exx
 440++86A7              	; ; call TextMode.gmxscron
 441++86A7              	; ; exx
 442++86A7              	; ; endif
 443++86A7              	; ret
 444++86A7
 445++86A7
 446++86A7
 447++86A7              ; A - file stream id
 448++86A7              fclose:
 449++86A7              	OS_FILE_CLOSE
 449++86A7 0E 25       >    ld c,#25
 449++86A9 E7          >    rst #20
 450++86AA C9           	ret
 451++86AB
 452++86AB                  ; ;esxCall ESX_FCLOSE
 453++86AB              	; ; push af
 454++86AB              	; ; pop af
 455++86AB              	; cp 2 ;если обычный файл
 456++86AB              	; jp nz,fclose_scl
 457++86AB
 458++86AB              	; ;дописать остаток файла
 459++86AB              	; ld a,(write_end_flag) ;нужно записывать остаток?
 460++86AB              	; or a
 461++86AB              	; jr nz,fclose_f ;не нужно
 462++86AB
 463++86AB              	; ld hl,sec_buf
 464++86AB              	; ld bc,#0106
 465++86AB              	; ld de,(#5cf4)
 466++86AB              	; call call3d13
 467++86AB
 468++86AB              	; ld a,"0" ;номер части файла
 469++86AB              	; ld (file_num),a
 470++86AB
 471++86AB              ; fclose_f ;поправить каталог
 472++86AB              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 473++86AB              	; ld hl,(f_w_len+0)
 474++86AB              	; or h
 475++86AB              	; or l
 476++86AB              	; jp z,fclose_ex ;выход если длина 0
 477++86AB
 478++86AB              	; ;проверки на заполнение
 479++86AB              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 480++86AB              	; cp 128
 481++86AB              	; jp nc,fclose_ex ;если уже максимум
 482++86AB              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 483++86AB              	; ld a,h
 484++86AB              	; or l
 485++86AB              	; jp z,fclose_ex ;если места нет
 486++86AB
 487++86AB              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 488++86AB              	; or a
 489++86AB              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 490++86AB              	; ld a,(f_w_len+1)
 491++86AB              	; cp 255
 492++86AB              	; jr nz,fclose_f1
 493++86AB              	; ld a,(f_w_len+0)
 494++86AB              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 495++86AB              ; fclose_f1
 496++86AB              	; ;файл не превышает максимальный размер для trdos
 497++86AB              	; ld de,(f_w_len+0)
 498++86AB              	; ld hl,f_name+11 ;длина файла
 499++86AB              	; ld (hl),e
 500++86AB              	; inc hl
 501++86AB              	; ld (hl),d
 502++86AB              	; inc hl
 503++86AB              	; ld a,(f_w_len+1) ;длина секторов
 504++86AB              	; ld (hl),a
 505++86AB              	; ld a,(f_w_len+0) ;длина младший
 506++86AB              	; or a
 507++86AB              	; jr z,fclose_f2
 508++86AB              	; inc (hl) ;коррекция секторов
 509++86AB              ; fclose_f2
 510++86AB              	; call fclose_f_one ;записать информацию
 511++86AB              	; jp fclose_ex ;готово
 512++86AB
 513++86AB              ; fclose_f_multi ;файл большой, будет несколько записей в каталоге
 514++86AB              	; ld a,(file_num)
 515++86AB              	; ld (f_name+7),a ;в конце имени номер
 516++86AB
 517++86AB              	; ld hl,f_name+11 ;длина файла
 518++86AB              	; ld (hl),0
 519++86AB              	; inc hl
 520++86AB              	; ld (hl),#ff ;65280
 521++86AB              	; inc hl
 522++86AB              	; ;длина секторов
 523++86AB              	; ld (hl),#ff
 524++86AB              	; call fclose_f_one ;записать информацию
 525++86AB
 526++86AB              	; ;вычесть длину записанного
 527++86AB              	; ld hl,(f_w_len+1) ;старший и средний байт
 528++86AB              	; ld bc,255
 529++86AB              	; and a
 530++86AB              	; sbc hl,bc ;вычесть 255 секторов
 531++86AB              	; ld (f_w_len+1),hl
 532++86AB
 533++86AB              	; ld a,(file_num)
 534++86AB              	; inc a
 535++86AB              	; ld (file_num),a
 536++86AB              	; ld (f_name+7),a ;в конце имени номер
 537++86AB
 538++86AB              	; jr fclose_f ;сначала
 539++86AB
 540++86AB
 541++86AB              ; fclose_f_one ;запись об одном файле
 542++86AB              			; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 543++86AB              			; ld l,a ;узнать в каком секторе будет запись о файле
 544++86AB              			; ld h,0
 545++86AB              			; add hl,hl ;*2
 546++86AB              			; add hl,hl ;*4
 547++86AB              			; add hl,hl ;*8
 548++86AB              			; add hl,hl ;*16
 549++86AB              			; ld a,h ;запомнить номер сетора в каталоге
 550++86AB              			; ld (sec_cat),a
 551++86AB              			; ld bc,cat_buf
 552++86AB              			; add hl,bc ;здесь будет запись о новом файле
 553++86AB              			; ex de,hl
 554++86AB
 555++86AB              			; ld hl,f_name ;запись о файле
 556++86AB              			; ld bc,16
 557++86AB              			; ldir ;скопировать
 558++86AB              			; ex de,hl
 559++86AB              			; dec hl
 560++86AB              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка назначения
 561++86AB              			; ld (hl),d ;дорожка
 562++86AB              			; dec hl
 563++86AB              			; ld (hl),e ;сектор
 564++86AB
 565++86AB              			; ld l,0 ;записать сектор целиком по ровному адресу
 566++86AB              			; ld d,0
 567++86AB              			; ld a,(sec_cat)
 568++86AB              			; ld e,a ;номер сектора
 569++86AB              			; ld bc,#0106 ;1 сектор записать
 570++86AB              			; call call3d13
 571++86AB
 572++86AB              			; ;служебный сектор
 573++86AB              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 574++86AB              			; ld a,(f_name+13) ;размер файла в секторах
 575++86AB              			; ld b,a
 576++86AB              			; call calc_next_pos2
 577++86AB              			; ld (cat_buf+8*256+#e1),de
 578++86AB
 579++86AB              			; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 580++86AB              			; ld a,(f_name+13) ;размер файла в секторах
 581++86AB              			; ld c,a
 582++86AB              			; ld b,0
 583++86AB              			; and a
 584++86AB              			; sbc hl,bc
 585++86AB              			; jr nc,fclose_f_one2
 586++86AB              			; ld hl,0 ;если было отрицательное
 587++86AB              ; fclose_f_one2
 588++86AB              			; ld (cat_buf+8*256+#e5),hl
 589++86AB
 590++86AB              			; ld hl,cat_buf+8*256+#e4 ; общее количество файлов
 591++86AB              			; inc (hl)
 592++86AB
 593++86AB              			; ld hl,cat_buf+8*256
 594++86AB              			; ld de,#0008
 595++86AB              			; ld bc,#0106 ;1 сектор записать
 596++86AB              			; call call3d13
 597++86AB              			; ret
 598++86AB
 599++86AB
 600++86AB              ; fclose_scl
 601++86AB              	; cp 4 ;если scl
 602++86AB              	; jr nz,fclose_ex
 603++86AB              	; ld hl,sec_buf ;
 604++86AB              	; ld b,1
 605++86AB              	; call scl_write_buf ;допишем остаток scl, если есть
 606++86AB
 607++86AB              ; fclose_ex
 608++86AB              	; xor a ;закрываем все файлы
 609++86AB              	; ld (f_r_flag),a
 610++86AB              	; ld (f_w_flag),a
 611++86AB
 612++86AB              	; ld a,(com_file_err_flag) ;была ли ошибка
 613++86AB              	; or a
 614++86AB              	; ret z
 615++86AB              	; ld a,2 ;если была
 616++86AB              	; out (254),a ;бордюр красный
 617++86AB                  ; ld hl, com_file_err ;общая ошибка
 618++86AB                  ; call DialogBox.msgBox ;предуреждение
 619++86AB              	; xor a ;
 620++86AB              	; out (254),a
 621++86AB              	; ;call restore_drive ;вернуть диск, какой был
 622++86AB                  ; ret
 623++86AB
 624++86AB
 625++86AB
 626++86AB
 627++86AB              ; A - file stream id
 628++86AB              ; BC - length
 629++86AB              ; HL - buffer
 630++86AB              ; Returns
 631++86AB              ;  BC - length(how much was actually read)
 632++86AB              fread: ;(id=1)
 633++86AB 59           	ld e,c ;сохранить длину
 634++86AC 50           	ld d,b
 635++86AD              	OS_FILE_READ
 635++86AD 0E 23       >    ld c,#23
 635++86AF E7          >    rst #20
 636++86B0 C9           	ret
 637++86B1
 638++86B1                  ; push hl : pop ix
 639++86B1                  ; esxCall ESX_FREAD
 640++86B1              	; push af
 641++86B1              	; ld a,4
 642++86B1              	; out (254),a
 643++86B1              	; xor a
 644++86B1              	; out (254),a
 645++86B1              	; pop af
 646++86B1
 647++86B1              	; cp 1 ;id = 1?
 648++86B1              	; jr nz,fread_no_chek ;выход если номер потока не = 1
 649++86B1              	; ld a,(f_r_flag)
 650++86B1              	; or a
 651++86B1              	; jr nz,fread_chek ;файл уже открыт?
 652++86B1              ; fread_no_chek ;выход с ошибкой
 653++86B1              	; xor a
 654++86B1              	; scf ;флаг ошибки
 655++86B1              	; ld bc,0 ;ничего мы не считали
 656++86B1              	; ret
 657++86B1
 658++86B1              ; fread_chek
 659++86B1              	; ld bc,(f_r_len_sec-1) ;загружаем файл целиком, не смотря на то, сколько байт было запрошено
 660++86B1                  ; ld      c,5 ;read читаем целыми секторами
 661++86B1              	; ld de,(f_r_cur_trk)
 662++86B1                  ; call    call3d13
 663++86B1              	; ld bc,(f_r_len) ;возвратим сколько считали байт (длину файла)
 664++86B1              	; xor a ;флаги сбросим
 665++86B1                  ; ret
 666++86B1
 667++86B1              ; A - file stream id
 668++86B1              ; BC - length
 669++86B1              ; HL - buffer
 670++86B1              ; Returns:
 671++86B1              ;   BC - actually written bytes
 672++86B1              fwrite: ;
 673++86B1 59           	ld e,c ;сохранить длину
 674++86B2 50           	ld d,b
 675++86B3              	OS_FILE_WRITE
 675++86B3 0E 24       >    ld c,#24
 675++86B5 E7          >    rst #20
 676++86B6 C9           	ret
 677++86B7
 678++86B7                  ; push hl : pop ix
 679++86B7                  ; esxCall ESX_FWRITE
 680++86B7
 681++86B7              	; push af
 682++86B7              	; ld a,2
 683++86B7              	; out (254),a
 684++86B7
 685++86B7              	; xor a
 686++86B7              	; out (254),a
 687++86B7              	; pop af
 688++86B7
 689++86B7              	; cp 2 ;id = 2?
 690++86B7              	; jr z,fwrite_chek ;проверка id потока
 691++86B7              	; cp 3 ;id = 3?
 692++86B7              	; jr z,fwrite_chek_trd ;проверка id потока
 693++86B7              	; cp 4 ;id = 4?
 694++86B7              	; jp z,fwrite_chek_scl ;проверка id потока
 695++86B7              	; cp 6 ;id = 6?
 696++86B7              	; jp z,fwrite_chek_fat ;проверка id потока
 697++86B7
 698++86B7
 699++86B7              ; fwrite_no_chek ;выход с ошибкой
 700++86B7              	; ld a,1
 701++86B7              	; ld (com_file_err_flag),a
 702++86B7              	; xor a
 703++86B7              	; scf ;флаг ошибки
 704++86B7              	; ld bc,0 ;ничего мы не записали
 705++86B7              	; ret
 706++86B7
 707++86B7              ; fwrite_chek ;запись произвольного типа файла (id=2)
 708++86B7
 709++86B7              	; ;не отличается от записи trd, пишется входящий поток на диск, отличия при открытии и закрытии файла
 710++86B7
 711++86B7
 712++86B7
 713++86B7
 714++86B7
 715++86B7              ; fwrite_chek_trd ;запись trd файла (разворачивание образа, id=3)
 716++86B7              	; ; ld a,2
 717++86B7              	; ; out (254),a
 718++86B7
 719++86B7              	; ; xor a
 720++86B7              	; ; out (254),a
 721++86B7              	; ld a,(f_w_flag)
 722++86B7              	; or a
 723++86B7              	; jr z,fwrite_no_chek ;файл уже открыт?
 724++86B7              	; ld (temp_bc),bc ;длина
 725++86B7              	; ld (temp_hl),hl ;адрес данных
 726++86B7              	; ld a,b
 727++86B7              	; or c
 728++86B7              	; jr z,fwrite_no_chek ; если длина 0, то выход
 729++86B7
 730++86B7              	; ;защита от переполнения диска
 731++86B7              	; ld de,(#5cf4)
 732++86B7              	; ld a,d
 733++86B7              	; cp #a0 ;последняя дорожка 160
 734++86B7              	; jr nc,fwrite_no_chek
 735++86B7
 736++86B7              	; xor a
 737++86B7              	; ld (sec_part),a ;обнулить переменные
 738++86B7              	; ld (sec_shift2),a
 739++86B7              	; ld (sec_shift2+1),a
 740++86B7              	; ld (sec_shift_flag),a
 741++86B7              	; ld (write_end_flag),a ;
 742++86B7
 743++86B7
 744++86B7              	; ld a,(sec_shift)
 745++86B7              	; or a
 746++86B7              	; jr z,fwrite_trd3 ;если смещения нет, то первую часть пропустим
 747++86B7
 748++86B7
 749++86B7              	; ld c,a
 750++86B7              	; ld b,0
 751++86B7              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 752++86B7              	; add hl,bc
 753++86B7
 754++86B7              	; ld a,1
 755++86B7              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 756++86B7
 757++86B7              	; ld a,h
 758++86B7              	; or a
 759++86B7              	; jr nz,fwrite_trd4
 760++86B7              	; ld a,1
 761++86B7              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 762++86B7
 763++86B7              ; fwrite_trd4
 764++86B7              	; ld hl,sec_buf ;буфер последнего сектора
 765++86B7              	; add hl,bc ;на этой точке остановились
 766++86B7              	; ex de,hl
 767++86B7              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 768++86B7              	; ; ld a,c
 769++86B7              	; ; or a
 770++86B7              	; ; jr nz,fwrite_trd2
 771++86B7              	; ; inc b ;коррекция
 772++86B7              ; ; fwrite_trd2
 773++86B7              	; ; ld c,a
 774++86B7              	; xor a
 775++86B7              	; sub c
 776++86B7              	; ld c,a ;сколько осталось перенести до заполнения сектора
 777++86B7              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 778++86B7              	; ldir
 779++86B7
 780++86B7              	; ld a,(sec_shift_flag)
 781++86B7              	; or a
 782++86B7              	; jr nz,fwrite_trd3 ;если сектор ещё не заполнен писать не будем
 783++86B7
 784++86B7              	; ld hl,sec_buf
 785++86B7              	; ld de,(#5cf4)
 786++86B7              	; ;ld (f_w_cur_trk),de	;запомним позицию
 787++86B7                  ; ld      bc,#0106 ;пишем 1 сектор из буфера
 788++86B7                  ; call    call3d13
 789++86B7              	; ld a,c
 790++86B7              	; cp 255
 791++86B7              	; jp z,fwrite_no_chek ;выход если ошибка
 792++86B7
 793++86B7              	; xor a
 794++86B7              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 795++86B7              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 796++86B7              	; ; ld (#5cf4),de
 797++86B7              	; ; ld b,1 ;на сектор вперёд
 798++86B7              	; ; ld de,(f_w_cur_trk)
 799++86B7              	; ; call calc_next_pos
 800++86B7              	; ; ld (f_w_cur_trk),de
 801++86B7
 802++86B7              ; fwrite_trd3
 803++86B7              	; ld hl,(temp_hl) ;запишем остаток данных
 804++86B7              	; ;ld a,(sec_shift)
 805++86B7              	; ;ld c,a
 806++86B7              	; ;ld b,0
 807++86B7              	; ld bc,(sec_shift2)
 808++86B7              	; add hl,bc ;с этой точки пишем
 809++86B7              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 810++86B7
 811++86B7              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 812++86B7              	; and a
 813++86B7              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 814++86B7              	; ld c,l
 815++86B7              	; ld b,h
 816++86B7              	; jr nc,fwrite_trd5
 817++86B7              	; ld b,0 ;коррекция если вышел минус
 818++86B7              ; fwrite_trd5
 819++86B7              	; ld hl,(temp_hl)
 820++86B7              	; add hl,bc
 821++86B7
 822++86B7              	; ld de,outputBuffer
 823++86B7              	; and a
 824++86B7              	; sbc hl,de
 825++86B7
 826++86B7              	; ld a,l
 827++86B7              	; ld (sec_shift),a ;смещение на следующий раз
 828++86B7              	; ;ld hl,(temp_hl)
 829++86B7
 830++86B7
 831++86B7              	; ; or a
 832++86B7              	; ; jr z,fwrite_trd1
 833++86B7              	; ; inc b  ;коррекция количества секторов
 834++86B7
 835++86B7              	; ld a,b ;нужна проверка на количество секторов!!!
 836++86B7              	; ld (sec_part),a ;запомним сколько секторов во второй части
 837++86B7
 838++86B7              	; ;ld a,b
 839++86B7              	; or a
 840++86B7              	; jr z,fwrite_trd1 ;если размер данных меньше сектора, то пропустим запись
 841++86B7
 842++86B7              	; ld hl,(temp_hl2)
 843++86B7              	; ;push bc
 844++86B7              	; ld de,(#5cf4)
 845++86B7                  ; ld      c,6 ;пишем целыми секторами
 846++86B7                  ; call    call3d13
 847++86B7              	; ld a,c
 848++86B7              	; ;pop bc
 849++86B7              	; cp 255
 850++86B7              	; jp z,fwrite_no_chek ;выход если ошибка
 851++86B7              	; ; ld de,(f_w_cur_trk)
 852++86B7              	; ; call calc_next_pos
 853++86B7              	; ; ld (f_w_cur_trk),de
 854++86B7
 855++86B7              	; xor a
 856++86B7              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 857++86B7
 858++86B7              ; fwrite_trd1
 859++86B7              	; ld a,(write_end_flag) ;нужно записывать остаток?
 860++86B7              	; or a
 861++86B7              	; jr nz,fwrite_trd_ex ;не нужно
 862++86B7
 863++86B7              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
 864++86B7              	; ld a,(sec_part)
 865++86B7              	; ld b,a
 866++86B7              	; ld c,0
 867++86B7              	; add hl,bc
 868++86B7              	; ld de,sec_buf
 869++86B7              	; ld bc,256
 870++86B7              	; ldir
 871++86B7              ; ;fwrite_trd2
 872++86B7
 873++86B7
 874++86B7              ; fwrite_trd_ex
 875++86B7              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 876++86B7              	; ;посчитаем общую длину записанного
 877++86B7              	; ld hl,(f_w_len)
 878++86B7              	; add hl,bc
 879++86B7              	; ld (f_w_len),hl
 880++86B7              	; jr nc,fwrite_trd_ex1
 881++86B7              	; ld hl,(f_w_len+2)
 882++86B7              	; inc hl
 883++86B7              	; ld (f_w_len+2),hl
 884++86B7
 885++86B7              ; fwrite_trd_ex1
 886++86B7              	; xor a ;флаги сбросим
 887++86B7                  ; ret
 888++86B7
 889++86B7
 890++86B7
 891++86B7
 892++86B7
 893++86B7              ; ;------------------scl----------------------
 894++86B7              ; fwrite_chek_scl ;запись scl файла (разворачивание образа, id=4)
 895++86B7              	; ; ld a,2
 896++86B7              	; ; out (254),a
 897++86B7
 898++86B7              	; ; xor a
 899++86B7              	; ; out (254),a
 900++86B7              	; ld a,(f_w_flag)
 901++86B7              	; or a
 902++86B7              	; jp z,fwrite_no_chek ;файл уже открыт?
 903++86B7              	; ld (temp_bc),bc ;длина
 904++86B7              	; ld (temp_hl),hl ;адрес данных
 905++86B7              	; ld a,b
 906++86B7              	; or c
 907++86B7              	; jp z,fwrite_no_chek ; если длина 0, то выход
 908++86B7
 909++86B7              	; ; ld a,b
 910++86B7              	; ; or a
 911++86B7              	; ; jr nz,testt1
 912++86B7              	; ; nop
 913++86B7
 914++86B7              ; ; testt1
 915++86B7
 916++86B7              	; xor a
 917++86B7              	; ld (sec_part),a ;обнулить переменные
 918++86B7              	; ld (sec_shift2),a
 919++86B7              	; ld (sec_shift2+1),a
 920++86B7              	; ld (sec_shift_flag),a
 921++86B7              	; ld (write_end_flag),a ;
 922++86B7
 923++86B7
 924++86B7              	; ld a,(sec_shift)
 925++86B7              	; or a
 926++86B7              	; jr z,fwrite_scl3 ;если смещения нет, то первую часть пропустим
 927++86B7
 928++86B7
 929++86B7              	; ld c,a
 930++86B7              	; ld b,0
 931++86B7              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 932++86B7              	; add hl,bc
 933++86B7
 934++86B7              	; ld a,1
 935++86B7              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 936++86B7
 937++86B7              	; ld a,h
 938++86B7              	; or a
 939++86B7              	; jr nz,fwrite_scl4
 940++86B7              	; ld a,1
 941++86B7              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 942++86B7
 943++86B7              ; fwrite_scl4
 944++86B7              	; ld hl,sec_buf ;буфер последнего сектора
 945++86B7              	; add hl,bc ;на этой точке остановились
 946++86B7              	; ex de,hl
 947++86B7              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 948++86B7              	; ; ld a,c
 949++86B7              	; ; or a
 950++86B7              	; ; jr nz,fwrite_scl2
 951++86B7              	; ; inc b ;коррекция
 952++86B7              ; ; fwrite_scl2
 953++86B7              	; ; ld c,a
 954++86B7              	; xor a
 955++86B7              	; sub c
 956++86B7              	; ld c,a ;сколько осталось перенести до заполнения сектора
 957++86B7              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 958++86B7              	; ldir
 959++86B7
 960++86B7              	; ld a,(sec_shift_flag)
 961++86B7              	; or a
 962++86B7              	; jr nz,fwrite_scl3 ;если сектор ещё не заполнен писать не будем
 963++86B7
 964++86B7              	; ld hl,sec_buf
 965++86B7              	; ;ld de,(#5cf4)
 966++86B7              	; ;ld (f_w_cur_trk),de	;запомним позицию
 967++86B7                  ; ld      b,#01 ;пишем 1 сектор из буфера
 968++86B7                  ; call    scl_write_buf
 969++86B7              	; ; ld a,c
 970++86B7              	; ; cp 255
 971++86B7              	; ; jp z,fwrite_no_chek ;выход если ошибка
 972++86B7
 973++86B7              	; xor a
 974++86B7              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 975++86B7              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 976++86B7              	; ; ld (#5cf4),de
 977++86B7              	; ; ld b,1 ;на сектор вперёд
 978++86B7              	; ; ld de,(f_w_cur_trk)
 979++86B7              	; ; call calc_next_pos
 980++86B7              	; ; ld (f_w_cur_trk),de
 981++86B7
 982++86B7              ; fwrite_scl3
 983++86B7              	; ld hl,(temp_hl) ;запишем остаток данных
 984++86B7              	; ;ld a,(sec_shift)
 985++86B7              	; ;ld c,a
 986++86B7              	; ;ld b,0
 987++86B7              	; ld bc,(sec_shift2)
 988++86B7              	; add hl,bc ;с этой точки пишем
 989++86B7              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 990++86B7
 991++86B7              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 992++86B7              	; and a
 993++86B7              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 994++86B7              	; ld c,l
 995++86B7              	; ld b,h
 996++86B7              	; jr nc,fwrite_scl5
 997++86B7              	; ld b,0 ;коррекция если вышел минус
 998++86B7              ; fwrite_scl5
 999++86B7              	; ld hl,(temp_hl)
1000++86B7              	; add hl,bc
1001++86B7
1002++86B7              	; ld de,outputBuffer
1003++86B7              	; and a
1004++86B7              	; sbc hl,de
1005++86B7
1006++86B7              	; ld a,l
1007++86B7              	; ld (sec_shift),a ;смещение на следующий раз
1008++86B7              	; ;ld hl,(temp_hl)
1009++86B7
1010++86B7
1011++86B7              	; ; or a
1012++86B7              	; ; jr z,fwrite_scl1
1013++86B7              	; ; inc b  ;коррекция количества секторов
1014++86B7
1015++86B7              	; ld a,b ;нужна проверка на количество секторов!!!
1016++86B7              	; ld (sec_part),a ;запомним сколько секторов во второй части
1017++86B7
1018++86B7              	; ;ld a,b
1019++86B7              	; or a
1020++86B7              	; jr z,fwrite_scl1 ;если размер данных меньше сектора, то пропустим запись
1021++86B7
1022++86B7              	; ld hl,(temp_hl2)
1023++86B7              	; ;push bc
1024++86B7              	; ;ld de,(#5cf4)
1025++86B7                  ; ;ld      c,6 ;пишем целыми секторами
1026++86B7                  ; call    scl_write_buf
1027++86B7              	; ;ld a,c
1028++86B7              	; ;pop bc
1029++86B7              	; ; cp 255
1030++86B7              	; ; jp z,fwrite_no_chek ;выход если ошибка
1031++86B7              	; ; ld de,(f_w_cur_trk)
1032++86B7              	; ; call calc_next_pos
1033++86B7              	; ; ld (f_w_cur_trk),de
1034++86B7
1035++86B7              	; xor a
1036++86B7              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
1037++86B7
1038++86B7              ; fwrite_scl1
1039++86B7              	; ld a,(write_end_flag) ;нужно записывать остаток?
1040++86B7              	; or a
1041++86B7              	; jr nz,fwrite_scl_ex ;не нужно
1042++86B7
1043++86B7              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
1044++86B7              	; ld a,(sec_part)
1045++86B7              	; ld b,a
1046++86B7              	; ld c,0
1047++86B7              	; add hl,bc
1048++86B7              	; ld de,sec_buf
1049++86B7              	; ld bc,256
1050++86B7              	; ldir
1051++86B7              ; ;fwrite_scl2
1052++86B7
1053++86B7
1054++86B7              ; fwrite_scl_ex
1055++86B7              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1056++86B7              	; ;посчитаем общую длину записанного
1057++86B7              	; ld hl,(f_w_len)
1058++86B7              	; add hl,bc
1059++86B7              	; ld (f_w_len),hl
1060++86B7              	; jr nc,fwrite_scl_ex1
1061++86B7              	; ld hl,(f_w_len+2)
1062++86B7              	; inc hl
1063++86B7              	; ld (f_w_len+2),hl
1064++86B7
1065++86B7              ; fwrite_scl_ex1
1066++86B7              	; xor a ;флаги сбросим
1067++86B7                  ; ret
1068++86B7
1069++86B7
1070++86B7
1071++86B7
1072++86B7
1073++86B7
1074++86B7              ; scl_write_buf ;заполнение промежуточного буфера
1075++86B7              	; push bc ;сколько пакетов указано в b
1076++86B7              	; ld de,scl_buf ;перенесём сектор во временный буфер
1077++86B7              	; ld bc,256
1078++86B7              	; ldir
1079++86B7              	; ld (scl_temp_hl2),hl ;сохраним адрес данных
1080++86B7              	; ld a,(scl_que) ;проверим флаг что нужны данные
1081++86B7              	; or a
1082++86B7              	; jr z,scl_write_buf_ret ;не будем вызывать парсер если не нужны
1083++86B7              	; ld hl,scl_write_buf_ret ;адрес возврата
1084++86B7              	; push hl
1085++86B7              	; ld hl,(scl_parse_ret_adr) ;адрес для продолжения основного цикла сборки
1086++86B7              	; jp (hl) ;отдадим пакет 256 байт парсеру
1087++86B7              ; scl_write_buf_ret
1088++86B7              	; ld hl,(scl_temp_hl2)
1089++86B7              	; pop bc
1090++86B7              	; djnz scl_write_buf
1091++86B7
1092++86B7              	; ret
1093++86B7
1094++86B7
1095++86B7
1096++86B7              ; scl_parse ;разбор образа scl в trd, основной цикл
1097++86B7              	; ;получить первый сектор
1098++86B7              ; ;запрос порции данных по 256 байт
1099++86B7              	; ld (scl_temp_hl),hl
1100++86B7              	; ld (scl_temp_de),de
1101++86B7              	; ld (scl_temp_bc),bc
1102++86B7              	; ld a,1
1103++86B7              	; ld (scl_que),a ;включим флаг что нужны данные
1104++86B7              	; ld hl,scl_parse_ret ;сохраним адрес возврата
1105++86B7              	; ld (scl_parse_ret_adr),hl
1106++86B7              	; ret ;вернёмся для ожидания данных
1107++86B7              ; scl_parse_ret
1108++86B7              	; xor a
1109++86B7              	; ld (scl_que),a
1110++86B7              	; ld hl,(scl_temp_hl)
1111++86B7              	; ld de,(scl_temp_de)
1112++86B7              	; ld bc,(scl_temp_bc)
1113++86B7
1114++86B7              	; ld de,scl_buf ;проверка метки образа
1115++86B7              	; ld hl,scl_sign
1116++86B7              	; ld b,8
1117++86B7              ; scl_parse_chk
1118++86B7              	; ld a,(de)
1119++86B7              	; cp (hl)
1120++86B7              	; jr nz,scl_parse_chk_no
1121++86B7              	; inc hl
1122++86B7              	; inc de
1123++86B7              	; djnz scl_parse_chk
1124++86B7              	; jr scl_parse_chk_ok
1125++86B7              ; scl_parse_chk_no ;если не совпало, значит плохой образ
1126++86B7                  ; ld hl, scl_err
1127++86B7                  ; call DialogBox.msgBox ;предуреждение
1128++86B7              	; xor a
1129++86B7              	; ld (scl_que),a ;выключим флаг что нужны данные
1130++86B7              	; ld a,4 ;закроем файл
1131++86B7              	; call fclose
1132++86B7              	; ret
1133++86B7              ; scl_parse_chk_ok ;сигнатура правильная
1134++86B7
1135++86B7              ; ;формирование каталога
1136++86B7              	; ld a,(scl_buf+8)
1137++86B7              	; ld (scl_files),a ;всего файлов
1138++86B7              	; ld (scl_cat_cycl),a ;цикл
1139++86B7              	; ld hl,scl_buf+9 ;адрес первого заголовка
1140++86B7              	; ld de,cat_buf ;адрес формируемого каталога trd
1141++86B7              ; scl_parse_cat2
1142++86B7              	; ld b,14 ;14 байт одна запись
1143++86B7              ; scl_parse_cat
1144++86B7              	; ld a,(hl)
1145++86B7              	; ld (de),a
1146++86B7              	; inc de
1147++86B7              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1148++86B7              	; jr nz,scl_parse_cat1
1149++86B7              	; ;тут пора запросить следующий сектор
1150++86B7              ; ;запрос порции данных по 256 байт
1151++86B7              	; ld (scl_temp_hl),hl
1152++86B7              	; ld (scl_temp_de),de
1153++86B7              	; ld (scl_temp_bc),bc
1154++86B7              	; ld a,1
1155++86B7              	; ld (scl_que),a ;включим флаг что нужны данные
1156++86B7              	; ld hl,scl_parse_ret1 ;сохраним адрес возврата
1157++86B7              	; ld (scl_parse_ret_adr),hl
1158++86B7              	; ret ;вернёмся для ожидания данных
1159++86B7              ; scl_parse_ret1
1160++86B7              	; xor a
1161++86B7              	; ld (scl_que),a
1162++86B7              	; ld hl,(scl_temp_hl)
1163++86B7              	; ld de,(scl_temp_de)
1164++86B7              	; ld bc,(scl_temp_bc)
1165++86B7
1166++86B7              ; scl_parse_cat1
1167++86B7              	; djnz scl_parse_cat
1168++86B7              	; inc de
1169++86B7              	; inc de
1170++86B7              	; ld a,(scl_cat_cycl)
1171++86B7              	; dec a
1172++86B7              	; ld (scl_cat_cycl),a
1173++86B7              	; jr nz,scl_parse_cat2
1174++86B7
1175++86B7              	; ld (scl_temp_hl),hl ;запомнить где остановились
1176++86B7
1177++86B7              ; ;подсчёт секторов и дорожек
1178++86B7              	; push ix
1179++86B7              	; ld a,(scl_files)
1180++86B7              	; ld de,#0100 ;данные с первой дорожки
1181++86B7              	; ld ix,cat_buf
1182++86B7              	; ld (ix+14),e
1183++86B7              	; ld (ix+15),d
1184++86B7              	; ld hl,0 ;общее количество секторов
1185++86B7              ; scl_cacl
1186++86B7              	; ld (scl_cat_cycl),a ;цикл
1187++86B7              	; ld a,(ix+13) ;длина файла в секторах
1188++86B7              	; ld c,a
1189++86B7              	; ld b,0
1190++86B7              	; add hl,bc ;секторов
1191++86B7
1192++86B7              	; ld bc,16
1193++86B7              	; add ix,bc
1194++86B7              	; ld b,a
1195++86B7              	; call calc_next_pos
1196++86B7              	; ld a,(scl_cat_cycl)
1197++86B7              	; cp 1
1198++86B7              	; jr z,scl_cacl2 ;в последний раз пропусим
1199++86B7              	; ld (ix+14),e
1200++86B7              	; ld (ix+15),d
1201++86B7              ; scl_cacl2
1202++86B7              	; dec a
1203++86B7              	; jr nz,scl_cacl
1204++86B7              	; ;теперь узнаем первый свободный сектор
1205++86B7              	; ld a,(ix+13) ;длина файла в секторах
1206++86B7              	; ld c,a
1207++86B7              	; ld b,0
1208++86B7              	; add hl,bc
1209++86B7              	; ; ld b,a
1210++86B7              	; ; call calc_next_pos
1211++86B7              	; ld (cat_buf+8*256+#e1),de ;Первый свободный сектор и дорожка на дискете
1212++86B7              	; ld de,16*159
1213++86B7              	; ex de,hl
1214++86B7              	; and a
1215++86B7              	; sbc hl,de
1216++86B7              	; ld (cat_buf+8*256+#e5),hl ;Число свободных секторов на диске
1217++86B7              	; pop ix
1218++86B7
1219++86B7
1220++86B7
1221++86B7              ; ;запись содержимого файлов
1222++86B7              	; ld a,(scl_files) ;всего файлов
1223++86B7              	; ld (scl_cat_cycl),a ;цикл
1224++86B7              	; ld hl,cat_buf+13 ;адрес размер секторов файла
1225++86B7              	; ld (cat_cur_adr),hl
1226++86B7
1227++86B7              	; ld hl,#0100 ;начиная с первой дорожки
1228++86B7              	; ld (#5cf4),hl
1229++86B7              ; scl_parse_file2
1230++86B7              	; ld hl,(scl_temp_hl) ;адрес данных
1231++86B7              	; ld de,(cat_cur_adr) ;адрес сектор дорожка файла
1232++86B7              	; ;dec de
1233++86B7              	; ld a,(de) ;количество секторов, цикл
1234++86B7              	; ld c,a
1235++86B7              ; scl_parse_file3
1236++86B7              	; ld de,scl_buf2 ;адрес ещё одного буфера
1237++86B7              	; ld b,0 ;256 байт один сектор, цикл
1238++86B7              ; scl_parse_file
1239++86B7              	; ld a,(hl)
1240++86B7              	; ld (de),a
1241++86B7              	; inc de
1242++86B7              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1243++86B7              	; jr nz,scl_parse_file1
1244++86B7              	; ;тут пора запросить следующий сектор
1245++86B7              ; ;запрос порции данных по 256 байт
1246++86B7              	; ld (scl_temp_hl),hl
1247++86B7              	; ld (scl_temp_de),de
1248++86B7              	; ld (scl_temp_bc),bc
1249++86B7              	; ld a,1
1250++86B7              	; ld (scl_que),a ;включим флаг что нужны данные
1251++86B7              	; ld hl,scl_parse_ret2 ;сохраним адрес возврата
1252++86B7              	; ld (scl_parse_ret_adr),hl
1253++86B7              	; ret ;вернёмся для ожидания данных
1254++86B7              ; scl_parse_ret2
1255++86B7              	; xor a
1256++86B7              	; ld (scl_que),a
1257++86B7              	; ld hl,(scl_temp_hl)
1258++86B7              	; ld de,(scl_temp_de)
1259++86B7              	; ld bc,(scl_temp_bc)
1260++86B7
1261++86B7              ; scl_parse_file1
1262++86B7              	; djnz scl_parse_file
1263++86B7              	; ld (scl_temp_hl),hl
1264++86B7              	; ld (scl_temp_bc),bc
1265++86B7
1266++86B7              	; ld hl,scl_buf2 ;;запишем один сектор
1267++86B7              	; ld  de,(#5cf4)
1268++86B7                  ; ld      bc,#0106 ;
1269++86B7                  ; call    call3d13
1270++86B7              	; ; ld a,c
1271++86B7              	; ; cp 255
1272++86B7              	; ; jp z,fwrite_no_chek ;выход если ошибка
1273++86B7              	; ld hl,(scl_temp_hl)
1274++86B7              	; ld bc,(scl_temp_bc)
1275++86B7
1276++86B7              	; dec c
1277++86B7              	; jr nz,scl_parse_file3
1278++86B7
1279++86B7              	; ld hl,(cat_cur_adr) ;адрес сектор дорожка файла
1280++86B7              	; ; ld e,(hl)
1281++86B7              	; ; inc hl
1282++86B7              	; ; ld d,(hl)
1283++86B7              	; ld bc,16
1284++86B7              	; add hl,bc ;на следующий файл
1285++86B7              	; ld (cat_cur_adr),hl
1286++86B7
1287++86B7
1288++86B7              	; ld a,(scl_cat_cycl)
1289++86B7              	; dec a
1290++86B7              	; ld (scl_cat_cycl),a
1291++86B7              	; jr nz,scl_parse_file2	;на следующий файл
1292++86B7
1293++86B7
1294++86B7
1295++86B7              ; ;формирование системного сектора №9 (8)
1296++86B7              	; ;
1297++86B7              	; ;ld (cat_buf+8*256+#e1),a ;// #E1 Первый свободный сектор на дискете
1298++86B7              	; ;
1299++86B7              	; ;ld (cat_buf+8*256+#e2),a ;// #E2 Первый свободный трек
1300++86B7              	; ld a,#16
1301++86B7              	; ld (cat_buf+8*256+#e3),a ;// #E3 16 80 дорожек, 2 стороны
1302++86B7              	; ld a,(scl_files)
1303++86B7              	; ld (cat_buf+8*256+#e4),a ;// #E4 Общее количество файлов записанных на диск
1304++86B7              	; ;
1305++86B7              	; ;ld (cat_buf+8*256+#e5),a ;// #Е5,Е6 Число свободных секторов на диске
1306++86B7              	; ;ld (cat_buf+8*256+#e6),a
1307++86B7              	; ld a,#10
1308++86B7              	; ld (cat_buf+8*256+#e7),a ;// #E7 Код  #10,определяющий принадлежность к TR-DOS
1309++86B7
1310++86B7              	; ld hl,f_name ;запишем имя диска, взяв для этого имя файла
1311++86B7              	; ld de,cat_buf+8*256+#f5 ;// #F5-#FC Имя диска в ASCII формате
1312++86B7              	; ld bc,8
1313++86B7              	; ldir
1314++86B7
1315++86B7              	; ld hl,cat_buf ;запишем каталог на диск
1316++86B7              	; ld de,0
1317++86B7                  ; ld      bc,#0906 ;
1318++86B7                  ; call    call3d13
1319++86B7              	; ; ld a,c
1320++86B7              	; ; cp 255
1321++86B7              	; ; jp z,fwrite_no_chek ;выход если ошибка
1322++86B7              	; ret
1323++86B7
1324++86B7
1325++86B7              ; ;-----------scl end --------------------
1326++86B7
1327++86B7
1328++86B7
1329++86B7              ; ;---------------------------------------
1330++86B7              ; fwrite_chek_fat ;запись файла fat
1331++86B7              	; ld (temp_bc),bc ;длина
1332++86B7              	; ld a,c ;младший байт длины
1333++86B7              	; ld	de,fcb
1334++86B7              	; R8FAT r8f09_FileWrite	;записать в файл
1335++86B7              	; jp 	c,fwrite_no_chek
1336++86B7
1337++86B7              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1338++86B7              	; ;посчитаем общую длину записанного
1339++86B7              	; ld hl,(f_w_len)
1340++86B7              	; add hl,bc
1341++86B7              	; ld (f_w_len),hl
1342++86B7              	; jr nc,fwrite_fat_ex1
1343++86B7              	; ld hl,(f_w_len+2)
1344++86B7              	; inc hl
1345++86B7              	; ld (f_w_len+2),hl
1346++86B7              ; fwrite_fat_ex1
1347++86B7              	; xor a ;флаги сбросим
1348++86B7              	; ret
1349++86B7              ;---------------------------------------
1350++86B7
1351++86B7
1352++86B7
1353++86B7              ; A - file stream id
1354++86B7              ; fsync:
1355++86B7              ;     esxCall ESX_FSYNC
1356++86B7                  ; ret
1357++86B7
1358++86B7
1359++86B7              ; ; HL - name (name.ext)
1360++86B7              ; ; Returns:
1361++86B7              ; ; HL - name (name    e)
1362++86B7              ; format_name ;подгоняет имя файла под стандарт trdos (8+1)
1363++86B7
1364++86B7              	; ;сначала попробуем убрать из пути подпапку, если она есть
1365++86B7              	; ld (temp_hl),hl ;сохраним адрес исходного имени
1366++86B7              	; ld b,#00 ;не больше 255 символов
1367++86B7              ; format_name5
1368++86B7              	; ld a,(hl)
1369++86B7              	; cp "/" ;если есть подпапка
1370++86B7              	; jr z,format_name_path_yep
1371++86B7              	; ld a,(hl)
1372++86B7              	; cp "." ;если ещё не дошли до расширения
1373++86B7              	; jr nz,format_name6
1374++86B7              	; ld hl,(temp_hl) ;если дошли до расширения, то путей нет, вернёмся на начало имени
1375++86B7              	; jr format_name_7 ;на выход
1376++86B7              ; format_name6
1377++86B7              	; inc hl
1378++86B7              	; djnz format_name5
1379++86B7
1380++86B7              ; format_name_path_yep ;нашли
1381++86B7              	; inc hl ;пропустим знак "/"
1382++86B7
1383++86B7              ; format_name_7
1384++86B7
1385++86B7              	; push hl ;очистим место для нового имени
1386++86B7              	; ld hl,f_name
1387++86B7              	; ld de,f_name+1
1388++86B7              	; ld (hl)," "
1389++86B7              	; ld bc,8+1
1390++86B7              	; ldir
1391++86B7              	; ld (hl),0
1392++86B7              	; ld bc,16-8-1-1
1393++86B7              	; ldir
1394++86B7              	; pop hl
1395++86B7
1396++86B7              	; ld bc,#09ff ;длина имени 9 символов
1397++86B7              	; ld de,f_name ;куда
1398++86B7              ; format_name2
1399++86B7              	; ld a,(hl)
1400++86B7              	; cp "."
1401++86B7              	; jr nz,format_name1
1402++86B7              	; ld de,f_name+8
1403++86B7              	; inc hl
1404++86B7              	; ldi ; и в конце расширение 3 буквы
1405++86B7              	; ldi
1406++86B7              	; ldi
1407++86B7              	; ;ex de,hl ;сохраним адрес исходного расширения
1408++86B7              	; jr format_name_e
1409++86B7              ; format_name1
1410++86B7              	; ldi
1411++86B7              	; djnz format_name2
1412++86B7
1413++86B7              	; ;если имя длинное, пропустим лишнее до расширения
1414++86B7              	; ld b,#00 ;не больше 255 символов
1415++86B7              ; format_name3
1416++86B7              	; ld a,(hl)
1417++86B7              	; cp "."
1418++86B7              	; jr nz,format_name4
1419++86B7              	; ld de,f_name+8
1420++86B7              	; inc hl
1421++86B7              	; ldi ; и в конце расширение 3 буквы
1422++86B7              	; ldi
1423++86B7              	; ldi
1424++86B7              	; ;ex de,hl ;сохраним адрес исходного расширения
1425++86B7              	; jr format_name_e
1426++86B7              ; format_name4
1427++86B7              	; inc hl
1428++86B7              	; djnz format_name3
1429++86B7
1430++86B7              ; format_name_e ;выход
1431++86B7              	; ld hl,f_name ;вернём результат
1432++86B7              	; ret
1433++86B7
1434++86B7              ; ; DE - trk/sec
1435++86B7              ; ; B - sectors step
1436++86B7              ; ; Returns:
1437++86B7              ; ; DE - trk/sec
1438++86B7              ; calc_next_pos		;вперёд на N секторов
1439++86B7              			; ;ld b,4
1440++86B7              			; ;ld  de,(#5ceb)
1441++86B7              ; calc_next_pos2
1442++86B7              			; inc e
1443++86B7              			; ld a,e
1444++86B7              			; cp 16
1445++86B7              			; jr c,calc_next_pos1
1446++86B7              			; inc d
1447++86B7              			; ld e,0
1448++86B7              ; calc_next_pos1
1449++86B7              			; ;ld (#5ceb),de
1450++86B7              			; djnz calc_next_pos2
1451++86B7              			; ret
1452++86B7
1453++86B7
1454++86B7              ; ;testt db "123.trd"
1455++86B7              ; write_ima db "Select disk "
1456++86B7              ; write_ima_d db "A: (A-" ;текущая буква
1457++86B7              ; write_ima_e	db "D). " ;последняя буква
1458++86B7              		; db "All data may be lost! Press Y or N.",0
1459++86B7              ; ;prev_drive db 0 ;предыдущий номер дисковода
1460++86B7              ; curr_drive db 0 ;текущий диск
1461++86B7
1462++86B7              ; trdExt1 db ".trd", 0
1463++86B7              ; trdExt2 db ".TRD", 0
1464++86B7
1465++86B7              ; sclExt1 db ".scl", 0
1466++86B7              ; sclExt2 db ".SCL", 0
1467++86B7
1468++86B7              ;f_name ds 16 ;имя файла
1469++86B7              ; f_r_cur_trk dw 	 0 ;текущие сектор-дорожка файла на чтение
1470++86B7              ; f_r_len_sec db 0 ;длина файла на чтение в секторах
1471++86B7              ; f_r_len dw 0;длина файла в байтах
1472++86B7              ; f_r_flag db 0 ;флаг что открыт файл на чтение
1473++86B7
1474++86B7              ; f_w_cur_trk dw 	 0 ;текущие сектор-дорожка файла на запись
1475++86B7              ; f_w_len_sec db 0 ;длина файла на запись в секторах
1476++86B7              ; f_w_flag db 0 ;флаг что открыт файл на запись
1477++86B7              ; f_w_len ds 4 ;длина записанных данных
1478++86B7              ; write_end_flag db 0 ;флаг что нужно записать остаток
1479++86B7
1480++86B7              ; temp_bc dw 0 ;хранение регистра
1481++86B7              ;temp_hl dw 0 ;хранение регистра
1482++86B7              ; temp_hl2 dw 0 ;хранение регистра
1483++86B7
1484++86B7              ; sec_shift db 0 ;указатель на каком байте остановлена запись
1485++86B7              ; sec_shift2 db 0 ;указатель на каком байте остановлена запись (остаток)
1486++86B7              ; sec_part db 0 ;сколько секторов во второй порции для записи
1487++86B7              ; sec_shift_flag db 0 ;флаг что буфер сектора не заполнен
1488++86B7
1489++86B7              ; ;секция scl
1490++86B7              ; scl_sign db "SINCLAIR" ;метка
1491++86B7              ; scl_que db 0 ;флаг запроса порции данных
1492++86B7              ; scl_err db "SCL image error!",0
1493++86B7              ; scl_parse_ret_adr dw 0; адрес возврата в цикл
1494++86B7              ; scl_cat_cycl db 0 ;переменная цикла
1495++86B7              ; scl_files db 0 ;всего файлов
1496++86B7              ; scl_temp_hl dw 0;;хранение регистра
1497++86B7              ; scl_temp_hl2 dw 0;
1498++86B7              ; scl_temp_de dw 0;
1499++86B7              ; scl_temp_bc dw 0;
1500++86B7              ; cat_cur_adr dw 0;
1501++86B7              ; ;scl end
1502++86B7
1503++86B7              ; ;секция сохранения любого файла
1504++86B7              ; file_err db "Not enough space!",0
1505++86B7              ; sec_cat db 0 ;сектор каталога
1506++86B7              ; file_num db "0" ;номер части для больших файлов
1507++86B7
1508++86B7              	; ;по адресу #4000 шрифт
1509++86B7              ; cat_buf equ #4800 ;буфер для кататога диска 9*256
1510++86B7              ; sec_buf equ cat_buf + 9*256 ;буфер сектора для записи 256
1511++86B7              ; scl_buf equ sec_buf + 512 ;промежуточный буфер 256
1512++86B7              ; scl_buf2 equ scl_buf + 512 ;промежуточный буфер 256
1513++86B7              ; ;общая ошибка с файлами
1514++86B7              ; com_file_err db "File error!",0
1515++86B7              ; com_file_err_flag db 0 ;общая ошибка
1516++86B7
1517++86B7
1518++86B7
1519++86B7
1520++86B7              ; ;Раздел SMUC и SD ------------------------------------
1521++86B7
1522++86B7
1523++86B7              ; ;список доступных разделов на винчестерах
1524++86B7              ; ;7,=0/1 тип раздела MFS/FAT
1525++86B7              ; ;6,=1 раздел есть
1526++86B7              ; ;3,=0/1 Hdd/SD card
1527++86B7              ; ;2,=0/1 для HDD master/slave
1528++86B7              ; ;0..1,=?? номер раздела
1529++86B7              ; ;
1530++86B7              ; typeDrive	ds 3*4+1
1531++86B7              ; ;typeDriveFAT	ds 3*4+1 ;список всех разделов FAT
1532++86B7              ; numDrives db 0 ;количество устройств
1533++86B7              ; ;numDrivesFAT db 0 ;количество устройств FAT
1534++86B7              ; next_lett db 0 ;следующая свободная буква диска
1535++86B7
1536++86B7              ; ;подсчет количества доступных разделов на всех устройствах
1537++86B7              ; ;вых: hl,a - количество устройств
1538++86B7              ; ;     typeDrives - сформированная таблица
1539++86B7              ; ;     cy=1 не обнаружено ни одного устройства
1540++86B7              ; ;
1541++86B7              ; GetNumPart
1542++86B7              ; ;
1543++86B7              	; push	de
1544++86B7              	; push	bc
1545++86B7              	; ld	hl,typeDrive
1546++86B7              	; push	hl
1547++86B7              	; xor	a
1548++86B7              	; call	proc_01			;HDD master
1549++86B7              	; ld	a,#01
1550++86B7              	; call	proc_01			;HDD slave
1551++86B7              	; ld	a,#02
1552++86B7              	; call	proc_01			;SD card
1553++86B7              	; pop	de
1554++86B7              	; or	a
1555++86B7              	; sbc	hl,de			;количество разделов на HDD
1556++86B7              	; IFDEF	useTRD
1557++86B7              	 ; ld	a,l
1558++86B7              	 ; add	a,#04
1559++86B7              	 ; ld	l,a
1560++86B7              	; ELSE
1561++86B7              	 ; ld	a,l
1562++86B7              	; ENDIF
1563++86B7              	; pop	bc
1564++86B7              	; pop	de
1565++86B7              	; ld	(numDrives),a
1566++86B7              	; cp	1
1567++86B7              	; ret
1568++86B7
1569++86B7              ; ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1570++86B7              ; ;формирование таблицы с доступными разделами на винчестере
1571++86B7              ; ;вх:  a =#00 выбрать master
1572++86B7              ; ;       =#01 выбрать slave
1573++86B7              ; ;       =#02 выбрать SD card
1574++86B7              ; ;     hl - адрес в таблице разделов typeDrives
1575++86B7              ; ;вых: hl - новый адрес в таблице разделов typeDrives
1576++86B7              ; ;
1577++86B7              ; proc_01	ld	c,a
1578++86B7              	; push	hl
1579++86B7              	; push	bc
1580++86B7              	; R8DOS	r8d2E_CngHDD
1581++86B7              	; jr	c,goto001		;на текущем канале нет винчестера
1582++86B7              	; R8DOS	r8d2D_FindPart
1583++86B7              ; goto001	pop	bc
1584++86B7              	; pop	hl
1585++86B7              	; ret	c			;на текущем винчестере нет разделов
1586++86B7              	; ld	b,a
1587++86B7              	; ld	a,c
1588++86B7              	; add	a,a
1589++86B7              	; add	a,a
1590++86B7              	; ld	c,a			;номер винчестера и первого раздела
1591++86B7              	; ld	a,b
1592++86B7              	; ld	b,#04
1593++86B7              ; loop001	ld	(hl),#00
1594++86B7              	; rra
1595++86B7              	; jr	nc,goto002		;нет раздела
1596++86B7              	; IFDEF	useMFS
1597++86B7              	 ; ld	(hl),c
1598++86B7              	 ; set	6,(hl)			;=%01???hpp MFS
1599++86B7              	 ; rra
1600++86B7              	 ; jr	nc,goto003		;это MFS
1601++86B7              	 ; set	7,(hl)			;=%11???hpp это FAT
1602++86B7              	; ELSE
1603++86B7              	 ; rra
1604++86B7              	 ; jr	nc,goto004		;это MFS
1605++86B7              	 ; ld	(hl),c
1606++86B7              	 ; set	6,(hl)			;раздел есть
1607++86B7              	 ; set	7,(hl)			;=%11???hpp это FAT
1608++86B7              	; ENDIF
1609++86B7              ; goto003	inc	hl
1610++86B7              	; rla
1611++86B7              ; goto002	rra
1612++86B7              ; goto004	inc	c
1613++86B7              	; djnz	loop001
1614++86B7              	; ret
1615++86B7
1616++86B7
1617++86B7
1618++86B7              ; hdd_init_flag: db 0 ;флаг инициализации
1619++86B7              ; ;fcb_tmp ds 32 ;буфер fcb временно
1620++86B7              ; ActPathFAT db "\\Download",0 ;папка для сохранений
1621++86B7              ; fcb ds 32	;буфер fcb
1622++86B7              	; nop
1623++86B7              ; ;конец секции SMUC и SD ----------------------------
1624++86B7 5C 4F 53 5A  path_os db "\\OSZ",0
1624++86BB 00
1625++86BC 5C 4F 53 5A  path_download db "\\OSZ\\Download\\MoonR",0
1625++86C0 5C 44 6F 77
1625++86C4 6E 6C 6F 61
1625++86C8 64 5C 4D 6F
1625++86CC 6F 6E 52 00
1626++86D0              ;path_deskr ds 32 ;дескриптор каталога
1627++86D0
1628++86D0
1629++86D0                  ENDMODULE
# file closed: dos/zsfat.asm
   9+ 86D0              	ENDIF
  10+ 86D0                  include "console.asm"
# file opened: dos/console.asm
   1++86D0                  module Console
   2++86D0              KEY_UP = 11
   3++86D0              KEY_DN = 10
   4++86D0              KEY_LT = 8
   5++86D0              KEY_RT = 9
   6++86D0              BACKSPACE = 12
   7++86D0 00           keyCode db 0
   8++86D1
   9++86D1              ;BASIC_KEY = #5C08
  10++86D1
  11++86D1              waitForKeyUp:
  12++86D1              	OS_WAIT
  12++86D1 DF          >	rst #18
  13++86D2              	OS_GET_CHAR
  13++86D2 0E 10       >    ld c,#10
  13++86D4 E7          >    rst #20
  14++86D5 FE FF           cp 255
  15++86D7 20 F8           jr nz, waitForKeyUp
  16++86D9
  17++86D9                 ; ld (BASIC_KEY), a
  18++86D9 C9              ret
  19++86DA
  20++86DA              getC:
  21++86DA              	OS_WAIT
  21++86DA DF          >	rst #18
  22++86DB              	OS_GET_CHAR
  22++86DB 0E 10       >    ld c,#10
  22++86DD E7          >    rst #20
  23++86DE                 ;ld a,(BASIC_KEY)
  24++86DE                 ;and a : jr z, getC
  25++86DE FE FF           cp 255
  26++86E0 28 F8           jr z, getC
  27++86E2                 ;ld b,a
  28++86E2                 ;xor a : ld (BASIC_KEY), a
  29++86E2                 ;ld a, b
  30++86E2 C9              ret
  31++86E3
  32++86E3              peekC:
  33++86E3              	OS_GET_CHAR
  33++86E3 0E 10       >    ld c,#10
  33++86E5 E7          >    rst #20
  34++86E6                  ;xor a: ld (BASIC_KEY),a
  35++86E6                  ;call inkey
  36++86E6 C9               ret
  37++86E7
  38++86E7              ; inkey:
  39++86E7                 ; ld de,0
  40++86E7                 ; ld bc,$fefe
  41++86E7                 ; in a,(c)
  42++86E7                 ; or $e1
  43++86E7                 ; cp $ff
  44++86E7                 ; jr nz, .keyhitA
  45++86E7
  46++86E7                 ; ld e,5
  47++86E7                 ; ld b,$fd
  48++86E7                 ; in a,(c)
  49++86E7                 ; or $e0
  50++86E7                 ; cp $ff
  51++86E7                 ; jr nz, .keyhitA
  52++86E7
  53++86E7                 ; ld e,10
  54++86E7                 ; ld b,$fb
  55++86E7                 ; in a,(c)
  56++86E7                 ; or $e0
  57++86E7                 ; cp $ff
  58++86E7                 ; jr nz, .keyhitA
  59++86E7
  60++86E7                 ; ld e,15
  61++86E7                 ; ld b,$f7
  62++86E7                 ; in a,(c)
  63++86E7                 ; or $e0
  64++86E7                 ; cp $ff
  65++86E7                 ; jr nz, .keyhitA
  66++86E7
  67++86E7                 ; ld e,20
  68++86E7                 ; ld b,$ef
  69++86E7                 ; in a,(c)
  70++86E7                 ; or $e0
  71++86E7                 ; cp $ff
  72++86E7                 ; jr nz, .keyhitA
  73++86E7
  74++86E7                 ; ld e,25
  75++86E7                 ; ld b,$df
  76++86E7                 ; in a,(c)
  77++86E7                 ; or $e0
  78++86E7                 ; cp $ff
  79++86E7                 ; jr nz, .keyhitA
  80++86E7
  81++86E7                 ; ld e,30
  82++86E7                 ; ld b,$bf
  83++86E7                 ; in a,(c)
  84++86E7                 ; or $e0
  85++86E7                 ; cp $ff
  86++86E7                 ; jr nz, .keyhitA
  87++86E7
  88++86E7                 ; ld e,35
  89++86E7                 ; ld b,$7f
  90++86E7                 ; in a,(c)
  91++86E7                 ; or $e2
  92++86E7                 ; cp $ff
  93++86E7                 ; ld c,a
  94++86E7                 ; jr nz, .keyhitB
  95++86E7
  96++86E7              ; .nokey
  97++86E7                 ; xor a
  98++86E7                 ; ret
  99++86E7
 100++86E7              ; .keyhitA
 101++86E7
 102++86E7                 ; ld c,a
 103++86E7
 104++86E7                 ; ld a,b
 105++86E7                 ; cpl
 106++86E7                 ; or $81
 107++86E7                 ; in a,($fe)
 108++86E7                 ; or $e0
 109++86E7                 ; cp $ff
 110++86E7                 ; jr nz, .nokey
 111++86E7
 112++86E7                 ; ld a,$7f
 113++86E7                 ; in a,($fe)
 114++86E7                 ; or $e2
 115++86E7                 ; cp $ff
 116++86E7                 ; jr nz, .nokey
 117++86E7
 118++86E7              ; .keyhitB
 119++86E7
 120++86E7                 ; ld b,0
 121++86E7                 ; ld hl,.rowtbl-$e0
 122++86E7                 ; add hl,bc
 123++86E7                 ; ld a,(hl)
 124++86E7                 ; cp 5
 125++86E7                 ; jr nc, .nokey
 126++86E7                 ; add a,e
 127++86E7                 ; ld e,a
 128++86E7
 129++86E7                 ; ld hl,.table
 130++86E7                 ; add hl,de
 131++86E7
 132++86E7                 ; ld a,$fe
 133++86E7                 ; in a,($fe)
 134++86E7                 ; and $01
 135++86E7                 ; jr nz, .nocaps
 136++86E7                 ; ld e,40
 137++86E7                 ; add hl,de
 138++86E7
 139++86E7              ; .nocaps
 140++86E7
 141++86E7                 ; ld a,$7f
 142++86E7                 ; in a,($fe)
 143++86E7                 ; and $02
 144++86E7                 ; jr nz, .nosym
 145++86E7                 ; ld e,80
 146++86E7                 ; add hl,de
 147++86E7
 148++86E7              ; .nosym
 149++86E7
 150++86E7                 ; ld a,(hl)
 151++86E7                 ; ret
 152++86E7
 153++86E7              ; .rowtbl
 154++86E7                 ; defb 255,255,255,255,255,255,255
 155++86E7                 ; defb 255,255,255,255,255,255,255,255
 156++86E7                 ; defb 4,255,255,255,255,255,255
 157++86E7                 ; defb 255,3,255,255,255,2,255,1
 158++86E7                 ; defb 0,255
 159++86E7
 160++86E7              ; .table
 161++86E7                 ; db 0,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
 162++86E7                 ; db 'a','s','d','f','g'      ; A, S, D, F, G
 163++86E7                 ; db 'q','w','e','r','t'      ; Q, W, E, R, T
 164++86E7                 ; db '1','2','3','4','5'      ; 1, 2, 3, 4, 5
 165++86E7                 ; db '0','9','8','7','6'      ; 0, 9, 8, 7, 6
 166++86E7                 ; db 'p','o','i','u','y'      ; P, O, I, U, Y
 167++86E7                 ; db 13,'l','k','j','h'       ; ENTER, L, K, J, H
 168++86E7                 ; db ' ',0,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B
 169++86E7
 170++86E7                 ; ; the following are CAPS SHIFTed
 171++86E7
 172++86E7                 ; db 0,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
 173++86E7                 ; db 'A','S','D','F','G'      ; A, S, D, F, G
 174++86E7                 ; db 'Q','W','E','R','T'      ; Q, W, E, R, T
 175++86E7                 ; db 7,6,128,129,8            ; 1, 2, 3, 4, 5
 176++86E7                 ; db 12,0,9,11,10             ; 0, 9, 8, 7, 6
 177++86E7                 ; db 'P','O','I','U','Y'      ; P, O, I, U, Y
 178++86E7                 ; db 13,'L','K','J','H'       ; ENTER, L, K, J, H
 179++86E7                 ; db ' ',0,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B
 180++86E7
 181++86E7                 ; ; the following are SYM SHIFTed
 182++86E7
 183++86E7                 ; db 0,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
 184++86E7                 ; db '~','|',92,'{','}'       ; A, S, D, F, G
 185++86E7                 ; db 131,132,133,'<','>'      ; Q, W, E, R, T
 186++86E7                 ; db '!','@','#','$','%'      ; 1, 2, 3, 4, 5
 187++86E7                 ; db '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
 188++86E7                 ; db 34,';',130,']','['       ; P, O, I, U, Y
 189++86E7                 ; db 13,'=','+','-','^'       ; ENTER, L, K, J, H
 190++86E7                 ; db ' ',0,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B
 191++86E7
 192++86E7                 ; ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)
 193++86E7
 194++86E7                 ; db 0,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
 195++86E7                 ; db 1,19,4,6,7               ; A, S, D, F, G
 196++86E7                 ; db 17,23,5,18,20            ; Q, W, E, R, T
 197++86E7                 ; db 27,28,29,30,31           ; 1, 2, 3, 4, 5
 198++86E7                 ; db 127,0,134,'`',135      ; 0, 9, 8, 7, 6
 199++86E7                 ; db 16,15,9,21,25            ; P, O, I, U, Y
 200++86E7                 ; db 13,12,11,10,8            ; ENTER, L, K, J, H
 201++86E7                 ; db ' ',0,13,14,2          ; SPACE, SYM SHIFT, M, N, B
 202++86E7
 203++86E7                  endmodule
# file closed: dos/console.asm
# file closed: dos/index.asm
  19  86E7                  include "gopher/engine/history/index.asm"
# file opened: gopher/engine/history/index.asm
   1+ 86E7                  include "controler.asm"
# file opened: gopher/engine/history/controler.asm
   1++86E7                  module History
   2++86E7              back:
   3++86E7 3A 20 88         ld a, (depth)
   3++86EA FE 01          cp 1
   3++86EC CA FE 86       jp z, load
   4++86EF 21 69 8B 11      ld hl, historyBlock + HistoryRecord, de, historyBlock, bc, (total - 1) * HistoryRecord
   4++86F3 21 88 01 20
   4++86F7 0D
   4++86F8 ED B0          ldir ; Move history up
   5++86FA 21 20 88         ld hl, depth
   5++86FD 35             dec (hl)
   6++86FE              ; Loads current resource
   7++86FE              load:
   8++86FE 21 1B 87         ld hl, .msg
   8++8701 CD 30 86       call DialogBox.msgNoWait
   9++8704 AF               xor a
   9++8705 21 8B A3 11    ld hl, outputBuffer, de, outputBuffer + 1
   9++8709 8C A3
  10++870B 01 73 5C         ld bc, #ffff - outputBuffer - 1
  11++870E 77               ld (hl), a
  12++870F ED B0            ldir
  13++8711
  14++8711 3A 21 88         ld a, (historyBlock.isFile)
  14++8714 A7             and a
  14++8715 C2 E9 9D       jp nz, Fetcher.fetchFromFS
  15++8718 C3 99 9D         jp Fetcher.fetchFromNet
  16++871B
  17++871B 4C 6F 61 64  .msg db "Loading resource! Please wait! It will be here soon!", 0
  17++871F 69 6E 67 20
  17++8723 72 65 73 6F
  17++8727 75 72 63 65
  17++872B 21 20 50 6C
  17++872F 65 61 73 65
  17++8733 20 77 61 69
  17++8737 74 21 20 49
  17++873B 74 20 77 69
  17++873F 6C 6C 20 62
  17++8743 65 20 68 65
  17++8747 72 65 20 73
  17++874B 6F 6F 6E 21
  17++874F 00
  18++8750
  19++8750              home:
  20++8750 21 01 88         ld hl, homePage
  21++8753              ; HL - gopher row
  22++8753              navigate:
  23++8753 54 5D            ld de, hl
  24++8755 CD 12 9C         call UrlEncoder.isValidGopherRow
  25++8758 30 A4            jr nc, load ; Not valid - reload last
  26++875A 62 6B            ld hl, de
  27++875C E5               push hl
  28++875D
  29++875D E5               push hl
  30++875E 21 88 98 11      ld hl, HistoryEnd - HistoryRecord, de, HistoryEnd, bc,  HistoryRecord * total
  30++8762 D0 9B 01 68
  30++8766 10
  30++8767 ED B8          lddr
  31++8769
  32++8769 ED 5B 67 8B      ld de, (Render.position), (historyBlock.position + HistoryRecord), de
  32++876D ED 53 AF 8E
  33++8771                  ; Clean up struct
  34++8771 AF               xor a
  34++8772 21 21 88 11    ld hl, historyBlock, de, historyBlock + 1, bc, historyBlockSize - 1, (hl), a
  34++8776 22 88 01 47
  34++877A 03 77
  34++877C ED B0          ldir
  35++877E E1               pop hl
  36++877F
  37++877F                  ; Fill record
  38++877F 54 5D            ld de, hl
  39++8781 CD D1 9B         call UrlEncoder.isFile
  40++8784 EB               ex hl, de
  41++8785 11 21 88         ld de, historyBlock
  42++8788 12               ld (de), a
  42++8789 13             inc de
  43++878A 7E               ld a, (hl)
  43++878B E5 D5          push hl, de
  43++878D CD 06 81       call Render.getIcon
  43++8790 D1 E1          pop de, hl
  44++8792 12               ld (de), a
  44++8793 13             inc de
  45++8794 3E 09 01 FF      ld a, 9, bc, #fff
  45++8798 0F
  45++8799 ED B1          cpir
  46++879B              .locatorCopy
  47++879B 7E               ld a, (hl)
  47++879C FE 09          cp 9
  47++879E 28 05          jr z, 1f
  48++87A0 12               ld (de), a
  48++87A1 23 13          inc hl, de
  49++87A3 18 F6            jr .locatorCopy
  50++87A5              1
  51++87A5 23               inc hl
  51++87A6 AF             xor a
  51++87A7 12             ld (de), a
  52++87A8 11 22 8A         ld de, historyBlock.host
  53++87AB              .hostCopy
  54++87AB 7E               ld a, (hl)
  54++87AC FE 09          cp 9
  54++87AE 28 05          jr z, 1f
  55++87B0 12               ld (de), a
  55++87B1 23 13          inc hl, de
  56++87B3 18 F6            jr .hostCopy
  57++87B5              1
  58++87B5 23               inc hl
  58++87B6 AF             xor a
  58++87B7 12             ld (de), a
  59++87B8 11 62 8A         ld de, historyBlock.port
  60++87BB              .portCopy
  61++87BB 7E               ld a, (hl)
  62++87BC FE 09            cp 9
  62++87BE 28 11          jr z, 1f
  63++87C0 FE 0D            cp 13
  63++87C2 28 0D          jr z, 1f
  64++87C4 FE 0A            cp 10
  64++87C6 28 09          jr z, 1f
  65++87C8 FE 00            cp 0
  65++87CA 28 05          jr z, 1f
  66++87CC 12               ld (de), a
  66++87CD 23 13          inc hl, de
  67++87CF 18 EA            jr .portCopy
  68++87D1 AF           1   xor a
  68++87D2 12             ld (de), a
  69++87D3 21 D7 85 11      ld hl, DialogBox.inputBuffer, de, historyBlock.search, bc, #ff
  69++87D7 68 8A 01 FF
  69++87DB 00
  69++87DC ED B0          ldir
  70++87DE 11 00 00 ED      ld de, 0, (historyBlock.position), de
  70++87E2 53 67 8B
  71++87E5 E1               pop hl
  72++87E6 3A 20 88         ld a, (depth)
  72++87E9 FE 05          cp total
  72++87EB 30 04          jr nc, 1f
  73++87ED 3C               inc a
  73++87EE 32 20 88       ld (depth), a
  74++87F1              1
  75++87F1 3A 22 88         ld a,(historyBlock.mediaType)
  75++87F4 FE 01          cp MIME_DOWNLOAD
  75++87F6 CA E6 9E       jp z, Gopher.download
  76++87F9
  77++87F9                  ifdef GS
  78++87F9 FE 07            cp MIME_MOD
  78++87FB CA 88 9E       jp z, Gopher.loadMod
  79++87FE                  endif
  80++87FE
  81++87FE C3 FE 86         jp load
  82++8801
  83++8801              homePage:
  84++8801 31 48 6F 6D      db "1Home", TAB, "data/index.gph"
  84++8805 65 09 64 61
  84++8809 74 61 2F 69
  84++880D 6E 64 65 78
  84++8811 2E 67 70 68
  85++8815 09 66 69 6C      db TAB, "file", TAB, "70", CR, LF, 0
  85++8819 65 09 37 30
  85++881D 0D 0A 00
  86++8820                  endmodule
# file closed: gopher/engine/history/controler.asm
   2+ 8820                  include "model.asm"
# file opened: gopher/engine/history/model.asm
   1++8820              total   equ 5
   2++8820 00           depth   db 0
   3++8821
   4++8821              historyBlock:
   5++8821 00           .isFile    db  0
   6++8822 00           .mediaType db  0
   7++8823 00 00 00...  .locator   ds  #1ff
   8++8A22 00 00 00...  .host      ds  64
   9++8A62 00 00 00...  .port      ds  6
  10++8A68 00 00 00...  .search    ds  #ff
  11++8B67 00 00        .position  dw  #00
  12++8B69
  13++8B69              historyBlockSize = $ - historyBlock
  14++8B69
  15++8B69              HistoryRecord EQU $ - historyBlock
  16++8B69                  dup total
  17++8B69 00 00 00... >    ds HistoryRecord
  17++8EB1 00 00 00... >    ds HistoryRecord
  17++91F9 00 00 00... >    ds HistoryRecord
  17++9541 00 00 00... >    ds HistoryRecord
  17++9889 00 00 00... >    ds HistoryRecord
  18++988D                  edup
  19++9BD1              HistoryEnd equ $ - 1
# file closed: gopher/engine/history/model.asm
# file closed: gopher/engine/history/index.asm
  20  9BD1                  include "gopher/engine/urlencoder.asm"
# file opened: gopher/engine/urlencoder.asm
   1+ 9BD1                  MODULE UrlEncoder
   2+ 9BD1              ; HL - pointer to line in gopher page
   3+ 9BD1              ; C - flag set when it's file
   4+ 9BD1              isFile:
   5+ 9BD1              .findServerLoop
   6+ 9BD1 7E               ld a, (hl)
   6+ 9BD2 A7             and a
   6+ 9BD3 28 3B          jr z, .notFile
   6+ 9BD5 23             inc hl
   7+ 9BD6 FE 0D            cp 13
   7+ 9BD8 28 36          jr z, .notFile
   8+ 9BDA FE 09            cp 9
   8+ 9BDC 28 02          jr z, .skipPath
   9+ 9BDE 18 F1            jr .findServerLoop
  10+ 9BE0              .skipPath
  11+ 9BE0 7E               ld a, (hl)
  11+ 9BE1 A7             and a
  11+ 9BE2 28 2C          jr z, .notFile
  11+ 9BE4 23             inc hl
  12+ 9BE5 FE 0D            cp 13
  12+ 9BE7 28 27          jr z, .notFile
  13+ 9BE9 FE 09            cp 9
  13+ 9BEB 28 02          jr z, .compareServer
  14+ 9BED 18 F1            jr .skipPath
  15+ 9BEF              .compareServer
  16+ 9BEF 7E               ld a, (hl)
  16+ 9BF0 FE 66          cp "f"
  16+ 9BF2 20 1C          jr nz, .notFile
  16+ 9BF4 23             inc hl
  17+ 9BF5 7E               ld a, (hl)
  17+ 9BF6 FE 69          cp "i"
  17+ 9BF8 20 16          jr nz, .notFile
  17+ 9BFA 23             inc hl
  18+ 9BFB 7E               ld a, (hl)
  18+ 9BFC FE 6C          cp "l"
  18+ 9BFE 20 10          jr nz, .notFile
  18+ 9C00 23             inc hl
  19+ 9C01 7E               ld a, (hl)
  19+ 9C02 FE 65          cp "e"
  19+ 9C04 20 0A          jr nz, .notFile
  19+ 9C06 23             inc hl
  20+ 9C07 7E               ld a, (hl)
  20+ 9C08 FE 09          cp 9
  20+ 9C0A 20 04          jr nz, .notFile
  20+ 9C0C 23             inc hl
  21+ 9C0D 3E 01            ld a, 1
  22+ 9C0F C9               ret
  23+ 9C10              .notFile
  24+ 9C10 AF               xor a
  25+ 9C11 C9               ret
  26+ 9C12
  27+ 9C12              ; Is enough fields to encode
  28+ 9C12              ; HL - pointer to line in gopher page
  29+ 9C12              ; C - flag set when there is enough fields
  30+ 9C12              isValidGopherRow:
  31+ 9C12 7E               ld a, (hl)
  31+ 9C13 A7             and a
  31+ 9C14 28 FA          jr z, isFile.notFile
  31+ 9C16 23             inc hl
  32+ 9C17 FE 0D            cp 13
  32+ 9C19 28 F5          jr z, isFile.notFile
  33+ 9C1B FE 09            cp 9
  33+ 9C1D 28 02          jr z, .skipPath
  34+ 9C1F 18 F1            jr isValidGopherRow
  35+ 9C21              .skipPath
  36+ 9C21 7E               ld a, (hl)
  36+ 9C22 A7             and a
  36+ 9C23 28 EB          jr z, isFile.notFile
  36+ 9C25 23             inc hl
  37+ 9C26 FE 0D            cp 13
  37+ 9C28 28 E6          jr z, isFile.notFile
  38+ 9C2A FE 09            cp 9
  38+ 9C2C 28 02          jr z, .skipHost
  39+ 9C2E 18 F1            jr .skipPath
  40+ 9C30              .skipHost
  41+ 9C30 7E               ld a, (hl)
  41+ 9C31 A7             and a
  41+ 9C32 28 DC          jr z, isFile.notFile
  41+ 9C34 23             inc hl
  42+ 9C35 FE 0D            cp 13
  42+ 9C37 28 D7          jr z, isFile.notFile
  43+ 9C39 FE 09            cp 9
  43+ 9C3B 28 02           jr z, .isValid
  44+ 9C3D 18 F1            jr .skipHost
  45+ 9C3F              .isValid:
  46+ 9C3F 37               scf
  47+ 9C40 C9               ret
  48+ 9C41
  49+ 9C41              extractPath:
  50+ 9C41 21 23 88 11      ld hl, historyBlock.locator, de, nameBuffer, bc, #ff
  50+ 9C45 59 9C 01 FF
  50+ 9C49 00
  50+ 9C4A ED B0          ldir
  51+ 9C4C C9               ret
  52+ 9C4D
  53+ 9C4D              extractHostName:
  54+ 9C4D 21 22 8A 11      ld hl, historyBlock.host, de, hostName, bc, 64
  54+ 9C51 59 9D 01 40
  54+ 9C55 00
  54+ 9C56 ED B0          ldir
  55+ 9C58 C9               ret
  56+ 9C59
  57+ 9C59                  ENDMODULE
  58+ 9C59
  59+ 9C59 00 00 00...  nameBuffer ds #ff, 0
  60+ 9D58
  61+ 9D58 00                    db 0
  62+ 9D59 00 00 00...  hostName ds 64
# file closed: gopher/engine/urlencoder.asm
  21  9D99                  include "gopher/engine/fetcher.asm"
# file opened: gopher/engine/fetcher.asm
   1+ 9D99                  MODULE Fetcher
   2+ 9D99
   3+ 9D99              fetchFromNet:
   4+ 9D99 CD 60 9E         call Gopher.makeRequest
   4+ 9D9C 38 06          jr c, .error
   5+ 9D9E CD 78 9E         call Gopher.loadBuffer
   6+ 9DA1 C3 F5 9D         jp MediaProcessor.processResource
   7+ 9DA4              .error
   8+ 9DA4              	OS_ESP_CLOSE ;закрыть соединение, если было
   8+ 9DA4 0E 0C       >    ld c,#0c
   8+ 9DA6 E7          >    rst #20
   9+ 9DA7 21 B0 9D         ld hl, .err
   9+ 9DAA CD 27 86       call DialogBox.msgBox
  10+ 9DAD C3 E7 86         jp History.back
  11+ 9DB0
  12+ 9DB0 44 6F 63 75  .err db "Document fetch error! Check your connection or hostname!", 0
  12+ 9DB4 6D 65 6E 74
  12+ 9DB8 20 66 65 74
  12+ 9DBC 63 68 20 65
  12+ 9DC0 72 72 6F 72
  12+ 9DC4 21 20 43 68
  12+ 9DC8 65 63 6B 20
  12+ 9DCC 79 6F 75 72
  12+ 9DD0 20 63 6F 6E
  12+ 9DD4 6E 65 63 74
  12+ 9DD8 69 6F 6E 20
  12+ 9DDC 6F 72 20 68
  12+ 9DE0 6F 73 74 6E
  12+ 9DE4 61 6D 65 21
  12+ 9DE8 00
  13+ 9DE9
  14+ 9DE9
  15+ 9DE9              fetchFromFS:
  16+ 9DE9 CD 41 9C         call UrlEncoder.extractPath
  17+ 9DEC              loadFile
  18+ 9DEC 21 59 9C         ld hl, nameBuffer
  19+ 9DEF CD 5E 86         call Dos.loadBuffer
  20+ 9DF2 C3 F5 9D         jp MediaProcessor.processResource
  21+ 9DF5                  ENDMODULE
# file closed: gopher/engine/fetcher.asm
  22  9DF5                  include "gopher/engine/media-processor.asm"
# file opened: gopher/engine/media-processor.asm
   1+ 9DF5                  MODULE MediaProcessor
   2+ 9DF5              processResource:
   3+ 9DF5 CD 4D 9C         call UrlEncoder.extractHostName
   4+ 9DF8 3A 22 88         ld a, (historyBlock.mediaType)
   5+ 9DFB FE 05            cp MIME_MUSIC
   5+ 9DFD 28 17          jr z, processPT
   6+ 9DFF FE 02            cp MIME_LINK
   6+ 9E01 28 1F          jr z, processPage
   7+ 9E03 FE 04            cp MIME_INPUT
   7+ 9E05 28 1B          jr z, processPage
   8+ 9E07 FE 06            cp MIME_IMAGE
   8+ 9E09 CA 4C A2       jp z, ScreenViewer.display
   9+ 9E0C              	ifdef GS
  10+ 9E0C FE 07            cp MIME_MOD
  10+ 9E0E 28 0C          jr z, processMOD
  11+ 9E10              	endif
  12+ 9E10              ; Fallback to plain text
  13+ 9E10              processText:
  14+ 9E10 CD E1 84         call Render.renderPlainTextScreen
  15+ 9E13 C3 1D 85         jp   Render.plainTextLoop
  16+ 9E16
  17+ 9E16              processPT:
  18+ 9E16 CD B7 A1         call VortexProcessor.play
  19+ 9E19 C3 E7 86         jp History.back
  20+ 9E1C
  21+ 9E1C                  ifdef GS
  22+ 9E1C              processMOD:
  23+ 9E1C CD 0B A2         call ModProcessor.play
  24+ 9E1F C3 E7 86         jp History.back
  25+ 9E22              	endif
  26+ 9E22
  27+ 9E22              processPage:
  28+ 9E22 3A 81 85         ld a, (Render.play_next)
  28+ 9E25 A7             and a
  28+ 9E26 20 06          jr nz, .playNext
  29+ 9E28 CD 85 83         call Render.renderGopherScreen
  30+ 9E2B C3 CC 83         jp   Render.workLoop
  31+ 9E2E              .playNext
  32+ 9E2E 21 68 8B         ld hl, Render.cursor_position
  33+ 9E31 34               inc (hl)
  34+ 9E32 C3 B6 83         jp Render.checkBorder
  35+ 9E35
  36+ 9E35
  37+ 9E35                  ENDMODULE
# file closed: gopher/engine/media-processor.asm
  23  9E35                  include "gopher/gopher.asm"
# file opened: gopher/gopher.asm
   1+ 9E35                  module Gopher
   2+ 9E35              extractRequest:
   3+ 9E35 21 23 88         ld hl, historyBlock.locator
   4+ 9E38 11 B8 9F         ld de, requestbuffer
   5+ 9E3B              .loop
   6+ 9E3B 7E               ld a, (hl)
   7+ 9E3C 12               ld (de), a
   8+ 9E3D 23               inc hl
   9+ 9E3E 13               inc de
  10+ 9E3F FE 00            cp 0
  11+ 9E41 28 02            jr z, .search
  12+ 9E43 18 F6            jr .loop
  13+ 9E45              .search
  14+ 9E45 1B               dec de
  15+ 9E46 3A 22 88         ld a, (historyBlock.mediaType)
  16+ 9E49 FE 04            cp MIME_INPUT
  17+ 9E4B 20 10            jr nz, .exit
  18+ 9E4D 21 68 8A         ld hl, historyBlock.search
  19+ 9E50 3E 09            ld a, TAB
  20+ 9E52 12               ld (de), a
  21+ 9E53 13               inc de
  22+ 9E54              .searchCopy
  23+ 9E54 7E               ld a, (hl)
  24+ 9E55 A7               and a
  24+ 9E56 28 05          jr z, .exit
  25+ 9E58 12               ld (de), a
  26+ 9E59 23               inc hl
  26+ 9E5A 13             inc de
  27+ 9E5B 18 F7            jr .searchCopy
  28+ 9E5D              .exit
  29+ 9E5D AF               xor a
  30+ 9E5E 12               ld (de), a
  31+ 9E5F C9               ret
  32+ 9E60
  33+ 9E60
  34+ 9E60              makeRequest:
  35+ 9E60 CD 35 9E         call extractRequest
  36+ 9E63
  37+ 9E63 21 22 8A         ld hl, historyBlock.host
  38+ 9E66 11 62 8A         ld de, historyBlock.port
  39+ 9E69 CD 8B A2         call Wifi.openTCP
  40+ 9E6C D8               ret c
  41+ 9E6D
  42+ 9E6D 21 B8 9F         ld hl, requestbuffer
  43+ 9E70 CD B5 A2         call Wifi.tcpSendZ
  44+ 9E73 AF               xor a
  44+ 9E74 32 8A A2       ld (Wifi.closed), a
  45+ 9E77 C9               ret
  46+ 9E78
  47+ 9E78
  48+ 9E78              loadBuffer:
  49+ 9E78 21 8B A3         ld hl, outputBuffer
  50+ 9E7B 22 88 A2         ld (Wifi.buffer_pointer), hl
  51+ 9E7E              .loop
  52+ 9E7E CD D3 A2         call Wifi.getPacket
  53+ 9E81 3A 8A A2         ld a, (Wifi.closed)
  53+ 9E84 A7             and a
  53+ 9E85 C0             ret nz
  54+ 9E86                  ;call Wifi.continue
  55+ 9E86 18 F6            jr .loop
  56+ 9E88
  57+ 9E88                  ifdef GS
  58+ 9E88              loadMod:
  59+ 9E88 AF               xor a
  59+ 9E89 CD 28 A3       call GeneralSound.init
  60+ 9E8C 21 C6 9E         ld hl, .progress
  60+ 9E8F CD 30 86       call DialogBox.msgNoWait
  61+ 9E92 CD 60 9E         call makeRequest
  61+ 9E95 DA A4 9D       jp c, Fetcher.fetchFromNet.error
  62+ 9E98 CD 35 A3         call GeneralSound.loadModule
  63+ 9E9B              .loop
  64+ 9E9B 21 8B A3 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
  64+ 9E9F 88 A2
  65+ 9EA1 CD D3 A2         call Wifi.getPacket
  66+ 9EA4 3A 8A A2         ld a, (Wifi.closed)
  66+ 9EA7 A7             and a
  66+ 9EA8 20 16          jr nz, .exit
  67+ 9EAA 21 8B A3 ED      ld hl, outputBuffer, bc, (Wifi.bytes_avail)
  67+ 9EAE 4B 86 A2
  68+ 9EB1              .loadLoop
  69+ 9EB1 78               ld a, b
  69+ 9EB2 B1             or c
  69+ 9EB3 A7             and a
  69+ 9EB4 28 08          jr z, .nextFrame
  70+ 9EB6 7E               ld a, (hl)
  70+ 9EB7 CD 48 A3       call GeneralSound.sendByte
  71+ 9EBA 0B               dec bc
  72+ 9EBB 23               inc hl
  73+ 9EBC 18 F3            jr .loadLoop
  74+ 9EBE              .nextFrame
  75+ 9EBE                  ;call Wifi.continue
  76+ 9EBE 18 DB            jr .loop
  77+ 9EC0              .exit
  78+ 9EC0 CD 50 A3         call GeneralSound.finishLoadingModule
  79+ 9EC3                  ;jp History.back
  80+ 9EC3 C3 F5 9D     	jp MediaProcessor.processResource
  81+ 9EC6 4D 4F 44 20  .progress db "MOD downloading directly to GS!", 0
  81+ 9ECA 64 6F 77 6E
  81+ 9ECE 6C 6F 61 64
  81+ 9ED2 69 6E 67 20
  81+ 9ED6 64 69 72 65
  81+ 9EDA 63 74 6C 79
  81+ 9EDE 20 74 6F 20
  81+ 9EE2 47 53 21 00
  82+ 9EE6                  endif
  83+ 9EE6
  84+ 9EE6
  85+ 9EE6              download:
  86+ 9EE6
  87+ 9EE6 11 23 88         ld de, historyBlock.locator
  88+ 9EE9 62 6B            ld hl, de
  89+ 9EEB              .findFileName
  90+ 9EEB 1A               ld a, (de)
  90+ 9EEC 13             inc de
  91+ 9EED FE 2F            cp '/'
  91+ 9EEF 20 02          jr nz, .skip
  92+ 9EF1 62 6B            ld hl, de
  93+ 9EF3              .skip
  94+ 9EF3 A7               and a
  94+ 9EF4 20 F5          jr nz, .findFileName
  95+ 9EF6              .copy
  96+ 9EF6                  ;; HL - filename pointer
  97+ 9EF6 11 D7 85         ld de, DialogBox.inputBuffer
  98+ 9EF9              .copyFileName
  99+ 9EF9 7E               ld a, (hl)
  99+ 9EFA A7             and a
  99+ 9EFB 28 05          jr z, .finishCopy
 100+ 9EFD
 101+ 9EFD 12               ld (de), a
 101+ 9EFE 23 13          inc hl, de
 102+ 9F00 18 F7            jr .copyFileName
 103+ 9F02              .finishCopy
 104+ 9F02 12               ld (de), a
 105+ 9F03 CD 86 85         call DialogBox.inputBox.noclear
 106+ 9F06 3A D7 85         ld a, (DialogBox.inputBuffer)
 106+ 9F09 A7             and a
 106+ 9F0A CA E7 86       jp z, History.back
 107+ 9F0D
 108+ 9F0D CD 60 9E         call makeRequest
 108+ 9F10 DA A4 9D       jp c, Fetcher.fetchFromNet.error
 109+ 9F13
 110+ 9F13 06 0E 21 D7      ld b, Dos.FMODE_CREATE, hl, DialogBox.inputBuffer
 110+ 9F17 85
 111+ 9F18 CD 7A 86         call Dos.fopen
 112+ 9F1B 32 B6 9F         ld (.fp), a
 113+ 9F1E
 114+ 9F1E 21 91 9F         ld hl, .progress
 114+ 9F21 CD 30 86       call DialogBox.msgNoWait
 115+ 9F24              .loop
 116+ 9F24 21 8B A3 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
 116+ 9F28 88 A2
 117+ 9F2A CD D3 A2         call Wifi.getPacket
 118+ 9F2D 3A 8A A2         ld a, (Wifi.closed)
 118+ 9F30 A7             and a
 118+ 9F31 20 0F          jr nz, .exit
 119+ 9F33
 120+ 9F33 3A B6 9F 21      ld a, (.fp), hl, outputBuffer, bc, (Wifi.bytes_avail)
 120+ 9F37 8B A3 ED 4B
 120+ 9F3B 86 A2
 121+ 9F3D CD B1 86         call Dos.fwrite
 122+ 9F40
 123+ 9F40                  ;call Wifi.continue
 124+ 9F40 18 E2            jr .loop
 125+ 9F42              .exit
 126+ 9F42 3A B6 9F         ld a, (.fp)
 127+ 9F45 CD A7 86         call Dos.fclose
 128+ 9F48 C3 E7 86         jp History.back
 129+ 9F4B              ;.error
 130+ 9F4B 3A B6 9F         ld a, (.fp)
 131+ 9F4E CD A7 86         call Dos.fclose
 132+ 9F51
 133+ 9F51 21 5A 9F         ld hl, .err
 134+ 9F54 CD 27 86         call DialogBox.msgBox
 135+ 9F57 C3 E7 86         jp History.back
 136+ 9F5A 4F 70 65 72  .err db "Operation failed! Sorry! Check filename or disk space!",0
 136+ 9F5E 61 74 69 6F
 136+ 9F62 6E 20 66 61
 136+ 9F66 69 6C 65 64
 136+ 9F6A 21 20 53 6F
 136+ 9F6E 72 72 79 21
 136+ 9F72 20 43 68 65
 136+ 9F76 63 6B 20 66
 136+ 9F7A 69 6C 65 6E
 136+ 9F7E 61 6D 65 20
 136+ 9F82 6F 72 20 64
 136+ 9F86 69 73 6B 20
 136+ 9F8A 73 70 61 63
 136+ 9F8E 65 21 00
 137+ 9F91 44 6F 77 6E  .progress db "Downloading in progress! Wait a bit!", 0
 137+ 9F95 6C 6F 61 64
 137+ 9F99 69 6E 67 20
 137+ 9F9D 69 6E 20 70
 137+ 9FA1 72 6F 67 72
 137+ 9FA5 65 73 73 21
 137+ 9FA9 20 57 61 69
 137+ 9FAD 74 20 61 20
 137+ 9FB1 62 69 74 21
 137+ 9FB5 00
 138+ 9FB6 00           .fp db 0
 139+ 9FB7
 140+ 9FB7 00           socket db 0
 141+ 9FB8
 142+ 9FB8 00 00 00...  requestbuffer ds #1ff
 143+ A1B7                  endmodule
 144+ A1B7
# file closed: gopher/gopher.asm
  24  A1B7                  include "player/vortex-processor.asm"
# file opened: player/vortex-processor.asm
   1+ A1B7                  MODULE VortexProcessor
   2+ A1B7              play:
   3+ A1B7 CD D1 86         call Console.waitForKeyUp
   4+ A1BA
   5+ A1BA 21 F6 A1         ld hl, message
   5+ A1BD CD 30 86       call DialogBox.msgNoWait
   6+ A1C0
   7+ A1C0 21 8B A3         ld hl, outputBuffer
   7+ A1C3                OS_VTPL_INIT
   7+ A1C3 0E 15       >    ld c,#15
   7+ A1C5 E7          >    rst #20
   8+ A1C6
   9+ A1C6
  10+ A1C6 3E 01 32 81      ld a, 1, (Render.play_next), a
  10+ A1CA 85
  11+ A1CB                  ifdef GS
  12+ A1CB CD 6C A3         call GeneralSound.stopModule
  13+ A1CE                  endif
  14+ A1CE              	OS_VTPL_PLAY
  14+ A1CE 0E 16       >    ld c,#16
  14+ A1D0 E7          >    rst #20
  15+ A1D1              .loop
  16+ A1D1                  OS_WAIT
  16+ A1D1 DF          >	rst #18
  16+ A1D2               ; di : call VTPL.PLAY : ei
  17+ A1D2              	OS_GET_CHAR
  17+ A1D2 0E 10       >    ld c,#10
  17+ A1D4 E7          >    rst #20
  18+ A1D5 FE 20        	cp " " ;останов по пробелу
  19+ A1D7 CA F0 A1     	jp z, .stopKey
  20+ A1DA CD 7B A2     	call printRTC
  21+ A1DD              	OS_GET_VTPL_SETUP
  21+ A1DD 0E 18       >    ld c,#18
  21+ A1DF E7          >    rst #20
  22+ A1E0 7E               ld a, (hl)
  22+ A1E1
  23+ A1E1 17           	rla
  23+ A1E2 30 ED          jr nc, .loop
  24+ A1E4 3E 01 32 81      ld a, 1, (Render.play_next), a
  24+ A1E8 85
  25+ A1E9              .stop
  26+ A1E9              	OS_VTPL_MUTE
  26+ A1E9 0E 17       >    ld c,#17
  26+ A1EB E7          >    rst #20
  27+ A1EC
  28+ A1EC                  IFDEF AY
  29+ A1EC ~                call restoreAyState
  30+ A1EC                  ENDIF
  31+ A1EC
  32+ A1EC CD D1 86         call Console.waitForKeyUp
  33+ A1EF C9               ret
  34+ A1F0              .stopKey
  35+ A1F0 AF               xor a
  35+ A1F1 32 81 85       ld (Render.play_next), a
  36+ A1F4 18 F3            jr .stop
  37+ A1F6
  38+ A1F6                  IFDEF AY
  39+ A1F6 ~            restoreAyState:
  40+ A1F6 ~                ld a, #07
  41+ A1F6 ~                ld bc, #fffd
  42+ A1F6 ~                out (c), a
  43+ A1F6 ~                ld a, #fc
  44+ A1F6 ~                ld b, #bf
  45+ A1F6 ~                out (c), a ; Enable read mode
  46+ A1F6 ~
  47+ A1F6 ~                ld a, #0e
  48+ A1F6 ~                ld bc, #fffd
  49+ A1F6 ~                out (c), a
  50+ A1F6 ~                ret
  51+ A1F6                  ENDIF
  52+ A1F6
  53+ A1F6 50 72 65 73  message db "Press key to stop...", 0
  53+ A1FA 73 20 6B 65
  53+ A1FE 79 20 74 6F
  53+ A202 20 73 74 6F
  53+ A206 70 2E 2E 2E
  53+ A20A 00
  54+ A20B                  ENDMODULE
  55+ A20B                  ;include "player.asm"
  56+ A20B
# file closed: player/vortex-processor.asm
  25  A20B                  include "player/mod-processor.asm"
# file opened: player/mod-processor.asm
   1+ A20B                  MODULE ModProcessor
   2+ A20B                  ifdef GS
   3+ A20B
   4+ A20B                  macro _WaitCommand2
   5+ A20B ~            .wait
   6+ A20B ~                in a, (CMD)
   7+ A20B ~                rrca
   8+ A20B ~                jr c, .wait
   9+ A20B                  endm
  10+ A20B
  11+ A20B                  macro _SendCommand2 nn
  12+ A20B ~                ld a, nn
  12+ A20B ~              out (CMD), a
  13+ A20B                  endm
  14+ A20B
  15+ A20B              play:
  16+ A20B CD D1 86         call Console.waitForKeyUp
  17+ A20E
  18+ A20E 21 B8 9F         ld hl, Gopher.requestbuffer
  18+ A211 CD 30 86       call DialogBox.msgNoWait
  19+ A214
  20+ A214                  ;ld a, 1, (Render.play_next), a
  21+ A214 AF           	xor a
  22+ A215 32 4B A2     	ld (last_song_position),a
  23+ A218
  24+ A218              .loop
  25+ A218                  OS_WAIT
  25+ A218 DF          >	rst #18
  25+ A219
  26+ A219                  OS_GET_CHAR
  26+ A219 0E 10       >    ld c,#10
  26+ A21B E7          >    rst #20
  27+ A21C FE 20        	cp " " ;пробел
  28+ A21E CA 45 A2     	jp z, .stopKey
  29+ A221 CD 7B A2     	call printRTC
  30+ A224                  ;проверка что MOD начал играть сначала
  31+ A224                  _SendCommand2 CMD_GET_SONG_POSITION
  31+ A224 3E 60       >    ld a, CMD_GET_SONG_POSITION
  31+ A226 D3 BB       >  out (CMD), a
  32+ A228                  _WaitCommand2
  32+ A228             >.wait
  32+ A228 DB BB       >    in a, (CMD)
  32+ A22A 0F          >    rrca
  32+ A22B 38 FB       >    jr c, .wait
  33+ A22D 3A 4B A2     	ld a,(last_song_position) ;предыдущая позиция
  34+ A230 4F           	ld c,a
  35+ A231 DB B3        	in a,(DATA) ;текущая позиция
  36+ A233 32 4B A2     	ld (last_song_position),a
  37+ A236 B9           	cp c
  38+ A237 30 DF        	jr nc, .loop ;если не меньше, продолжаем играть
  39+ A239 3E 01 32 81      ld a, 1, (Render.play_next), a ;флаг что надо будет играть следующий файл
  39+ A23D 85
  40+ A23E              .stop
  41+ A23E CD 6C A3         call GeneralSound.stopModule
  42+ A241
  43+ A241 CD D1 86         call Console.waitForKeyUp
  44+ A244 C9               ret
  45+ A245              .stopKey
  46+ A245 AF               xor a
  46+ A246 32 81 85       ld (Render.play_next), a ;флаг что не надо играть следующий файл
  47+ A249 18 F3            jr .stop
  48+ A24B
  49+ A24B
  50+ A24B              ;message db "Press key to stop...", 0
  51+ A24B
  52+ A24B
  53+ A24B              CMD_GET_SONG_POSITION     = #60
  54+ A24B 00           last_song_position db 0
  55+ A24C
  56+ A24C              ;; Control ports
  57+ A24C              CMD  = 187
  58+ A24C              DATA = 179
  59+ A24C
  60+ A24C                  endif
  61+ A24C                  ENDMODULE
  62+ A24C
  63+ A24C
# file closed: player/mod-processor.asm
  26  A24C                  include "screen/screen.asm"
# file opened: screen/screen.asm
   1+ A24C                  module ScreenViewer
   2+ A24C              display:
   3+ A24C CD D1 86         call Console.waitForKeyUp
   4+ A24F
   5+ A24F              display_wait1
   6+ A24F 3E 07        	ld a,7
   7+ A251              	OS_SET_SCREEN ;включить экран
   7+ A251 0E 1D       >    ld c,#1d
   7+ A253 E7          >    rst #20
   8+ A254 30 03        	jr nc,display_wait1_ok
   9+ A256              	OS_WAIT
   9+ A256 DF          >	rst #18
  10+ A257 18 F6        	jr display_wait1 ;пока не получилось, может не в фокусе приложение
  11+ A259
  12+ A259              display_wait1_ok
  13+ A259
  14+ A259              	OS_GET_MAIN_PAGES
  14+ A259 0E 1E       >    ld c,#1e
  14+ A25B E7          >    rst #20
  15+ A25C 78           	ld a,b ; страница с буфером
  16+ A25D 06 07        	ld b,7 ;страница назначения
  17+ A25F 21 8B A3     	ld hl,outputBuffer
  18+ A262 11 00 C0     	ld de,#c000
  19+ A265 DD 21 00 1B  	ld ix,6912
  20+ A269              	OS_RAM_COPY
  20+ A269 0E 19       >    ld c,#19
  20+ A26B E7          >    rst #20
  21+ A26C                  ;call TextMode.disable
  22+ A26C              .wait
  23+ A26C              	OS_WAIT
  23+ A26C DF          >	rst #18
  24+ A26D              	OS_GET_CHAR
  24+ A26D 0E 10       >    ld c,#10
  24+ A26F E7          >    rst #20
  25+ A270 FE FF        	cp 255
  26+ A272 28 F8        	jr z, .wait
  27+ A274 AF           	xor a ;текстовый экран
  28+ A275              	OS_SET_SCREEN
  28+ A275 0E 1D       >    ld c,#1d
  28+ A277 E7          >    rst #20
  29+ A278                  ;call TextMode.cls
  30+ A278 C3 E7 86         jp History.back
  31+ A27B
  32+ A27B                  endmodule
  33+ A27B
# file closed: screen/screen.asm
  27  A27B                  include "screen/rtc.asm"
# file opened: screen/rtc.asm
   1+ A27B              printRTC
   2+ A27B              	ifndef SMUCRTC
   3+ A27B C9           	ret
   4+ A27C              	endif
   5+ A27C              	ifdef SMUCRTC
   6+ A27C ~            	;печать текущего времени
   7+ A27C ~            	call Clock.readTime
   8+ A27C ~            	jr nc,read_time_ok
   9+ A27C ~            	; ld hl,mes_no_RTC
  10+ A27C ~            	; call print_mes
  11+ A27C ~            	; scf
  12+ A27C ~            	ret ;выход
  13+ A27C ~            read_time_ok
  14+ A27C ~            	push bc
  15+ A27C ~            	ld l,e ;часы
  16+ A27C ~            	ld h,0
  17+ A27C ~            	call toDecimal
  18+ A27C ~            	ld de,00 ;координаты
  19+ A27C ~            	call TextMode.gotoXY
  20+ A27C ~            	ld hl,decimalS+3
  21+ A27C ~            	call TextMode.printZ
  22+ A27C ~            	ld a,":"
  23+ A27C ~            	call TextMode.putC
  24+ A27C ~            	pop bc
  25+ A27C ~            	ld l,b ;минуты
  26+ A27C ~            	ld h,0
  27+ A27C ~            	call toDecimal
  28+ A27C ~            	ld hl,decimalS+3
  29+ A27C ~            	call TextMode.printZ
  30+ A27C ~            	; ld a,":"
  31+ A27C ~            	; call TextMode.putC
  32+ A27C ~            	; ld l,c ;секунды
  33+ A27C ~            	; ld h,0
  34+ A27C ~            	; call toDecimal
  35+ A27C ~            	; ld hl,decimalS+3
  36+ A27C ~            	; call TextMode.printZ
  37+ A27C ~            	; or a ;нет ошибки
  38+ A27C ~            	ret
  39+ A27C ~
  40+ A27C ~
  41+ A27C ~            toDecimal		;конвертирует 2 байта в 5 десятичных цифр
  42+ A27C ~            				;на входе в HL число
  43+ A27C ~            			ld de,10000 ;десятки тысяч
  44+ A27C ~            			ld a,255
  45+ A27C ~            toDecimal10k
  46+ A27C ~            			and a
  47+ A27C ~            			sbc hl,de
  48+ A27C ~            			inc a
  49+ A27C ~            			jr nc,toDecimal10k
  50+ A27C ~            			add hl,de
  51+ A27C ~            			add a,48
  52+ A27C ~            			ld (decimalS),a
  53+ A27C ~            			ld de,1000 ;тысячи
  54+ A27C ~            			ld a,255
  55+ A27C ~            toDecimal1k
  56+ A27C ~            			and a
  57+ A27C ~            			sbc hl,de
  58+ A27C ~            			inc a
  59+ A27C ~            			jr nc,toDecimal1k
  60+ A27C ~            			add hl,de
  61+ A27C ~            			add a,48
  62+ A27C ~            			ld (decimalS+1),a
  63+ A27C ~            			ld de,100 ;сотни
  64+ A27C ~            			ld a,255
  65+ A27C ~            toDecimal01k
  66+ A27C ~            			and a
  67+ A27C ~            			sbc hl,de
  68+ A27C ~            			inc a
  69+ A27C ~            			jr nc,toDecimal01k
  70+ A27C ~            			add hl,de
  71+ A27C ~            			add a,48
  72+ A27C ~            			ld (decimalS+2),a
  73+ A27C ~            			ld de,10 ;десятки
  74+ A27C ~            			ld a,255
  75+ A27C ~            toDecimal001k
  76+ A27C ~            			and a
  77+ A27C ~            			sbc hl,de
  78+ A27C ~            			inc a
  79+ A27C ~            			jr nc,toDecimal001k
  80+ A27C ~            			add hl,de
  81+ A27C ~            			add a,48
  82+ A27C ~            			ld (decimalS+3),a
  83+ A27C ~            			ld de,1 ;единицы
  84+ A27C ~            			ld a,255
  85+ A27C ~            toDecimal0001k
  86+ A27C ~            			and a
  87+ A27C ~            			sbc hl,de
  88+ A27C ~            			inc a
  89+ A27C ~            			jr nc,toDecimal0001k
  90+ A27C ~            			add hl,de
  91+ A27C ~            			add a,48
  92+ A27C ~            			ld (decimalS+4),a
  93+ A27C ~
  94+ A27C ~            			ret
  95+ A27C ~
  96+ A27C ~            decimalS	ds 6 ;десятичные цифры
  97+ A27C ~
  98+ A27C              	endif
# file closed: screen/rtc.asm
  28  A27C                  include "drivers/index.asm"
# file opened: drivers/index.asm
   1+ A27C                  IFDEF UNO
   2+ A27C ~                include "uno-uart.asm"
   3+ A27C                  ENDIF
   4+ A27C
   5+ A27C                  IFDEF MB03
   6+ A27C ~                include "mb03-uart.asm"
   7+ A27C                  ENDIF
   8+ A27C
   9+ A27C                  IFDEF AY
  10+ A27C ~                include "ay-uart.asm"
  11+ A27C                  ENDIF
  12+ A27C
  13+ A27C                  IFDEF ZW
  14+ A27C                  include "zx-wifi.asm"
# file opened: drivers/zx-wifi.asm
   1++A27C              ; ; This driver works with 16c550 uart that's support AFE
   2++A27C                  ; module Uart
   3++A27C              ; ; Make init shorter and readable:-)
   4++A27C                  ; macro outp port, value
   5++A27C              	; ld b, port
   6++A27C              	; ld c, #EF
   7++A27C                  ; ld a, value
   8++A27C                  ; out (c), a
   9++A27C                  ; endm
  10++A27C
  11++A27C              ; ; Internal port constants
  12++A27C              ; RBR_THR = #F8
  13++A27C              ; IER     = RBR_THR + 1
  14++A27C              ; IIR_FCR = RBR_THR + 2
  15++A27C              ; LCR     = RBR_THR + 3
  16++A27C              ; MCR     = RBR_THR + 4
  17++A27C              ; LSR     = RBR_THR + 5
  18++A27C              ; MSR     = RBR_THR + 6
  19++A27C              ; SR      = RBR_THR + 7
  20++A27C
  21++A27C              ; init:
  22++A27C                  ; outp MCR,     #0d  // Assert RTS
  23++A27C                  ; outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  24++A27C                  ; outp LCR,     #83  // 8n1, DLAB=1
  25++A27C                  ; outp RBR_THR, #01  // 115200 (divider 1)
  26++A27C                  ; outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  27++A27C
  28++A27C                  ; outp LCR,     #03 // 8n1, DLAB=0
  29++A27C                  ; outp IER,     #00 // Disable int
  30++A27C                  ; outp MCR,     #2f // Enable AFE
  31++A27C                  ; ret
  32++A27C
  33++A27C              ; ;retry_rec_count_max equ %00011111 ;ждать столько прерываний
  34++A27C
  35++A27C              ; ; Flag C <- Data available
  36++A27C              ; ; isAvailable:
  37++A27C                  ; ; ld a, LSR
  38++A27C                  ; ; in a, (#EF)
  39++A27C                  ; ; rrca
  40++A27C                  ; ; ret
  41++A27C
  42++A27C              ; ; Non-blocking read
  43++A27C              ; ; Flag C <- is byte was readen
  44++A27C              ; ; A <- byte
  45++A27C              ; ; read1:
  46++A27C                  ; ; ld a, LSR
  47++A27C                  ; ; in a, (#EF)
  48++A27C                  ; ; rrca
  49++A27C                  ; ; ret nc
  50++A27C                  ; ; ld a, RBR_THR
  51++A27C                  ; ; in a, (#EF)
  52++A27C                  ; ; scf
  53++A27C                  ; ; ret
  54++A27C
  55++A27C              ; ; Tries read byte with timeout
  56++A27C              ; ; Flag C <- is byte read
  57++A27C              ; ; A <- byte
  58++A27C              ; read:
  59++A27C              	; ;xor a ;4
  60++A27C              	; ;ld (#5C78),a ;обнулить счётчик ожидания ;13
  61++A27C              ; .wait
  62++A27C                  ; ld a, LSR
  63++A27C                  ; in a, (#EF)
  64++A27C                  ; rrca
  65++A27C              	; jr nc, .wait
  66++A27C                  ; ld a, RBR_THR
  67++A27C                  ; in a, (#EF)
  68++A27C              	; ret
  69++A27C              ; ; .readW
  70++A27C              	; ; OS_GETTIMER
  71++A27C              	; ; ld a,e
  72++A27C              	; ; and retry_rec_count_max
  73++A27C              	; ; ;ld a,(#5C78)
  74++A27C              	; ; ;cp retry_rec_count_max
  75++A27C              	; ; jr nz, .wait ;ещё попытка
  76++A27C              	; ; xor a ;выключим флаг переноса если время вышло
  77++A27C              	; ; ret
  78++A27C
  79++A27C
  80++A27C
  81++A27C
  82++A27C              ; ; Blocking read
  83++A27C              ; ; A <- Byte
  84++A27C              ; ; readB:
  85++A27C                  ; ; ld a, LSR
  86++A27C                  ; ; in a, (#EF)
  87++A27C                  ; ; rrca
  88++A27C                  ; ; jr nc, readB
  89++A27C              	; ; ld a, RBR_THR
  90++A27C                  ; ; in a, (#EF)
  91++A27C                  ; ; ret
  92++A27C
  93++A27C              ; ; A -> byte to send
  94++A27C              ; write:
  95++A27C                  ; push af
  96++A27C              ; .wait
  97++A27C              	; ld a, LSR
  98++A27C                  ; in a, (#EF)
  99++A27C                  ; and #20
 100++A27C                  ; jr z, .wait
 101++A27C                  ; pop af
 102++A27C              	; ld b, RBR_THR
 103++A27C              	; ld c, #EF
 104++A27C                  ; out (c), a
 105++A27C                  ; ret
 106++A27C
 107++A27C                  ; endmodule
# file closed: drivers/zx-wifi.asm
  15+ A27C                  ENDIF
  16+ A27C
  17+ A27C                  IFDEF SMUCRTC
  18+ A27C ~                include "smuc-rtc.asm"
  19+ A27C                  ENDIF
  20+ A27C
  21+ A27C                  include "utils.asm"
# file opened: drivers/utils.asm
   1++A27C              ; ;;; Macroses!!!!
   2++A27C                  ; MACRO EspSend Text
   3++A27C                  ; ld hl, .txtB
   4++A27C                  ; ld e, (.txtE - .txtB)
   5++A27C                  ; call espSend
   6++A27C                  ; jr .txtE
   7++A27C              ; .txtB
   8++A27C                  ; db Text
   9++A27C              ; .txtE
  10++A27C                  ; ENDM
  11++A27C
  12++A27C                  ; MACRO EspCmd Text
  13++A27C                  ; ld hl, .txtB
  14++A27C                  ; ld e, (.txtE - .txtB)
  15++A27C                  ; call espSend
  16++A27C                  ; jr .txtE
  17++A27C              ; .txtB
  18++A27C                  ; db Text
  19++A27C                  ; db 13, 10
  20++A27C              ; .txtE
  21++A27C                  ; ENDM
  22++A27C
  23++A27C                  ; MACRO EspCmdOkErr text
  24++A27C                  ; EspCmd text
  25++A27C                  ; call checkOkErr
  26++A27C                  ; ENDM
  27++A27C
  28++A27C              ; IN DE - string pointer
  29++A27C              ; OUT HL - string len
  30++A27C              strLen:
  31++A27C 21 00 00         ld hl, 0
  32++A27F              .loop
  33++A27F 1A               ld a, (de)
  33++A280 A7             and a
  33++A281 C8             ret z
  34++A282 13 23            inc de, hl
  35++A284 18 F9            jr .loop
# file closed: drivers/utils.asm
  22+ A286                  include "wifi.asm"
# file opened: drivers/wifi.asm
   1++A286                  MODULE Wifi
   2++A286 00 00        bytes_avail dw 0
   3++A288 00 00        buffer_pointer dw 0
   4++A28A 01           closed db 1
   5++A28B              ;link_id db 0;
   6++A28B              wait_count equ 5*50 ; ожидание в кадрах
   7++A28B              buffer_top equ #fa;ограничение буфера сверху #ffff - 1500
   8++A28B              ; ; Initialize Wifi chip to work
   9++A28B              ;init:
  10++A28B              	;ld hl,uartGetID : call TextMode.printZ
  11++A28B              ; init1:
  12++A28B              	; halt
  13++A28B              	; xor a ;CY=0
  14++A28B              	; OS_ESP_LINK_ID ;получить номер соединения
  15++A28B              	; jr c,init1:
  16++A28B              	; ld (link_id),a
  17++A28B              	;ret
  18++A28B                  ; ; ld hl, .uartIniting : call TextMode.printZ
  19++A28B                  ; ; call Uart.init
  20++A28B                  ; ld hl, .chipIniting : call TextMode.printZ
  21++A28B                  ; EspCmdOkErr "ATE0"
  22++A28B                  ; jr c, .initError
  23++A28B
  24++A28B                  ; EspCmdOkErr "AT+CIPSERVER=0"
  25++A28B                  ; EspCmdOkErr "AT+CIPCLOSE" ; Close if there some connection was. Don't care about result
  26++A28B                  ; EspCmdOkErr "AT+CIPMUX=0" ; Single connection mode
  27++A28B                  ; jr c, .initError
  28++A28B
  29++A28B                  ; EspCmdOkErr "AT+CIPDINFO=0" ; Disable additional info
  30++A28B                  ; jr c, .initError
  31++A28B
  32++A28B                  ; ld hl, .doneInit : call TextMode.printZ
  33++A28B
  34++A28B                  ; or a
  35++A28B                  ; ret
  36++A28B              ; .initError
  37++A28B                  ; ld hl, .errMsg : call DialogBox.msgBox
  38++A28B                  ; scf
  39++A28B                  ; ret
  40++A28B              ; .errMsg db "WiFi chip init failed!",0
  41++A28B              ;.uartIniting db "Uart initing...",13,0
  42++A28B              ;uartGetID db "Get link ID...",13,0
  43++A28B              ; .chipIniting db "Chip initing...",13,0
  44++A28B              ; .doneInit    db "Done!",0
  45++A28B                  ; IFNDEF PROXY
  46++A28B              ; ; HL - host pointer in gopher row
  47++A28B              ; ; DE - port pointer in gopher row
  48++A28B              openTCP:
  49++A28B              	;ld a,(link_id)
  50++A28B              	OS_ESP_CLOSE ;если уже пытались раньше, то закрыть
  50++A28B 0E 0C       >    ld c,#0c
  50++A28D E7          >    rst #20
  51++A28E
  52++A28E 06 FA        	ld b,wait_count ; пробуем открыть
  53++A290              openTCP_wait1
  54++A290              	OS_WAIT
  54++A290 DF          >	rst #18
  55++A291 C5           	push bc
  56++A292 AF           	xor a ;TCP
  57++A293              	OS_ESP_OPEN
  57++A293 0E 0D       >    ld c,#0d
  57++A295 E7          >    rst #20
  58++A296 C1           	pop bc
  59++A297 30 03        	jr nc,openTCP_wait1_ok
  60++A299 10 F5        	djnz openTCP_wait1
  61++A29B C9           	ret ;не удалось, наверное очередь
  62++A29C              openTCP_wait1_ok
  63++A29C
  64++A29C              	;или подождём открытия
  65++A29C 06 FA        	ld b,wait_count ;
  66++A29E              openTCP_wait
  67++A29E              	OS_WAIT
  67++A29E DF          >	rst #18
  68++A29F DD 7E 02     	ld a,(ix+2) ;флаг
  69++A2A2 07           	rlca
  70++A2A3 D8           	ret c ;если ошибка (=255)
  71++A2A4 B7           	or a
  72++A2A5 20 04        	jr nz,openTCP_wait_skip
  73++A2A7 10 F5        	djnz openTCP_wait
  74++A2A9 37           	scf
  75++A2AA C9           	ret
  76++A2AB              openTCP_wait_skip
  77++A2AB DD 7E 02     	ld a,(ix+2) ;флаг
  78++A2AE EE 01        	xor 1
  79++A2B0 32 8A A2     	ld (closed), a
  80++A2B3 B7           	or a ;успешно
  81++A2B4 C9           	ret
  82++A2B5
  83++A2B5
  84++A2B5
  85++A2B5                  ; push de
  86++A2B5                  ; push hl
  87++A2B5                  ; EspCmdOkErr "AT+CIPCLOSE" ; Don't care about result. Just close if it didn't happens before
  88++A2B5                  ; EspSend 'AT+CIPSTART="TCP","'
  89++A2B5                  ; pop hl
  90++A2B5                  ; call espSendT
  91++A2B5                  ; EspSend '",'
  92++A2B5                  ; pop hl
  93++A2B5                  ; call espSendT
  94++A2B5                  ; ld a, 13 : call Uart.write
  95++A2B5                  ; ld a, 10 : call Uart.write
  96++A2B5                  ; xor a : ld (closed), a
  97++A2B5                  ; jp checkOkErr
  98++A2B5
  99++A2B5              ; continue:
 100++A2B5                  ; ret
 101++A2B5                  ; ENDIF
 102++A2B5
 103++A2B5
 104++A2B5
 105++A2B5              ; checkOkErr:
 106++A2B5                  ; call Uart.read
 107++A2B5                  ; cp 'O' : jr z, .okStart ; OK
 108++A2B5                  ; cp 'E' : jr z, .errStart ; ERROR
 109++A2B5                  ; cp 'F' : jr z, .failStart ; FAIL
 110++A2B5                  ; jr checkOkErr
 111++A2B5              ; .okStart
 112++A2B5                  ; call Uart.read : cp 'K' : jr nz, checkOkErr
 113++A2B5                  ; call Uart.read : cp 13  : jr nz, checkOkErr
 114++A2B5                  ; call .flushToLF
 115++A2B5                  ; or a
 116++A2B5                  ; ret
 117++A2B5              ; .errStart
 118++A2B5                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 119++A2B5                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 120++A2B5                  ; call Uart.read : cp 'O' : jr nz, checkOkErr
 121++A2B5                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 122++A2B5                  ; call .flushToLF
 123++A2B5                  ; scf
 124++A2B5                  ; ret
 125++A2B5              ; .failStart
 126++A2B5                  ; call Uart.read : cp 'A' : jr nz, checkOkErr
 127++A2B5                  ; call Uart.read : cp 'I' : jr nz, checkOkErr
 128++A2B5                  ; call Uart.read : cp 'L' : jr nz, checkOkErr
 129++A2B5                  ; call .flushToLF
 130++A2B5                  ; scf
 131++A2B5                  ; ret
 132++A2B5              ; .flushToLF
 133++A2B5                  ; call Uart.read
 134++A2B5                  ; cp 10 : jr nz, .flushToLF
 135++A2B5                  ; ret
 136++A2B5
 137++A2B5              ; ; Send buffer to UART
 138++A2B5              ; ; HL - buff
 139++A2B5              ; ; E - count
 140++A2B5              ; espSend:
 141++A2B5                  ; ld a, (hl) : call Uart.write
 142++A2B5                  ; inc hl
 143++A2B5                  ; dec e
 144++A2B5                  ; jr nz, espSend
 145++A2B5                  ; ret
 146++A2B5
 147++A2B5              ; ; HL - string that ends with one of the terminator(CR/LF/TAB/NULL)
 148++A2B5              ; espSendT:
 149++A2B5                  ; ld a, (hl)
 150++A2B5
 151++A2B5                  ; and a : ret z
 152++A2B5                  ; cp 9 : ret z
 153++A2B5                  ; cp 13 : ret z
 154++A2B5                  ; cp 10 : ret z
 155++A2B5
 156++A2B5                  ; call Uart.write
 157++A2B5                  ; inc hl
 158++A2B5                  ; jr espSendT
 159++A2B5
 160++A2B5              ; ; HL - stringZ to send
 161++A2B5              ; ; Adds CR LF
 162++A2B5              tcpSendZ:
 163++A2B5 E5           	push hl
 164++A2B6 EB           	ex de,hl
 165++A2B7 CD 7C A2     	call strLen ;узнать длину
 166++A2BA EB           	ex de,hl
 167++A2BB E1           	pop hl ;буфер
 168++A2BC E5           	push hl
 169++A2BD 19           	add hl,de ;добавить в конце 13 и 10
 170++A2BE 36 0D        	ld (hl),13
 171++A2C0 23           	inc hl
 172++A2C1 36 0A        	ld (hl),10
 173++A2C3 E1           	pop hl
 174++A2C4 13           	inc de ;увеличить длину
 175++A2C5 13           	inc de
 176++A2C6
 177++A2C6              	;call Wifi.tcpSendZ ;послать запрос
 178++A2C6              	;ld a,(link_id)
 179++A2C6              	OS_ESP_SEND
 179++A2C6 0E 0E       >    ld c,#0e
 179++A2C8 E7          >    rst #20
 180++A2C9              	;ret c ;сразу не удалось (может, очередь)
 181++A2C9              	;ждём когда запрос пройдёт
 182++A2C9              	;ld b,wait_count ;
 183++A2C9              tcpSendZ_wait1 ;бесконечно ждём
 184++A2C9              	OS_WAIT
 184++A2C9 DF          >	rst #18
 185++A2CA DD 7E 04     	ld a,(ix+4) ;флаг
 186++A2CD FE 01        	cp 1
 187++A2CF 20 F8        	jr nz,tcpSendZ_wait1
 188++A2D1 B7           	or a
 189++A2D2 C9           	ret
 190++A2D3
 191++A2D3
 192++A2D3                  ; push hl
 193++A2D3                  ; EspSend "AT+CIPSEND="
 194++A2D3                  ; pop de : push de
 195++A2D3                  ; call strLen
 196++A2D3                  ; inc hl : inc hl ; +CRLF
 197++A2D3                  ; call hlToNumEsp
 198++A2D3                  ; ld a, 13 : call Uart.write
 199++A2D3                  ; ld a, 10 : call Uart.write
 200++A2D3                  ; call checkOkErr : ret c
 201++A2D3              ; .wait
 202++A2D3                  ; call Uart.read : cp '>' : jr nz, .wait
 203++A2D3                  ; pop hl
 204++A2D3              ; .loop
 205++A2D3                  ; ld a, (hl) : and a : jr z, .exit
 206++A2D3                  ; call Uart.write
 207++A2D3                  ; inc hl
 208++A2D3                  ; jp .loop
 209++A2D3              ; .exit
 210++A2D3                  ; ld a, 13 : call Uart.write
 211++A2D3                  ; ld a, 10 : call Uart.write
 212++A2D3                  ; jp checkOkErr
 213++A2D3
 214++A2D3              ;вх: hl - адрес буфера
 215++A2D3              getPacket:
 216++A2D3              	;переделано под ОС
 217++A2D3 7C           	ld a,h
 218++A2D4 FE FA        	cp buffer_top ;ограничение буфера
 219++A2D6 38 10        	jr c,getPacket_skip_over ; ниже ограничения грузим
 220++A2D8 3E 01        	ld a,1 ;или прекращаем
 221++A2DA 32 8A A2     	ld (closed),a ;флаг закрытия
 222++A2DD 21 00 00     	ld hl,0
 223++A2E0 22 86 A2     	ld (bytes_avail), hl
 224++A2E3              	OS_ESP_CLOSE ;освободить очередь
 224++A2E3 0E 0C       >    ld c,#0c
 224++A2E5 E7          >    rst #20
 225++A2E6 37           	scf
 226++A2E7 C9           	ret
 227++A2E8              getPacket_skip_over
 228++A2E8
 229++A2E8              	;ld a,(link_id)
 230++A2E8              	OS_ESP_GET
 230++A2E8 0E 0F       >    ld c,#0f
 230++A2EA E7          >    rst #20
 231++A2EB              	; ret c ;сразу не удалось (может, очередь)
 232++A2EB              	; ld b,wait_count ;
 233++A2EB              getPacket_wait1
 234++A2EB              	OS_WAIT
 234++A2EB DF          >	rst #18
 235++A2EC DD 7E 06     	ld a,(ix+6) ;флаг результат приёма
 236++A2EF              	; rlca
 237++A2EF              	; ret c ;если ошибка (=255)
 238++A2EF FE 01        	cp 1
 239++A2F1 20 F8        	jr nz,getPacket_wait1
 240++A2F3
 241++A2F3
 242++A2F3              ;getPacket_wait1_skip
 243++A2F3 2A 88 A2     	ld hl,(buffer_pointer)
 244++A2F6 DD 4E 09     	ld c,(ix+9) ; длина принятого
 245++A2F9 DD 46 0A     	ld b,(ix+10)
 246++A2FC ED 43 86 A2  	ld (bytes_avail), bc
 247++A300 09           	add hl,bc
 248++A301 22 88 A2     	ld (buffer_pointer),hl ;продолжить загружать с этого места
 249++A304
 250++A304 DD 7E 02     	ld a,(ix+2) ;!!! closed
 251++A307 EE 01        	xor 1
 252++A309 32 8A A2     	ld (closed),a ;флаг закрытия
 253++A30C 28 03        	jr z,getPacket_ex
 254++A30E              	OS_ESP_CLOSE ;освободить очередь
 254++A30E 0E 0C       >    ld c,#0c
 254++A310 E7          >    rst #20
 255++A311              getPacket_ex
 256++A311 B7           	or a
 257++A312 C9           	ret
 258++A313
 259++A313
 260++A313                  ; call Uart.read
 261++A313                  ; cp '+' : jr z, .ipdBegun    ; "+IPD," packet
 262++A313                  ; cp 'O' : jr z, .closedBegun ; It enough to check "OSED\n" :-)
 263++A313                  ; jr getPacket
 264++A313              ; .closedBegun
 265++A313                  ; call Uart.read : cp 'S' : jr nz, getPacket
 266++A313                  ; call Uart.read : cp 'E' : jr nz, getPacket
 267++A313                  ; call Uart.read : cp 'D' : jr nz, getPacket
 268++A313                  ; call Uart.read : cp 13 : jr nz, getPacket
 269++A313                  ; ld a, 1, (closed), a
 270++A313                  ; ret
 271++A313              ; .ipdBegun
 272++A313                  ; call Uart.read : cp 'I' : jr nz, getPacket
 273++A313                  ; call Uart.read : cp 'P' : jr nz, getPacket
 274++A313                  ; call Uart.read : cp 'D' : jr nz, getPacket
 275++A313                  ; call Uart.read ; Comma
 276++A313                  ; call .count_ipd_lenght : ld (bytes_avail), hl
 277++A313                  ; ld bc, hl
 278++A313                  ; ld hl, (buffer_pointer)
 279++A313              ; .readp
 280++A313                  ; ld a, h : cp #ff : jr nc, .skipbuff
 281++A313                  ; push bc, hl
 282++A313                  ; call Uart.read
 283++A313                  ; pop hl, bc
 284++A313                  ; ld (hl), a
 285++A313                  ; dec bc : inc hl
 286++A313                  ; ld a, b : or c : jr nz, .readp
 287++A313                  ; ld (buffer_pointer), hl
 288++A313                  ; ret
 289++A313              ; .skipbuff
 290++A313                  ; push bc
 291++A313                  ; call Uart.read
 292++A313                  ; pop bc
 293++A313                  ; dec bc : ld a, b : or c : jr nz, .skipbuff
 294++A313                  ; ret
 295++A313              ; .count_ipd_lenght
 296++A313              		; ld hl,0			; count lenght
 297++A313              ; .cil1	push  hl
 298++A313                      ; call Uart.read
 299++A313                      ; pop hl
 300++A313              		; cp ':' : ret z
 301++A313              		; sub 0x30 : ld c,l : ld b,h : add hl,hl : add hl,hl : add hl,bc : add hl,hl : ld c,a : ld b,0 : add hl,bc
 302++A313              		; jr .cil1
 303++A313
 304++A313              ; ; Based on: https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
 305++A313              ; ; HL - number
 306++A313              ; ; It will be written to UART
 307++A313              ; hlToNumEsp:
 308++A313              	; ld	bc,-10000
 309++A313              	; call	.n1
 310++A313              	; ld	bc,-1000
 311++A313              	; call	.n1
 312++A313              	; ld	bc,-100
 313++A313              	; call	.n1
 314++A313              	; ld	c,-10
 315++A313              	; call	.n1
 316++A313              	; ld	c,-1
 317++A313              ; .n1	ld	a,'0'-1
 318++A313              ; .n2	inc	a
 319++A313              	; add	hl,bc
 320++A313              	; jr	c, .n2
 321++A313              	; sbc	hl,bc
 322++A313                  ; push bc
 323++A313              	; call Uart.write
 324++A313                  ; pop bc
 325++A313                  ; ret
 326++A313
 327++A313                  ENDMODULE
# file closed: drivers/wifi.asm
  23+ A313                  include "proxy.asm"
# file opened: drivers/proxy.asm
   1++A313                  IFDEF PROXY
   2++A313 ~                MODULE Wifi
   3++A313 ~            ; Same singature as wifi.openTCP
   4++A313 ~            ; HL - host pointer in gopher row
   5++A313 ~            ; DE - port pointer in gopher row
   6++A313 ~            openTCP:
   7++A313 ~                push de
   8++A313 ~                push hl
   9++A313 ~
  10++A313 ~                xor a
  10++A313 ~              ld hl, hostBuff, de, hostBuff + 1, bc, 102, (hl), a
  10++A313 ~              ldir
  11++A313 ~
  12++A313 ~                EspCmdOkErr "AT+CIPCLOSE"
  13++A313 ~                EspCmdOkErr 'AT+CIPSTART="TCP","138.68.76.243",6912' // Replace here for yourown proxy. If you wish
  14++A313 ~                jr c, .error
  15++A313 ~                pop hl
  15++A313 ~              ld de, hostBuff
  16++A313 ~            .copyHost
  17++A313 ~                ld a, (hl)
  17++A313 ~              and a
  17++A313 ~              jr z, 1F
  17++A313 ~              and a
  17++A313 ~              jr z, 1F
  18++A313 ~                ld (de), a
  18++A313 ~              inc hl, de
  19++A313 ~                jr .copyHost
  20++A313 ~            1   xor a
  20++A313 ~              ld (de), a
  21++A313 ~                pop hl
  21++A313 ~              ld de, portBuff
  22++A313 ~            .copyPort
  23++A313 ~                ld a, (hl)
  23++A313 ~              and a
  23++A313 ~              jr z, 1F
  23++A313 ~              and a
  23++A313 ~              jr z, 1F
  24++A313 ~                ld (de), a
  24++A313 ~              inc hl, de
  25++A313 ~                jr .copyPort
  26++A313 ~            1   ld hl, hostBuff
  26++A313 ~              call tcpSendZ
  27++A313 ~                ld hl, portBuff
  27++A313 ~              call tcpSendZ
  28++A313 ~                xor a
  28++A313 ~              ld (closed), a
  29++A313 ~                ret
  30++A313 ~            .error
  31++A313 ~                pop hl
  31++A313 ~              pop de
  32++A313 ~                ret
  33++A313 ~
  34++A313 ~            continue:
  35++A313 ~                EspCmdOkErr "AT+CIPSEND=1"
  36++A313 ~                ret c
  37++A313 ~            .wait
  38++A313 ~                call Uart.read
  38++A313 ~              cp '>'
  38++A313 ~              jr nz, .wait
  39++A313 ~                ld a, 'c'
  39++A313 ~              call Uart.write
  40++A313 ~                jp checkOkErr
  41++A313 ~
  42++A313 ~            hostBuff ds 96
  43++A313 ~            portBuff ds 7
  44++A313 ~                ENDMODULE
  45++A313                  ENDIF
# file closed: drivers/proxy.asm
  24+ A313                  include "memory.asm"
# file opened: drivers/memory.asm
   1++A313                  module Memory
   2++A313              BANKM = #5b5c
   3++A313              MEM_PORT = #7ffd
   4++A313
   5++A313              init:
   6++A313 F3               di
   7++A314 FD CB 01 A6      res 4, (iy + 1)
   8++A318
   9++A318 AF               xor a
   9++A319 CD 1D A3       call setPage
  10++A31C C9               ret
  11++A31D
  12++A31D              ; a - page
  13++A31D              setPage:
  14++A31D F6 18            or #18
  14++A31F 32 5C 5B       ld (BANKM), a
  15++A322 01 FD 7F         ld bc, MEM_PORT
  15++A325 ED 79          out (c), a
  16++A327 C9               ret
  17++A328
  18++A328                  endmodule
# file closed: drivers/memory.asm
  25+ A328                  include "general-sound.asm"
# file opened: drivers/general-sound.asm
   1++A328                  ifdef GS
   2++A328                  macro _WaitCommand
   3++A328 ~            .wait
   4++A328 ~                in a, (GeneralSound.CMD)
   5++A328 ~                rrca
   6++A328 ~                jr c, .wait
   7++A328                  endm
   8++A328
   9++A328                  macro _WaitData
  10++A328 ~            .wait
  11++A328 ~                in a, (GeneralSound.CMD)
  12++A328 ~                rlca
  13++A328 ~                jr c, .wait
  14++A328                  endm
  15++A328
  16++A328                  macro _SendCommand nn
  17++A328 ~                ld a, nn
  17++A328 ~              out (GeneralSound.CMD), a
  18++A328                  endm
  19++A328
  20++A328                  module GeneralSound
  21++A328              ;; Control ports
  22++A328              CMD  = 187
  23++A328              DATA = 179
  24++A328
  25++A328              ;; Commands
  26++A328              CMD_WARM_RESET      = #F3
  27++A328              CMD_COLD_RESET      = #F4
  28++A328              CMD_LOAD_MODULE     = #30
  29++A328              CMD_PLAY_MODULE     = #31
  30++A328              CMD_STOP_MODULE     = #32
  31++A328              CMD_CONTINUE_MODULE = #33
  32++A328              CMD_OPEN_STREAM     = #D1
  33++A328              CMD_CLOSE_STREAM    = #D2
  34++A328
  35++A328              ; A - 0 warm reset, other - cold
  36++A328              init:
  37++A328 A7               and a
  37++A329 20 05          jr nz, .cold
  38++A32B                  _SendCommand CMD_WARM_RESET
  38++A32B 3E F3       >    ld a, CMD_WARM_RESET
  38++A32D D3 BB       >  out (GeneralSound.CMD), a
  39++A32F C9               ret
  40++A330              .cold
  41++A330                  _SendCommand CMD_COLD_RESET
  41++A330 3E F4       >    ld a, CMD_COLD_RESET
  41++A332 D3 BB       >  out (GeneralSound.CMD), a
  42++A334 C9               ret
  43++A335
  44++A335              ;; Initializes loading module
  45++A335              loadModule:
  46++A335                  _SendCommand CMD_LOAD_MODULE
  46++A335 3E 30       >    ld a, CMD_LOAD_MODULE
  46++A337 D3 BB       >  out (GeneralSound.CMD), a
  47++A339                  _WaitCommand
  47++A339             >.wait
  47++A339 DB BB       >    in a, (GeneralSound.CMD)
  47++A33B 0F          >    rrca
  47++A33C 38 FB       >    jr c, .wait
  48++A33E                  _SendCommand CMD_OPEN_STREAM
  48++A33E 3E D1       >    ld a, CMD_OPEN_STREAM
  48++A340 D3 BB       >  out (GeneralSound.CMD), a
  49++A342                  _WaitCommand
  49++A342             >.wait
  49++A342 DB BB       >    in a, (GeneralSound.CMD)
  49++A344 0F          >    rrca
  49++A345 38 FB       >    jr c, .wait
  50++A347 C9               ret
  51++A348
  52++A348              ;; Use it for streaming mod file
  53++A348              sendByte:
  54++A348 D3 B3            out (DATA), a
  55++A34A                  _WaitData
  55++A34A             >.wait
  55++A34A DB BB       >    in a, (GeneralSound.CMD)
  55++A34C 07          >    rlca
  55++A34D 38 FB       >    jr c, .wait
  56++A34F C9               ret
  57++A350
  58++A350              ;; Call it when module was loaded
  59++A350              finishLoadingModule:
  60++A350                  _SendCommand CMD_CLOSE_STREAM
  60++A350 3E D2       >    ld a, CMD_CLOSE_STREAM
  60++A352 D3 BB       >  out (GeneralSound.CMD), a
  61++A354                  _WaitCommand
  61++A354             >.wait
  61++A354 DB BB       >    in a, (GeneralSound.CMD)
  61++A356 0F          >    rrca
  61++A357 38 FB       >    jr c, .wait
  62++A359              rewind:
  63++A359 3E 01            ld a, 1
  63++A35B D3 B3          out (DATA), a
  64++A35D                  _SendCommand CMD_PLAY_MODULE
  64++A35D 3E 31       >    ld a, CMD_PLAY_MODULE
  64++A35F D3 BB       >  out (GeneralSound.CMD), a
  65++A361                  _WaitCommand
  65++A361             >.wait
  65++A361 DB BB       >    in a, (GeneralSound.CMD)
  65++A363 0F          >    rrca
  65++A364 38 FB       >    jr c, .wait
  66++A366 3E 01 32 8A      ld a, 1, (state),a
  66++A36A A3
  67++A36B C9               ret
  68++A36C
  69++A36C              ;; Works like pause too
  70++A36C              stopModule:
  71++A36C AF               xor a
  71++A36D 32 8A A3       ld (state), a
  72++A370                  _SendCommand CMD_STOP_MODULE
  72++A370 3E 32       >    ld a, CMD_STOP_MODULE
  72++A372 D3 BB       >  out (GeneralSound.CMD), a
  73++A374 C9               ret
  74++A375
  75++A375              continueModule:
  76++A375 3E 01            ld a, 1
  76++A377 32 8A A3       ld (state), a
  77++A37A                  _SendCommand CMD_CONTINUE_MODULE
  77++A37A 3E 33       >    ld a, CMD_CONTINUE_MODULE
  77++A37C D3 BB       >  out (GeneralSound.CMD), a
  78++A37E C9               ret
  79++A37F
  80++A37F              ; Pauses resumes
  81++A37F              toggleModule:
  82++A37F CD D1 86         call Console.waitForKeyUp
  83++A382 3A 8A A3         ld a, (state)
  83++A385 A7             and a
  84++A386 28 ED            jr z, continueModule
  85++A388 18 E2            jr stopModule
  86++A38A
  87++A38A 00           state db 0
  88++A38B                  endmodule
  89++A38B
  90++A38B                  endif
# file closed: drivers/general-sound.asm
  26+ A38B
# file closed: drivers/index.asm
  29  A38B              start:
  30  A38B              	; IFDEF TRD
  31  A38B              	; align 256 ;временно
  32  A38B              	; ENDIF
  33  A38B              outputBuffer: ;equ #c000
  34  A38B                  ;di
  35  A38B                  ;xor a : ld (#5c6a), a  ; Thank you, Mario Prato, for feedback
  36  A38B                  ;ld (#5c00),a
  37  A38B                  ;ld sp, asmOrg
  38  A38B                  ;call Memory.init
  39  A38B                  ;xor a : out (#fe),a
  40  A38B                  ;ei
  41  A38B
  42  A38B                  ;ld a, 7 : call Memory.setPage
  43  A38B                  ;; Logo
  44  A38B                  ; ld hl, logo, b, Dos.FMODE_READ : call Dos.fopen
  45  A38B                  ; push af
  46  A38B                  ; ld hl, #c000, bc, 6912 : call Dos.fread
  47  A38B                  ; pop af
  48  A38B                  ; call Dos.fclose
  49  A38B
  50  A38B              	; ifdef ZSGMX
  51  A38B              	; call TextMode.disable
  52  A38B              	; endif
  53  A38B
  54  A38B                  ; ld b, 50
  55  A38B              ; 1   halt
  56  A38B                  ; djnz 1b
  57  A38B                  ;; End of logo :-)
  58  A38B
  59  A38B CD 03 80         call TextMode.init
  60  A38E
  61  A38E                  ; ld hl, initing : call TextMode.printZ
  62  A38E                  ; IFNDEF EMU
  63  A38E                  ; call Wifi.init
  64  A38E                  ; ENDIF
  65  A38E
  66  A38E C3 50 87         jp History.home
  67  A391
  68  A391              ;initing db "Initing Wifi...",13,0
  69  A391 64 61 74 61  logo    db  "data/logo.scr", 0
  69  A395 2F 6C 6F 67
  69  A399 6F 2E 73 63
  69  A39D 72 00
  70  A39F                  display "ENDS: ", $
  71  A39F                  display "Buff size", #ffff - $
  72  A39F
  73  A39F                  ;IFDEF ESX
  74  A39F                  ;save3dos "moon.bin", asmOrg, $ - asmOrg
  75  A39F                  savebin "moonr.apg", asmOrg, $ - asmOrg
  76  A39F              	;ELSE
  77  A39F                  ;SAVETRD "MOONR.TRD",|"moon.C",asmOrg, $ - asmOrg
  78  A39F                  ;ENDIF
# file closed: main.asm
