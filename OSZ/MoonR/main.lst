# file opened: main.asm
   1  0000                  device	zxspectrum128
   2  0000              	include "../os_defs.asm"
# file opened: ../os_defs.asm
   1+ 0000              ;Список всех вызовов (функций) ОС GMX
   2+ 0000
   3+ 0000              ;Включить в свой код (в начале файла):
   4+ 0000              	; include os_defs.asm
   5+ 0000
   6+ 0000              ;Использовать только имена функций, коды могут поменяться
   7+ 0000
   8+ 0000              ;например:
   9+ 0000              	; org PROG_START
  10+ 0000              	; ../include os_defs.asm
  11+ 0000              	; ld hl,text
  12+ 0000              	; OS_PRINTZ ;печать	до кода 0
  13+ 0000
  14+ 0000              ;сохранность регистров не гарантируется
  15+ 0000              ;на выходе обычно (но не всегда) CY=1 = ошибка
  16+ 0000
  17+ 0000              PROG_START equ #8000 ;адрес старта приложений
  18+ 0000
  19+ 0000
  20+ 0000              ;короткие вызовы (именные RST) -------------------------
  21+ 0000
  22+ 0000              ;печать символа в консоль (ускоренная)
  23+ 0000              	MACRO OS_PRINT_CHARF ;a=char
  24+ 0000 ~            	rst #10
  25+ 0000              	ENDM
  26+ 0000
  27+ 0000
  28+ 0000              ;передача управления ОС до следующего прерывания (когда придёт очередь процесса в следующий раз);
  29+ 0000              ;все регистры сохраняются
  30+ 0000              ;рекомендуется использовать вместо обычного halt
  31+ 0000              	MACRO OS_WAIT
  32+ 0000 ~            	rst #18
  33+ 0000              	ENDM
  34+ 0000
  35+ 0000              	; MACRO OS_
  36+ 0000              	; rst #28
  37+ 0000              	; ENDM
  38+ 0000
  39+ 0000              	; MACRO OS_
  40+ 0000              	; rst #30
  41+ 0000              	; ENDM
  42+ 0000
  43+ 0000
  44+ 0000
  45+ 0000              ;вызовы через единую точку входа RST #20 ----------------
  46+ 0000
  47+ 0000              ;вывод в консоль --------------------
  48+ 0000
  49+ 0000              ;очистить консоль
  50+ 0000              	macro OS_CLS ;clear visible area of terminal
  51+ 0000 ~                ld c,#00
  52+ 0000 ~                rst #20
  53+ 0000                  endm
  54+ 0000
  55+ 0000              ;установить позицию курсора в консоли
  56+ 0000                  macro OS_SET_XY ;de=yx ;SET CURSOR POSITION
  57+ 0000 ~                ld c,#01
  58+ 0000 ~                rst #20
  59+ 0000                  endm
  60+ 0000
  61+ 0000              ;печать символа в консоль
  62+ 0000                  macro OS_PRINT_CHAR ;a=char
  63+ 0000 ~                ld c,#02
  64+ 0000 ~                rst #20
  65+ 0000                  endm
  66+ 0000
  67+ 0000              ;заполнение строки одним символом
  68+ 0000                  macro OS_FILL_LINE ;; H - line ; A - char
  69+ 0000 ~                ld c,#03
  70+ 0000 ~                rst #20
  71+ 0000                  endm
  72+ 0000
  73+ 0000              ;покрасить строку цветом
  74+ 0000                  macro OS_PAINT_LINE ;a - line, b - color
  75+ 0000 ~                ld c,#04
  76+ 0000 ~                rst #20
  77+ 0000                  endm
  78+ 0000
  79+ 0000
  80+ 0000                  ; macro OS_ ;
  81+ 0000                  ; ld c,#05
  82+ 0000                  ; rst #20
  83+ 0000                  ; endm
  84+ 0000
  85+ 0000              ;установить цвет текста в консоли;
  86+ 0000                  macro OS_SET_COLOR ;a = color, b = color 2 (highlight)
  87+ 0000 ~                ld c,#06
  88+ 0000 ~                rst #20
  89+ 0000                  endm
  90+ 0000
  91+ 0000                  ; macro OS_ ;
  92+ 0000                  ; ld c,#07
  93+ 0000                  ; rst #20
  94+ 0000                  ; endm
  95+ 0000
  96+ 0000
  97+ 0000              ;включить/выключить моно режим для приложения
  98+ 0000              ;при включенном режиме разрешена запись в диапазон памяти #4000-#7fff + страницы приложения
  99+ 0000              ;вх: a = 0 - включить; a = 255 - выключить
 100+ 0000                  macro OS_SET_MONO_MODE ;
 101+ 0000 ~                ld c,#08
 102+ 0000 ~                rst #20
 103+ 0000                  endm
 104+ 0000
 105+ 0000
 106+ 0000
 107+ 0000              ;печать в консоль до кода 0
 108+ 0000                  macro OS_PRINTZ ;hl=text ;PRINT to 0
 109+ 0000 ~                ld c,#09
 110+ 0000 ~                rst #20
 111+ 0000                  endm
 112+ 0000
 113+ 0000
 114+ 0000              ;прочитать байт из порта uart
 115+ 0000              ;вх:
 116+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart или нет данных для приёма
 117+ 0000              ;вых: A - считанный байт
 118+ 0000                  macro OS_UART_READ
 119+ 0000 ~                ld c,#0a
 120+ 0000 ~                rst #20
 121+ 0000                  endm
 122+ 0000
 123+ 0000              ;записать байт в порт uart
 124+ 0000              ;вх: A -байт
 125+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 126+ 0000                  macro OS_UART_WRITE
 127+ 0000 ~                ld c,#0b
 128+ 0000 ~                rst #20
 129+ 0000                  endm
 130+ 0000
 131+ 0000              ;закрыть соединение ESP
 132+ 0000              ;вх:
 133+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 134+ 0000                  macro OS_ESP_CLOSE
 135+ 0000 ~                ld c,#0c
 136+ 0000 ~                rst #20
 137+ 0000                  endm
 138+ 0000
 139+ 0000              ;установить соединение ESP (CIPSTART);
 140+ 0000              ;вх: a - тип соединения 0-tcp, 1-udp, 2-ssl; 3-прямое соединение с портом; hl - строка адрес, de - строка порт
 141+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 142+ 0000              ;вых: ix - адрес в таблице соединений (ix+2 - флаг открытия =1 - открыто, 255 - ошибка);
 143+ 0000                  macro OS_ESP_OPEN
 144+ 0000 ~                ld c,#0d
 145+ 0000 ~                rst #20
 146+ 0000                  endm
 147+ 0000
 148+ 0000              ;послать запрос ESP (CIPSEND);
 149+ 0000              ;вх: hl - адрес данных, de - длина данных
 150+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 151+ 0000              ;вых: ix - адрес в таблице соединений (ix+4 - флаг =1 - отправлено, 255 - ошибка)
 152+ 0000                  macro OS_ESP_SEND
 153+ 0000 ~                ld c,#0e
 154+ 0000 ~                rst #20
 155+ 0000                  endm
 156+ 0000
 157+ 0000              ;получить пакет ESP (+IPD);
 158+ 0000              ;вх: hl - адрес для данных
 159+ 0000              ;вых: CY=0 - OK; CY=1 - занято другим процессом или нет uart
 160+ 0000              ;вых: ix - адрес в таблице соединений (ix+6 - флаг =1 - принято, 255 - ошибка)
 161+ 0000                  macro OS_ESP_GET
 162+ 0000 ~                ld c,#0f
 163+ 0000 ~                rst #20
 164+ 0000                  endm
 165+ 0000
 166+ 0000              ;ввод с консоли ----------------------
 167+ 0000
 168+ 0000              ;получить код нажатой клавиши
 169+ 0000                  macro OS_GET_CHAR ;read char from stdin (out: A=char, 255-no char)
 170+ 0000 ~                ld c,#10
 171+ 0000 ~                rst #20
 172+ 0000                  endm
 173+ 0000
 174+ 0000
 175+ 0000              ;процессы ----------------------------
 176+ 0000
 177+ 0000              ;запустить процесс
 178+ 0000              ;вх: hl - имя файла (заканчивается на 0)
 179+ 0000                  macro OS_PROC_RUN ;
 180+ 0000 ~                ld c,#11
 181+ 0000 ~                rst #20
 182+ 0000                  endm
 183+ 0000
 184+ 0000              ;установить фокус
 185+ 0000              ;вх: a - id процесса
 186+ 0000                  macro OS_PROC_SET_FOCUS ;
 187+ 0000 ~                ld c,#12
 188+ 0000 ~                rst #20
 189+ 0000                  endm
 190+ 0000
 191+ 0000              ;закрыть процесс
 192+ 0000              ;вх: A - ID процесса. Если A=0, закрыть текущий (себя)
 193+ 0000              ;останавливается процесс и освобождаются все его страницы памяти, файлы, соединения
 194+ 0000                  macro OS_PROC_CLOSE ;
 195+ 0000 ~                ld c,#13
 196+ 0000 ~                rst #20
 197+ 0000                  endm
 198+ 0000
 199+ 0000
 200+ 0000              ;прерывания --------------------------
 201+ 0000
 202+ 0000              ;установка адреса обработчика прерываний процесса;
 203+ 0000              ;например, плеера музыки
 204+ 0000              ;включать прерывания во время работы обработчика нельзя. время работы, по возможности, минимальное
 205+ 0000              ;на время выполнения включаются обе страницы процесса
 206+ 0000                  macro OS_SET_INTER ;(HL - address, address = 0 = отключить)
 207+ 0000 ~                ld c,#14
 208+ 0000 ~                rst #20
 209+ 0000                  endm
 210+ 0000
 211+ 0000
 212+ 0000              ;плеер AY ----------------------------
 213+ 0000
 214+ 0000              ;инициализация плеера AY;
 215+ 0000                  macro OS_VTPL_INIT ;(HL - address music)
 216+ 0000 ~                ld c,#15
 217+ 0000 ~                rst #20
 218+ 0000                  endm
 219+ 0000
 220+ 0000              ;запустить плеер AY (система будет сама вызывать его каждое прерывание);
 221+ 0000                  macro OS_VTPL_PLAY ;()
 222+ 0000 ~                ld c,#16
 223+ 0000 ~                rst #20
 224+ 0000                  endm
 225+ 0000
 226+ 0000              ;заглушить плеер AY;
 227+ 0000                  macro OS_VTPL_MUTE ;()
 228+ 0000 ~                ld c,#17
 229+ 0000 ~                rst #20
 230+ 0000                  endm
 231+ 0000
 232+ 0000              ;получить значение переменной плеера;
 233+ 0000                  macro OS_GET_VTPL_SETUP ;(out: HL - setup address)
 234+ 0000 ~                ld c,#18
 235+ 0000 ~                rst #20
 236+ 0000                  endm
 237+ 0000
 238+ 0000
 239+ 0000              ;прочие ------------------------------
 240+ 0000
 241+ 0000
 242+ 0000              ;скопировать данные из страницы в страницу
 243+ 0000              ;вх: hl - откуда (абсолютный адрес 0-ffff); de - куда; ix - длина; a - страница слот2; b - страница слот3;
 244+ 0000                  macro OS_RAM_COPY
 245+ 0000 ~                ld c,#19
 246+ 0000 ~                rst #20
 247+ 0000                  endm
 248+ 0000
 249+ 0000              ;получить дополнительную страницу памяти;
 250+ 0000                  macro OS_GET_PAGE ;(out A - number page)
 251+ 0000 ~                ld c,#1a
 252+ 0000 ~                rst #20
 253+ 0000                  endm
 254+ 0000
 255+ 0000              ;включить страницу в слот 2 (#8000); предварительно зарезервировать страницу OS_GET_PAGE
 256+ 0000                  macro OS_SET_PAGE_SLOT2 ;(A - page number)
 257+ 0000 ~                ld c,#1b
 258+ 0000 ~                rst #20
 259+ 0000                  endm
 260+ 0000
 261+ 0000              ;включить страницу в слот 3 (#C000); предварительно зарезервировать страницу OS_GET_PAGE
 262+ 0000                  macro OS_SET_PAGE_SLOT3 ;(A - page number)
 263+ 0000 ~                ld c,#1c
 264+ 0000 ~                rst #20
 265+ 0000                  endm
 266+ 0000
 267+ 0000              ;включить экран N;
 268+ 0000              ;вх: A - номер экрана (5, 7, #39, #3a; 0 = текстовый)
 269+ 0000              ;переключать может только приложение в фокусе
 270+ 0000              ;если режим не текстовый, то приложение работает только когда в фокусе. Иначе временно останавливается.
 271+ 0000              ;при переключении процессов сохраняется только экран #39
 272+ 0000                  macro OS_SET_SCREEN ;
 273+ 0000 ~                ld c,#1d
 274+ 0000 ~                rst #20
 275+ 0000                  endm
 276+ 0000
 277+ 0000
 278+ 0000              ;получить номера страниц процесса;
 279+ 0000              ;вх:
 280+ 0000              ;вых: b, c - страницы в слотах 2, 3
 281+ 0000                  macro OS_GET_MAIN_PAGES ;
 282+ 0000 ~                ld c,#1e
 283+ 0000 ~                rst #20
 284+ 0000                  endm
 285+ 0000
 286+ 0000              ;получить значение системного таймера
 287+ 0000                  macro OS_GET_TIMER ;(out: HL, DE - timer)
 288+ 0000 ~                ld c,#1F
 289+ 0000 ~                rst #20
 290+ 0000                  endm
 291+ 0000
 292+ 0000
 293+ 0000              ;освободить страницу памяти
 294+ 0000              ;вх: a - номер страницы
 295+ 0000                  macro OS_DEL_PAGE ;
 296+ 0000 ~                ld c,#20
 297+ 0000 ~                rst #20
 298+ 0000                  endm
 299+ 0000
 300+ 0000
 301+ 0000              ;дисковые операции -------------------
 302+ 0000
 303+ 0000              ; менять напрямую что-то в таблице fcb из приложения не рекомендуется, только для чтения
 304+ 0000
 305+ 0000              ; fcbFAT (из руководства к монитору)
 306+ 0000              ; формат fcb для работы с FAT
 307+ 0000
 308+ 0000              ; +#00 8 имя файла
 309+ 0000              ; +#08 3 расширение файла
 310+ 0000              ; +#0B 1 атрибуты файла
 311+ 0000              ; +#0C 4 номер первого кластера файла/каталога
 312+ 0000              ; +#10 4 номер первого кластера каталога с этим файлом/каталогом
 313+ 0000              ; +#14 4 размер файла/каталога в байтах
 314+ 0000              ; +#18 4 указатель в файле
 315+ 0000              ; +#1C 1 для внутренних нужд
 316+ 0000              ; +#1D 1 для внутренних нужд
 317+ 0000              ; +#1E 1 резерв
 318+ 0000              ; +#1F 1 номер винчестера и раздела на нем
 319+ 0000              	; 1-0,nn номер раздела
 320+ 0000              	; 3-2,=00/01/10 HDD master/HDD slave/SD
 321+ 0000              	    ; значение %11 недопустимо
 322+ 0000
 323+ 0000              ;открыть файл для чтения или записи
 324+ 0000                  macro OS_FILE_OPEN ;HL - File name (out: A - id file, de hl - size, IX - fcb)
 325+ 0000 ~                ld c,#21
 326+ 0000 ~                rst #20
 327+ 0000                  endm
 328+ 0000
 329+ 0000              ;создать файл
 330+ 0000                  macro OS_FILE_CREATE ;HL - File name  (out: A - id file, IX - fcb)
 331+ 0000 ~                ld c,#22
 332+ 0000 ~                rst #20
 333+ 0000                  endm
 334+ 0000
 335+ 0000              ;прочитать из файла
 336+ 0000                  macro OS_FILE_READ ;HL - address, A - id file, DE - length (out: hl - следующий адрес для чтения)
 337+ 0000 ~                ld c,#23
 338+ 0000 ~                rst #20
 339+ 0000                  endm
 340+ 0000
 341+ 0000              ;записать в файл
 342+ 0000                  macro OS_FILE_WRITE ;HL - address, A - id file, DE - length (out: hl - следующий адрес для чтения)
 343+ 0000 ~                ld c,#24
 344+ 0000 ~                rst #20
 345+ 0000                  endm
 346+ 0000
 347+ 0000              ;закрыть файл
 348+ 0000                  macro OS_FILE_CLOSE ;A - id file
 349+ 0000 ~                ld c,#25
 350+ 0000 ~                rst #20
 351+ 0000                  endm
 352+ 0000
 353+ 0000              ;чтение секторов текущего каталога
 354+ 0000              ; вх:
 355+ 0000                   ; hl - буфер для чтения
 356+ 0000                   ; de - относительный номер первого сектора каталога для чтения [0..nn]
 357+ 0000                   ; b - максимальное количество секторов для чтения
 358+ 0000              ; вых: cy=1, если были ошибки, код ошибки возвращается в аккумуляторе
 359+ 0000                     ; a=errRWnum
 360+ 0000                     ; a=errInvalidPart
 361+ 0000                     ; a=errFileEmpty
 362+ 0000                   ; cy=0, a=errEoF - каталог закончился
 363+ 0000                     ; hl - следующий адрес в буфере
 364+ 0000                     ; de - номер первого непрочитанного сектора
 365+ 0000                     ; b - не прочитано секторов
 366+ 0000                   ; cy=0 - считано успешно
 367+ 0000                     ; hl - следующий адрес в буфере
 368+ 0000                     ; de - номер первого непрочитанного сектора
 369+ 0000                     ; b=#00
 370+ 0000                  macro OS_DIR_READ ;
 371+ 0000 ~                ld c,#26
 372+ 0000 ~                rst #20
 373+ 0000                  endm
 374+ 0000
 375+ 0000              ;вход в каталог/выход в родительский каталог
 376+ 0000              	; Если путь не указан производится только настройка переменных драйвера,
 377+ 0000              	; при этом если передан дескриптор файла, текущий каталог не изменится)
 378+ 0000              	; Если пусть указан, в конец пути добавится название каталога (если это
 379+ 0000              	; переход в родительский, последнее имя в пути удалится).
 380+ 0000              	; Если передан дескриптор файла, текущий каталог не изменится, к пути
 381+ 0000              	; добавится имя файла
 382+ 0000              ; вх:
 383+ 0000                   ; hl - адрес пути (=#0000 - путь отсутствует)
 384+ 0000                   ; de - адрес дескриптора директории/файла
 385+ 0000              ; вых: a - если путь был указан, новая длина пути
 386+ 0000                  macro OS_DIR_OPEN ;
 387+ 0000 ~                ld c,#27
 388+ 0000 ~                rst #20
 389+ 0000                  endm
 390+ 0000
 391+ 0000              ;установка/чтение указателя в файле (Переменная +#18-#1b fcb)
 392+ 0000              ;проверки на допустимость значений не производится
 393+ 0000              ;вх: CY = 1 - установка; CY = 0 - чтение
 394+ 0000              ;вх: A - id файла
 395+ 0000              ;вх: de, hl - значения старшие быйты, младшие
 396+ 0000              ;вых: de, hl - значения старшие быйты, младшие
 397+ 0000                  macro OS_FILE_POSITION ;
 398+ 0000 ~                ld c,#28
 399+ 0000 ~                rst #20
 400+ 0000                  endm
 401+ 0000
 402+ 0000              ; поиск файла или каталога по заданному пути, начиная от корневого, со входом в подкаталоги
 403+ 0000              ;вх: hl - путь к файлу в формате ASCIZ (не более 250 байт, заканчивается нулем)
 404+ 0000              	 ;формат пути: \[DIR\DIR\..\DIR\]filename.ext	(можно без имени файла, только каталоги)
 405+ 0000              ;вх: a=#00/#FF - без установки каталога/с установкой найденного каталога текущим
 406+ 0000                  macro OS_FIND_PATH ;
 407+ 0000 ~                ld c,#29
 408+ 0000 ~                rst #20
 409+ 0000                  endm
 410+ 0000
 411+ 0000
 412+ 0000              ; получение длинного имени файла
 413+ 0000              ;вх: hl - адрес буфера для имени
 414+ 0000              ;    de - номер записи в текущем каталоге
 415+ 0000              ;вых: hl - в буфере имя в формате ASCIZ (если длинное имя отсутсвует, то возвращается короткое имя)
 416+ 0000              ; 	a - длина имени, с учетом нуля
 417+ 0000                  macro OS_GET_LFN ;
 418+ 0000 ~                ld c,#2a
 419+ 0000 ~                rst #20
 420+ 0000                  endm
 421+ 0000
# file closed: ../os_defs.asm
   3  0000                  org PROG_START
   4  8000              asmOrg:
   5  8000 C3 3E A4         jp start
   6  8003
   7  8003              ; Generate version string
   8  8003                  LUA ALLPASS
   9  8003 ~                v = tostring(sj.get_define("V"))
  10  8003 ~                maj = string.sub(v, 1,1)
  11  8003 ~                min = string.sub(v, 2,2)
  12  8003 ~                sj.insert_define("VERSION_STRING", "\"" .. maj .. "." .. min .. "\"")
  13  8003                  ENDLUA
  14  8003
  15  8003                  include "vdp/index.asm"
# file opened: vdp/index.asm
   1+ 8003                  IFDEF TIMEX
   2+ 8003 ~                include "timex.asm"
   3+ 8003                  ENDIF
   4+ 8003
   5+ 8003                  IFDEF TIMEX80
   6+ 8003 ~                include "timex80.asm"
   7+ 8003                  ENDIF
   8+ 8003
   9+ 8003                  IFDEF ZXSCR
  10+ 8003 ~                include "zx.asm"
  11+ 8003                  ENDIF
  12+ 8003
  13+ 8003                  IFDEF ZSGMX
  14+ 8003                  include "zsgmx.asm"
# file opened: vdp/zsgmx.asm
   1++8003              COLOR=1
   2++8003              ;; ZS GMX screen driver (izzx)
   3++8003              	;define LINE_LIMIT 80
   4++8003                  module TextMode
   5++8003              init:
   6++8003                  ; ld hl, font_file, b, Dos.FMODE_READ
   7++8003                  ; call Dos.fopen
   8++8003                  ; push af
   9++8003                  ; ld bc, 2048, hl, font
  10++8003                  ; call Dos.fread
  11++8003                  ; pop af
  12++8003                  ; call Dos.fclose
  13++8003              	; xor a : out (#fe), a
  14++8003              	; call cls
  15++8003              	; ret
  16++8003              cls:
  17++8003              	OS_CLS
  17++8003 0E 00       >    ld c,#00
  17++8005 E7          >    rst #20
  18++8006 C9           	ret
  19++8007                  ; ld de, 0 : call gotoXY
  20++8007                  ; ;ld a, 7 : call Memory.setPage
  21++8007              	; ld a,#3b
  22++8007              	; call PageSlot3 ;включить страницу пикселей
  23++8007                  ; xor a : out (#fe), a
  24++8007                  ; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  25++8007              	; ld a,#7b
  26++8007              	; call PageSlot3 ;включить страницу атрибутов
  27++8007              	; ld a,(attr_screen) ;цвет
  28++8007              	; ld hl, #c000, de, #c001, bc, 16000-1, (hl), a : ldir ;очистить
  29++8007              	; call gmxscron ;включить расширенный экран
  30++8007              	; xor a
  31++8007              	; jp PageSlot3 ;вернуть страницу 0
  32++8007                  ;jp Memory.setPage
  33++8007
  34++8007
  35++8007              ; Set console coordinates
  36++8007              ; d = row(0..23), e = column (0..79)
  37++8007              gotoXY:
  38++8007              	OS_SET_XY
  38++8007 0E 01       >    ld c,#01
  38++8009 E7          >    rst #20
  39++800A              	;rr e
  40++800A              	; ld a, 0
  41++800A              	; ld (half_tile_screen), a
  42++800A                  ;ld (col_screen), de
  43++800A C9               ret
  44++800B
  45++800B              disable:
  46++800B                  ; Nothing to disable
  47++800B              	;call gmxscroff ;выключить расширенный экран
  48++800B C9               ret
  49++800C
  50++800C              ; H - line
  51++800C              ; A - char
  52++800C              fillLine: ;заполнение строки одним символом
  53++800C              	OS_FILL_LINE
  53++800C 0E 03       >    ld c,#03
  53++800E E7          >    rst #20
  54++800F C9           	ret
  55++8010                  ; push af
  56++8010                  ; ld d, h, e, 0 : call gotoXY
  57++8010                  ; pop af
  58++8010                  ; ld hl, fill_buff, de, fill_buff + 1, bc, 80-1, (hl), a : ldir
  59++8010                  ; ld hl, fill_buff : jp printZ
  60++8010
  61++8010              usualLine: ;на входе в A номер строки, которую надо покрасить обычным цветом
  62++8010 06 07        	ld b,#07 ;цвет
  63++8012              	OS_PAINT_LINE
  63++8012 0E 04       >    ld c,#04
  63++8014 E7          >    rst #20
  64++8015 C9           	ret
  65++8016                  ; ld b, a
  66++8016                  ; ld c, 0
  67++8016                  ; call bc_to_attr
  68++8016                  ; ;ld a, 7 : call Memory.setPage
  69++8016              	; push hl
  70++8016              	; ld a,#7b ;атрибуты
  71++8016              	; call PageSlot3
  72++8016              	; pop hl
  73++8016              	; ld a,(attr_screen) ;цвет
  74++8016                  ; ld (hl), a
  75++8016                  ; ld de, hl
  76++8016                  ; inc de
  77++8016                  ; ld bc, (80*8)-1
  78++8016                  ; ldir
  79++8016                  ; xor a : ;jp Memory.setPage
  80++8016              	; jp PageSlot3 ;вернуть страницу 0
  81++8016
  82++8016              highlightLine: ;на входе в A номер строки, которую надо покрасить другим цветом
  83++8016 06 0C        	ld b,#0c ;цвет
  84++8018              	OS_PAINT_LINE
  84++8018 0E 04       >    ld c,#04
  84++801A E7          >    rst #20
  85++801B C9           	ret
  86++801C                  ; ld b, a
  87++801C                  ; ld c, 0
  88++801C                  ; call bc_to_attr
  89++801C                  ; ;ld a, 7 : call Memory.setPage
  90++801C              	; push hl
  91++801C              	; ld a,#7b ;атрибуты
  92++801C              	; call PageSlot3
  93++801C              	; pop hl
  94++801C              	; ld a,(attr_screen2) ;цвет
  95++801C                  ; ld (hl), a
  96++801C                  ; ld de, hl
  97++801C                  ; inc de
  98++801C                  ; ld bc, (80*8)-1
  99++801C                  ; ldir
 100++801C                  ; xor a : ;jp Memory.setPage
 101++801C              	; jp PageSlot3 ;вернуть страницу 0
 102++801C
 103++801C              ; mvCR ;каретка вниз
 104++801C              	; ld de, (col_screen)
 105++801C              	; inc d
 106++801C              	; ld e, 0
 107++801C              	; ; ld a, 0
 108++801C              	; ; ld (half_tile_screen), a
 109++801C              	; jp gotoXY
 110++801C
 111++801C              ; Print just one symbol
 112++801C              ; A - symbol
 113++801C              putC
 114++801C              	OS_PRINT_CHARF
 114++801C D7          >	rst #10
 115++801D C9           	ret
 116++801E                  ; cp 13 : jp z, mvCR
 117++801E
 118++801E              	; ld hl, single_symbol
 119++801E              	; ld (hl), a
 120++801E              	; ;ld a, 7 : call Memory.setPage
 121++801E              	; ld a,#3b ;пиксели
 122++801E              	; call PageSlot3
 123++801E                  ; ld hl, single_symbol_print
 124++801E                  ; call printL
 125++801E                  ; xor a : ;jp Memory.setPage
 126++801E              	; jp PageSlot3 ;вернуть страницу 0
 127++801E
 128++801E              ; Put string
 129++801E              ; hl - string pointer that's begins from symbol count
 130++801E              printZ
 131++801E              	OS_PRINTZ
 131++801E 0E 09       >    ld c,#09
 131++8020 E7          >    rst #20
 132++8021 C9           	ret
 133++8022                  ; ld a, (hl) : and a : ret z
 134++8022                  ; push hl
 135++8022                  ; call putC
 136++8022                  ; pop hl
 137++8022                  ; inc hl
 138++8022                  ; jr printZ
 139++8022
 140++8022              ; printL
 141++8022                      ; ld	a, (hl)
 142++8022              		; and	a
 143++8022              		; ret	z
 144++8022
 145++8022              		; ; push	hl
 146++8022              		; ; call	calc_addr_scr
 147++8022              		; ; ld	a,(attr_screen)
 148++8022              		; ; ;ld	(hl),a ;покрасить символ
 149++8022              		; ; pop	hl
 150++8022
 151++8022              		; ;call	calc_addr_scr
 152++8022
 153++8022              		; ; ld	a,(half_tile_screen)
 154++8022              		; ; bit	0,a
 155++8022              		; ; ld	a,(hl)
 156++8022              		; ; jp	nz,print64_4
 157++8022              ; ;print80_3
 158++8022                      ; push    af
 159++8022              		; push	hl
 160++8022              		; ; ld a,#7b ;атрибуты
 161++8022              		; ; call PageSlot3
 162++8022              		; call	calc_addr_scr
 163++8022              		; ; ld	a,(attr_screen)
 164++8022              		; ; ld	(hl),a ;покрасить символ
 165++8022              		; ld d,h ;координаты экрана в DE
 166++8022              		; ld e,l
 167++8022              		; ; ld a,#3b ;пиксели
 168++8022              		; ; call PageSlot3
 169++8022              		; pop	hl
 170++8022
 171++8022                      ; inc     hl
 172++8022                      ; push    hl
 173++8022
 174++8022                      ; ld      a,(hl)
 175++8022              		; ld	l,a
 176++8022              		; ld	h,0
 177++8022              		; add	hl,hl
 178++8022              		; add	hl,hl
 179++8022              		; add	hl,hl
 180++8022                      ; ld      bc,font
 181++8022                      ; add     hl,bc
 182++8022
 183++8022                      ; ;push    de
 184++8022
 185++8022                      ; ld      b,8
 186++8022              		; ; xor	a
 187++8022              		; ; ld	(de),a
 188++8022              ; print80_1
 189++8022              	; ;inc     d
 190++8022
 191++8022              	; ld      a,(hl)
 192++8022              	; ;and	#f0
 193++8022              	; ld      (de),a
 194++8022              	; inc     hl
 195++8022
 196++8022              	; push hl ;на строку пикселей вниз
 197++8022              	; ld hl,80
 198++8022              	; add hl,de
 199++8022              	; ex de,hl
 200++8022              	; pop hl
 201++8022
 202++8022              	; djnz    print80_1
 203++8022
 204++8022              	; ;inc	d
 205++8022              	; ; push hl
 206++8022              	; ; ld hl,80
 207++8022              	; ; add hl,de
 208++8022              	; ; ex de,hl
 209++8022              	; ; pop hl
 210++8022
 211++8022              	; ; xor	a
 212++8022              	; ; ld	(de),a
 213++8022
 214++8022              	; ; ld	a,1
 215++8022              	; ; ld	(half_tile_screen),a
 216++8022
 217++8022              	; ;pop     de
 218++8022              	; pop     hl
 219++8022              	; pop     af
 220++8022
 221++8022              	; ;dec     a
 222++8022              	; ; ret     ;z
 223++8022
 224++8022              ; ; print64_4
 225++8022              	; ; push    af
 226++8022
 227++8022              	; ; inc     hl
 228++8022              	; ; push    hl
 229++8022
 230++8022              	; ; ld      a,(hl)
 231++8022              	; ; ld	l,a
 232++8022              	; ; ld	h,0
 233++8022              	; ; add	hl,hl
 234++8022              	; ; add	hl,hl
 235++8022              	; ; add	hl,hl
 236++8022              	; ; ld      bc,font
 237++8022              	; ; add     hl,bc
 238++8022
 239++8022              	; ; push    de
 240++8022
 241++8022              	; ; ld      b,6
 242++8022              	; ; xor	a
 243++8022              	; ; ld	(de),a
 244++8022              ; ; print64_2
 245++8022              	; ; ;inc     d
 246++8022              	; ; push hl
 247++8022              	; ; ld hl,80
 248++8022              	; ; add hl,de
 249++8022              	; ; ex de,hl
 250++8022              	; ; pop hl
 251++8022              	; ; ld      a,(hl)
 252++8022              	; ; ;and     #0f
 253++8022              	; ; ld      c,a
 254++8022              	; ; ld      a,(de)
 255++8022              	; ; or      c
 256++8022              	; ; ld      (de),a
 257++8022              	; ; inc     hl
 258++8022              	; ; djnz    print64_2
 259++8022
 260++8022              	; ; ;inc	d
 261++8022              	; ; push hl
 262++8022              	; ; ld hl,80
 263++8022              	; ; add hl,de
 264++8022              	; ; ex de,hl
 265++8022              	; ; pop hl
 266++8022              	; ; xor	a
 267++8022              	; ; ld	(de),a
 268++8022
 269++8022              	; ; ld	(half_tile_screen),a
 270++8022
 271++8022              	; ; pop     de
 272++8022
 273++8022              	; ; call	move_cr64
 274++8022
 275++8022              	; ; pop     hl
 276++8022              	; ; pop     af
 277++8022              	; ; dec     a
 278++8022
 279++8022              	; ; jp      nz,print64_3
 280++8022
 281++8022              	; ; ret
 282++8022
 283++8022              ; ; move cursor на одну позицию вперёд
 284++8022              ; move_cr80
 285++8022              	; ;inc	de
 286++8022
 287++8022              	; ld	hl,col_screen
 288++8022              	; inc	(hl) ;увеличить столбец
 289++8022              	; ld	a,(hl)
 290++8022
 291++8022              	; cp	80
 292++8022              	; ret	c
 293++8022
 294++8022              	; xor	a
 295++8022              	; ;ld	(half_tile_screen),a
 296++8022              	; ld	(hl),a
 297++8022              	; ld	c,a
 298++8022
 299++8022              	; inc	hl ;на переменную row
 300++8022              	; inc	(hl)
 301++8022              	; ld	a,(hl)
 302++8022              	; ld	b,a
 303++8022
 304++8022              	; cp	24
 305++8022              	; jp	c,move_cr80_01
 306++8022
 307++8022              	; ld	a,23
 308++8022              	; ld	(hl),a
 309++8022              	; ld	b,a
 310++8022
 311++8022              	; ; push	bc
 312++8022              	; ; call	scroll_up8
 313++8022              	; ; pop	bc
 314++8022
 315++8022              ; move_cr80_01
 316++8022              	; ; call	calc_addr_scr
 317++8022              	; ; ret
 318++8022
 319++8022              ; calc_addr_scr	;определение адреса экрана по координатам символа
 320++8022              	; ld	bc,(col_screen)
 321++8022              ; bc_to_attr:
 322++8022              	; ld h,0
 323++8022              	; ld l,b ;строка
 324++8022              	; add hl,hl ;*2
 325++8022              	; ld de,table_addr_scr
 326++8022              	; add hl,de
 327++8022              	; ld e,(hl)
 328++8022              	; inc hl
 329++8022              	; ld d,(hl) ;узнали координаты строки
 330++8022              	; ld h,0
 331++8022              	; ld l,c ;колонка
 332++8022              	; add hl,de ;узнали адрес символа
 333++8022              	; ; ld      a,b
 334++8022              	; ; ld      d,a
 335++8022              	; ; rrca
 336++8022              	; ; rrca
 337++8022              	; ; rrca
 338++8022              	; ; and     a,224
 339++8022              	; ; add     a,c
 340++8022              	; ; ld      e,a
 341++8022              	; ; ld      a,d
 342++8022              	; ; and     24
 343++8022              	; ; or      #c0
 344++8022              	; ; ld      d,a
 345++8022              	; ret
 346++8022
 347++8022              ; ; calc_addr_attr
 348++8022              	; ; ld	bc,(col_screen)
 349++8022              ; ; bc_to_attr:
 350++8022              	; ; ld	a,b
 351++8022              	; ; rrca
 352++8022              	; ; rrca
 353++8022              	; ; rrca
 354++8022              	; ; ld	l,a
 355++8022              	; ; and	31
 356++8022              	; ; or	#d8
 357++8022              	; ; ld	h,a
 358++8022              	; ; ld	a,l
 359++8022              	; ; and	252
 360++8022              	; ; or	c
 361++8022              	; ; ld	l,a
 362++8022              	; ; ret
 363++8022
 364++8022              ; ; scroll_up8	;
 365++8022              	; ; ld	hl,table_addr_scr
 366++8022              	; ; ld	b,184
 367++8022
 368++8022              ; ; scroll_up8_01
 369++8022              	; ; push	bc
 370++8022
 371++8022              	; ; ld	e,(hl)
 372++8022              	; ; inc	hl
 373++8022              	; ; ld	d,(hl)
 374++8022              	; ; inc	hl
 375++8022
 376++8022              	; ; push	hl
 377++8022
 378++8022              	; ; ld	bc,14
 379++8022              	; ; add	hl,bc
 380++8022              	; ; ld	c,(hl)
 381++8022              	; ; inc	hl
 382++8022              	; ; ld	b,(hl)
 383++8022
 384++8022              	; ; ld	h,b
 385++8022              	; ; ld	l,c
 386++8022
 387++8022              	; ; ld	bc,32
 388++8022              	; ; ldir
 389++8022
 390++8022              	; ; pop	hl
 391++8022              	; ; pop	bc
 392++8022              	; ; djnz	scroll_up8_01
 393++8022
 394++8022              	; ; ld	b,8
 395++8022
 396++8022              ; ; scroll_up8_02
 397++8022              	; ; push	bc
 398++8022
 399++8022              	; ; ld	e,(hl)
 400++8022              	; ; inc	hl
 401++8022              	; ; ld	d,(hl)
 402++8022              	; ; inc	hl
 403++8022
 404++8022              	; ; push	hl
 405++8022
 406++8022              	; ; ld	h,d
 407++8022              	; ; ld	l,e
 408++8022              	; ; inc	de
 409++8022              	; ; ld	(hl),0
 410++8022              	; ; ld	bc,31
 411++8022              	; ; ldir
 412++8022
 413++8022              	; ; pop	hl
 414++8022              	; ; pop	bc
 415++8022              	; ; djnz	scroll_up8_02
 416++8022              	; ; ld	de,#D800, hl,#D820, bc,736
 417++8022              	; ; ldir
 418++8022              	; ; ld	a,(de)
 419++8022              	; ; ld	hl,#dae0, de,#dae1, (hl),a, bc,31
 420++8022              	; ; ldir
 421++8022
 422++8022              	; ; ret
 423++8022
 424++8022
 425++8022              ; gmxscron
 426++8022                          ; ld      bc,#7efd
 427++8022                          ; ld      a,#c8
 428++8022                          ; out     (c),a
 429++8022                          ; ; ld      bc,#7ffd
 430++8022                          ; ; ld      a,#10    ;5 screen
 431++8022                          ; ; out     (c),a
 432++8022                          ; ret
 433++8022
 434++8022              ; ; gmxscron2
 435++8022                          ; ; ld      bc,#7efd
 436++8022                          ; ; ld      a,#c8
 437++8022                          ; ; out     (c),a
 438++8022                          ; ; ld      bc,#7ffd
 439++8022                          ; ; ld      a,#18    ;7 screen
 440++8022                          ; ; out     (c),a
 441++8022                          ; ; ret
 442++8022
 443++8022              ; gmxscroff
 444++8022                          ; ld      bc,#7efd
 445++8022                          ; ld      a,#c0
 446++8022                          ; out     (c),a
 447++8022                          ; ; ld      bc,#7ffd
 448++8022                          ; ; ld      a,#10    ;5 screen
 449++8022                          ; ; out     (c),a
 450++8022                          ; ret
 451++8022
 452++8022
 453++8022              ; PageSlot3
 454++8022              ; ; драйвер памяти для TR-DOS Navigator
 455++8022              ; ; и Scorpion GMX 2Mb
 456++8022                       ; ; org  #5b00
 457++8022                       ; ; jr   pag_on
 458++8022                       ; ; jr   clock
 459++8022                       ; ; db   #00
 460++8022                       ; ; db   #00
 461++8022
 462++8022                       ; ;push hl
 463++8022                       ; ld   hl,table
 464++8022                       ; add  a,l
 465++8022                       ; jr   nc,PageSlot3_1
 466++8022                       ; inc  h          ;коррекция
 467++8022              ; PageSlot3_1  ld   l,a
 468++8022                       ; ld   a,(hl)
 469++8022                       ; ;pop  hl
 470++8022                       ; ;cp   #ff
 471++8022                       ; ;scf
 472++8022                       ; ;ret  z
 473++8022                       ; ;push bc
 474++8022                       ; push af
 475++8022                       ; rlca
 476++8022                       ; and  #10
 477++8022                       ; ld   bc,#1ffd
 478++8022              ; PageSlot3DOS
 479++8022              		 ; ;or #00 ; #04 тут выбор ПЗУ TRDOS
 480++8022                       ; out  (c),a
 481++8022                       ; pop  af
 482++8022                       ; push af
 483++8022                       ; and  #07
 484++8022              ; PageSlot3Scr ;тут выбор экрана и ПЗУ
 485++8022                       ; or   #18 ;#0 ;#18
 486++8022                       ; ld   b,#7f
 487++8022                       ; out  (c),a
 488++8022                       ; pop  af
 489++8022                       ; rrca
 490++8022                       ; rrca
 491++8022                       ; rrca
 492++8022                       ; rrca
 493++8022                       ; and  #07
 494++8022                       ; ld   b,#df
 495++8022                       ; out  (c),a
 496++8022                       ; ;pop  hl
 497++8022                       ; ret
 498++8022              ; ; clock    ld   d,%00100000
 499++8022                       ; ; rst  8
 500++8022                       ; ; db   #89
 501++8022                       ; ; ret
 502++8022
 503++8022                       ; ; org  #5b5c ; здесь системная переменая
 504++8022                       ; ; db   #10
 505++8022              ; ;все страницы
 506++8022              ; table    db   #00,#01,#02,#03,#04,#05,#06,#07,#08,#09
 507++8022                       ; db   #0a,#0b,#0c,#0d,#0e
 508++8022                       ; db   #0f,#10,#11,#12,#13,#14
 509++8022                       ; db   #15,#16,#17,#18,#19,#1a
 510++8022                       ; db   #1b,#1c,#1d,#1e,#1f,#20
 511++8022                       ; db   #21,#22,#23,#24,#25,#26
 512++8022                       ; db   #27,#28,#29,#2a,#2b,#2c
 513++8022                       ; db   #2d,#2e,#2f,#30,#31,#32
 514++8022                       ; db   #33,#34,#35,#36,#37,#38,#39
 515++8022                       ; db   #3a,#3b,#3c,#3d,#3e,#3f,#40
 516++8022                       ; db   #41,#42,#43,#44,#45,#46
 517++8022                       ; db   #47,#48,#49,#4a,#4b,#4c
 518++8022
 519++8022                       ; db   #4d,#4e,#4f,#50,#51,#52
 520++8022                       ; db   #53,#54,#55,#56,#57,#58
 521++8022                       ; db   #59,#5a,#5b,#5c,#5d,#5e
 522++8022                       ; db   #5f,#60,#61,#62,#63,#64
 523++8022                       ; db   #65,#66,#67,#68,#69,#6a
 524++8022                       ; db   #6b,#6c,#6d,#6e,#6f,#70
 525++8022                       ; db   #71,#72,#73,#74,#75,#76
 526++8022                       ; db   #77,#78,#79,#7a,#7b,#7c,#7d,#7e
 527++8022                       ; db   #7f
 528++8022
 529++8022                       ; db   #ff ;конец таблицы
 530++8022
 531++8022
 532++8022
 533++8022              ; font equ #4000 ; Using ZX-Spectrum screen as font buffer
 534++8022              ; font_file db "data/font.bin", 0
 535++8022
 536++8022
 537++8022              ; table_addr_scr	;адреса строк текста
 538++8022              	; defw	#c000 ;0
 539++8022              	; defw	#c280
 540++8022              	; defw	#c500
 541++8022              	; defw	#c780
 542++8022              	; defw	#ca00
 543++8022              	; defw	#cc80
 544++8022              	; defw	#cf00
 545++8022              	; defw	#d180
 546++8022
 547++8022              	; defw	#d400 ;8
 548++8022              	; defw	#d680
 549++8022              	; defw	#d900
 550++8022              	; defw	#db80
 551++8022              	; defw	#de00
 552++8022              	; defw	#e080
 553++8022              	; defw	#e300
 554++8022              	; defw	#e580
 555++8022
 556++8022              	; defw	#e800 ;16
 557++8022              	; defw	#ea80
 558++8022              	; defw	#ed00
 559++8022              	; defw	#ef80
 560++8022              	; defw	#f200
 561++8022              	; defw	#f480
 562++8022              	; defw	#f700
 563++8022              	; defw	#f980
 564++8022
 565++8022              	; defw	#fc00 ;24
 566++8022              	; defw	#fe80 ;25 вне экрана
 567++8022
 568++8022
 569++8022              ; col_screen			db	0	;столбец
 570++8022              ; row_screen			db	0	;строка
 571++8022              ; ;half_tile_screen	db	0
 572++8022              ; attr_screen			db	07	;основной цвет
 573++8022              ; attr_screen2		db	#c	;другой цвет
 574++8022
 575++8022              ; ;col_screen_temp			dw	0
 576++8022              ; ;half_tile_screen_temp	db	0
 577++8022
 578++8022              ; single_symbol_print db 1
 579++8022              ; single_symbol 		db 0
 580++8022
 581++8022              ; fill_buff ds 80+1
 582++8022
 583++8022                  endmodule
# file closed: vdp/zsgmx.asm
  15+ 8022                  ENDIF
# file closed: vdp/index.asm
  16  8022                  include "utils/index.asm"
# file opened: utils/index.asm
   1+ 8022                  include "atoi.asm"
# file opened: utils/atoi.asm
   1++8022              ; DE - buffer
   2++8022              ; HL - output
   3++8022              atohl:
   4++8022 21 00 00         ld hl, 0
   5++8025              .loop
   6++8025 1A               ld a, (de)
   7++8026 13               inc de
   8++8027                  ; Sepparators
   9++8027 C5 E5            push bc, hl
  10++8029 01 05 00             ld bc, sepparators_len
  11++802C 21 44 80             ld hl, sepparators
  12++802F ED B1                cpir
  13++8031 E1 C1            pop hl, bc
  14++8033 C8               ret z
  15++8034
  16++8034 D6 30            sub '0'
  17++8036
  18++8036 C5               push bc
  19++8037 4D                   ld c, l
  20++8038 44                   ld b, h
  21++8039
  22++8039 29                   add hl, hl
  23++803A 29                   add hl, hl
  24++803B 09                   add hl, bc
  25++803C 29                   add hl, hl
  26++803D 4F                   ld c, a
  27++803E 06 00                ld b, 0
  28++8040 09                   add hl, bc
  29++8041 C1               pop bc
  30++8042 18 E1            jr .loop
  31++8044
# file closed: utils/atoi.asm
   2+ 8044                  include "constants.asm"
# file opened: utils/constants.asm
   1++8044              TAB = 9
   2++8044              CR = 13
   3++8044              LF = 10
   4++8044              NULL = 0
   5++8044              SPACE = ' '
   6++8044              ESC = 27
   7++8044
   8++8044                  IFNDEF TIMEX80
   9++8044              MIME_DOWNLOAD = 1
  10++8044              MIME_LINK     = 2
  11++8044              MIME_TEXT     = 3
  12++8044              MIME_IMAGE    = 6
  13++8044              MIME_MUSIC    = 5
  14++8044              MIME_INPUT    = 4
  15++8044              MIME_MOD      = 7
  16++8044
  17++8044              BORDER_TOP    = 9
  18++8044              BORDER_BOTTOM = 8
  19++8044                  ELSE
  20++8044 ~            MIME_DOWNLOAD = #19
  21++8044 ~            MIME_LINK = #1A
  22++8044 ~            MIME_TEXT = #10
  23++8044 ~            MIME_IMAGE = #01
  24++8044 ~            MIME_MUSIC = #0e
  25++8044 ~            MIME_INPUT = #b3
  26++8044 ~            MIME_MOD = #0d
  27++8044 ~
  28++8044 ~            BORDER_TOP = #b2
  29++8044 ~            BORDER_BOTTOM = #b1
  30++8044 ~
  31++8044                  ENDIF
  32++8044
  33++8044 0D 0A 09 00  sepparators db CR, LF, TAB, NULL, SPACE
  33++8048 20
  34++8049              sepparators_len = $ - sepparators
# file closed: utils/constants.asm
   3+ 8049                  include "strutils.asm"
# file opened: utils/strutils.asm
   1++8049              ; de - pointer
   2++8049              ; hl - count
   3++8049              strlen:
   4++8049 21 00 00         ld hl, 0
   5++804C              .loop
   6++804C 1A               ld a, (de)
   7++804D A7               and a
   7++804E 28 04          jr z, .exit
   8++8050 23               inc hl
   9++8051 13               inc de
  10++8052 18 F8            jr .loop
  11++8054              .exit
  12++8054 C9               ret
  13++8055
  14++8055                  module CompareBuff
  15++8055
  16++8055              ; Pushes A to buffer
  17++8055              push
  18++8055 F5               push af
  19++8056 06 20            ld b, 32
  19++8058 21 A1 80       ld hl, buffer + 1
  19++805B 11 A0 80       ld de, buffer
  20++805E              .loop
  21++805E 7E               ld a, (hl)
  21++805F 12             ld (de), a
  21++8060 23             inc hl
  21++8061 13             inc de
  21++8062 10 FA          djnz .loop
  22++8064 F1               pop af
  23++8065 21 BF 80         ld hl, buffer + 31
  23++8068 77             ld (hl), a
  24++8069 C9               ret
  25++806A
  26++806A              ; HL - Compare string(null terminated)
  27++806A              ; A - 0 NOT Found
  28++806A              ;     1 Found
  29++806A              search:
  30++806A 06 00            ld b, 0
  30++806C E5             push hl
  31++806D              .loop:
  32++806D 7E               ld a, (hl)
  32++806E 23             inc hl
  32++806F 04             inc b
  32++8070 A7             and a
  32++8071 C2 6D 80       jp nz, .loop
  33++8074 05               dec b
  33++8075 E1             pop hl
  33++8076 C5             push bc
  33++8077 E5             push hl
  34++8078 E1               pop hl
  35++8079 11 C0 80         ld de, buffer + 32
  36++807C              .sourceLoop
  37++807C 1B               dec de
  37++807D 10 FD          djnz .sourceLoop
  38++807F C1               pop bc
  39++8080              .compare
  40++8080 C5               push bc
  40++8081 F5             push af
  41++8082 1A               ld a, (de)
  41++8083 47             ld b, a
  42++8084 F1               pop af
  42++8085 7E             ld a, (hl)
  42++8086 B8             cp b
  42++8087 C1             pop bc
  42++8088 3E 00          ld a, 0
  42++808A C0             ret nz
  43++808B 13               inc de
  43++808C 23             inc hl
  44++808D 10 F1            djnz .compare
  45++808F 3E 01            ld a, 1
  46++8091 C9               ret
  47++8092
  48++8092              clear:
  49++8092 AF               xor a
  49++8093 21 A0 80       ld hl, buffer
  49++8096 11 A1 80       ld de, buffer + 1
  49++8099 01 20 00       ld bc, 32
  49++809C 77             ld (hl), a
  49++809D ED B0          ldir
  50++809F C9               ret
  51++80A0
  52++80A0 00 00 00...  buffer ds 32
  53++80C0
  54++80C0                  endmodule
# file closed: utils/strutils.asm
   4+ 80C0                  include "screen.asm"
# file opened: utils/screen.asm
   1++80C0                  IFNDEF LINE_LIMIT
   2++80C0              LINE_LIMIT = 60
   3++80C0                  ENDIF
   4++80C0              ; HL - string pointer
   5++80C0              print70Text:
   6++80C0 06 3C            ld b, LINE_LIMIT
   7++80C2              .loop
   8++80C2 7E               ld a, (hl)
   9++80C3 A7               and a
   9++80C4 C8             ret z
  10++80C5 FE 0D            cp 13
  10++80C7 C8             ret z
  11++80C8 FE 0A            cp 10
  11++80CA C8             ret z
  12++80CB C5               push bc
  13++80CC E5               push hl
  14++80CD CD 1C 80         call TextMode.putC
  15++80D0 E1               pop hl
  16++80D1 23               inc hl
  17++80D2 C1               pop bc
  18++80D3 05               dec b
  19++80D4 78               ld a, b
  19++80D5 A7             and a
  19++80D6 C8             ret z
  20++80D7 C3 C2 80         jp .loop
  21++80DA
  22++80DA              ; HL - string pointer
  23++80DA              print70Goph:
  24++80DA 06 3C            ld b, LINE_LIMIT
  25++80DC              .loop
  26++80DC 7E               ld a, (hl)
  26++80DD FE 09          cp 09
  26++80DF C8             ret z
  27++80E0 A7               and a
  27++80E1 C8             ret z
  28++80E2 C5               push bc
  29++80E3 E5               push hl
  30++80E4 CD 1C 80         call TextMode.putC
  31++80E7 E1               pop hl
  32++80E8 23               inc hl
  33++80E9 C1               pop bc
  34++80EA 05               dec b
  35++80EB 78               ld a, b
  35++80EC A7             and a
  35++80ED C8             ret z
  36++80EE C3 DC 80         jp .loop
# file closed: utils/screen.asm
# file closed: utils/index.asm
  17  80F1                  include "gopher/render/index.asm"
# file opened: gopher/render/index.asm
   1+ 80F1                  MODULE Render
   2+ 80F1              PER_PAGE = 19
   3+ 80F1              CURSOR_OFFSET = 3
   4+ 80F1                  include "row.asm"
# file opened: gopher/render/row.asm
   1++80F1              ; A - row number
   2++80F1              ; HL - pointer to row
   3++80F1              renderRow:
   4++80F1 C6 03            add CURSOR_OFFSET
   5++80F3 57 1E 00         ld d, a, e, 0
   5++80F6 CD 07 80       call TextMode.gotoXY
   6++80F9 7E               ld a, (hl)
   7++80FA E5               push hl
   8++80FB CD 06 81         call getIcon
   9++80FE CD 1C 80         call TextMode.putC
  10++8101 E1               pop hl
  11++8102 23               inc hl
  12++8103 C3 DA 80         jp print70Goph
  13++8106
  14++8106              ; A - gopher id char
  15++8106              getIcon:
  16++8106 FE 69            cp 'i'
  16++8108 CA 22 81       jp z, .info
  17++810B FE 39            cp '9'
  17++810D CA 25 81       jp z, .down
  18++8110 FE 31            cp '1'
  18++8112 CA A5 81       jp z, .page
  19++8115 FE 30            cp '0'
  19++8117 CA A8 81       jp z, .text
  20++811A FE 37            cp '7'
  20++811C CA AB 81       jp z, .input
  21++811F 3E 20            ld a, ' '
  22++8121 C9               ret
  23++8122              .info
  24++8122 3E 20            ld a, SPACE
  24++8124 C9             ret
  25++8125              .down
  26++8125 54 5D            ld de, hl
  27++8127 01 FF 00 3E      ld bc, #ff, a, TAB
  27++812B 09
  27++812C ED B1          cpir
  28++812E 78               ld a, b
  28++812F B1             or c
  28++8130 28 70          jr z, .downExit
  29++8132 D5               push de
  30++8133              .nameLoop
  31++8133 7E               ld a, (hl)
  31++8134 A7             and a
  31++8135 28 10          jr z, .check
  32++8137 FE 09            cp TAB
  32++8139 28 0C          jr z, .check
  33++813B FE 0D            cp CR
  33++813D 28 08          jr z, .check
  34++813F E5               push hl
  35++8140 CD 55 80         call CompareBuff.push
  36++8143 E1               pop hl
  37++8144 23               inc hl
  38++8145 18 EC            jr .nameLoop
  39++8147              .check
  40++8147 3A E7 81     	ld a,(saveMode+1);фикс обход открытия файлов, чтобы их скачать по кнопке Caps
  41++814A B7           	or a
  42++814B 20 54        	jr nz,.checkExit
  43++814D 21 BA 81         ld hl, scrExt1
  43++8150 CD 6A 80       call CompareBuff.search
  43++8153 A7             and a
  43++8154 20 58          jr nz, .image
  44++8156 21 BF 81         ld hl, scrExt2
  44++8159 CD 6A 80       call CompareBuff.search
  44++815C A7             and a
  44++815D 20 4F          jr nz, .image
  45++815F              	OS_GET_VTPL_SETUP
  45++815F 0E 18       >    ld c,#18
  45++8161 E7          >    rst #20
  46++8162 3E 03            ld a, 3
  46++8164
  47++8164 77           	ld (hl), a ; 0 bit - looping, 1 bit - pt2 file
  48++8165 21 CE 81         ld hl, pt2Ext1
  48++8168 CD 6A 80       call CompareBuff.search
  48++816B A7             and a
  48++816C 20 44          jr nz, .music
  49++816E 21 D3 81         ld hl, pt2Ext2
  49++8171 CD 6A 80       call CompareBuff.search
  49++8174 A7             and a
  49++8175 20 3B          jr nz, .music
  50++8177              	OS_GET_VTPL_SETUP
  50++8177 0E 18       >    ld c,#18
  50++8179 E7          >    rst #20
  51++817A 3E 01            ld a, 1
  51++817C
  52++817C 77           	ld (hl), a
  53++817D 21 C4 81         ld hl, pt3Ext1
  53++8180 CD 6A 80       call CompareBuff.search
  53++8183 A7             and a
  53++8184 20 2C          jr nz, .music
  54++8186 21 C9 81         ld hl, pt3Ext2
  54++8189 CD 6A 80       call CompareBuff.search
  54++818C A7             and a
  54++818D 20 23          jr nz, .music
  55++818F
  56++818F                  ; General Sound support
  57++818F                  ifdef GS
  58++818F 21 D8 81         ld hl, modExt1
  58++8192 CD 6A 80       call CompareBuff.search
  58++8195 A7             and a
  58++8196 20 1E          jr nz, .mod
  59++8198 21 DD 81         ld hl, modExt2
  59++819B CD 6A 80       call CompareBuff.search
  59++819E A7             and a
  59++819F 20 15          jr nz, .mod
  60++81A1                  endif
  61++81A1              .checkExit
  62++81A1 E1               pop hl
  63++81A2              .downExit
  64++81A2 3E 01            ld a, MIME_DOWNLOAD
  64++81A4 C9             ret
  65++81A5              .page
  66++81A5 3E 02            ld a, MIME_LINK
  66++81A7 C9             ret
  67++81A8              .text
  68++81A8 3E 03            ld a, MIME_TEXT
  68++81AA C9             ret
  69++81AB              .input
  70++81AB 3E 04            ld a, MIME_INPUT
  70++81AD C9             ret
  71++81AE              .image
  72++81AE E1               pop hl
  72++81AF 3E 06          ld a, MIME_IMAGE
  72++81B1 C9             ret
  73++81B2              .music
  74++81B2 E1               pop hl
  74++81B3 3E 05          ld a, MIME_MUSIC
  74++81B5 C9             ret
  75++81B6              .mod
  76++81B6 E1               pop hl
  76++81B7 3E 07          ld a, MIME_MOD
  76++81B9 C9             ret
  77++81BA
  78++81BA 2E 73 63 72  scrExt1 db ".scr", 0
  78++81BE 00
  79++81BF 2E 53 43 52  scrExt2 db ".SCR", 0
  79++81C3 00
  80++81C4
  81++81C4 2E 70 74 33  pt3Ext1 db ".pt3", 0
  81++81C8 00
  82++81C9 2E 50 54 33  pt3Ext2 db ".PT3", 0
  82++81CD 00
  83++81CE 2E 70 74 32  pt2Ext1 db ".pt2", 0
  83++81D2 00
  84++81D3 2E 50 54 32  pt2Ext2 db ".PT2", 0
  84++81D7 00
  85++81D8
  86++81D8 2E 6D 6F 64  modExt1 db ".mod", 0
  86++81DC 00
  87++81DD 2E 4D 4F 44  modExt2 db ".MOD", 0
  87++81E1 00
  88++81E2
  89++81E2              toggleSaveMode
  90++81E2 F5           			push af
  91++81E3 CD DF 86     			call Console.waitForKeyUp
  92++81E6 3E 00        saveMode	ld a,0 ; Флаг Open/Save files
  93++81E8 EE 01        			xor 1
  94++81EA 32 E7 81     			ld (saveMode+1),a
  95++81ED F1           			pop af
  96++81EE C9           			ret
# file closed: gopher/render/row.asm
   5+ 81EF                  include "buffer.asm"
# file opened: gopher/render/buffer.asm
   1++81EF              ; B - line count
   2++81EF              findLine:
   3++81EF 21 3E A4         ld hl, outputBuffer
   4++81F2              findLine2:
   5++81F2 AF               xor a
   5++81F3 B0             or b
   5++81F4 28 1D          jr z, .checkEmpty
   6++81F6              .loop
   7++81F6 7E               ld a, (hl)
   7++81F7 A7             and a
   7++81F8 28 1C          jr z, .nope
   8++81FA FE 0D            cp 13
   8++81FC 23             inc hl
   8++81FD 28 0C          jr z, .checkLF
   9++81FF FE 0A            cp 10
   9++8201 28 02          jr z, .nextCheck
  10++8203 18 F1            jr .loop
  11++8205              .nextCheck
  12++8205 A7               and a
  12++8206 28 0E          jr z, .nope
  13++8208 10 EC            djnz .loop
  14++820A C9               ret
  15++820B              .checkLF
  16++820B 7E               ld a, (hl)
  17++820C FE 0A            cp 10
  17++820E 20 F5          jr nz, .nextCheck
  18++8210 23               inc hl
  19++8211 18 F2            jr  .nextCheck
  20++8213              .checkEmpty
  21++8213 7E               ld a, (hl)
  21++8214 A7             and a
  21++8215 C0             ret nz
  22++8216              .nope
  23++8216 21 00 00         ld hl, 0
  23++8219 C9             ret
# file closed: gopher/render/buffer.asm
   6+ 821A                  include "ui.asm"
# file opened: gopher/render/ui.asm
   1++821A              prepareScreen:
   2++821A CD 03 80         call TextMode.cls
   3++821D 21 46 83         ld hl, header
   3++8220 CD 1E 80       call TextMode.printZ
   4++8223 21 4A 82         ld hl, toolbox
   4++8226 CD 1E 80       call TextMode.printZ
   5++8229 21 67 9D         ld hl, hostName
   5++822C CD 1E 80       call TextMode.printZ
   6++822F 11 00 17         ld de, #1700
   6++8232 CD 07 80       call TextMode.gotoXY
   6++8235 21 56 82       ld hl, footer
   6++8238 CD 1E 80       call TextMode.printZ
   7++823B
   8++823B AF               xor a
   8++823C CD 16 80       call TextMode.highlightLine
   9++823F 3E 01            ld a, 1
   9++8241 CD 16 80       call TextMode.highlightLine
  10++8244 3E 17            ld a, #17
  10++8246 CD 16 80       call TextMode.highlightLine
  11++8249 C9               ret
  12++824A
  13++824A
  14++824A 20 5B 44 5D  toolbox db " [D]omain: ", 0
  14++824E 6F 6D 61 69
  14++8252 6E 3A 20 00
  15++8256 20 20 43 75  footer db "  Cursor - movement  [B]ack to prev. page  [H]ome page", 0
  15++825A 72 73 6F 72
  15++825E 20 2D 20 6D
  15++8262 6F 76 65 6D
  15++8266 65 6E 74 20
  15++826A 20 5B 42 5D
  15++826E 61 63 6B 20
  15++8272 74 6F 20 70
  15++8276 72 65 76 2E
  15++827A 20 70 61 67
  15++827E 65 20 20 5B
  15++8282 48 5D 6F 6D
  15++8286 65 20 70 61
  15++828A 67 65 00
  16++828D
  17++828D              inputHost:
  18++828D CD DF 86         call Console.waitForKeyUp
  19++8290              .loop
  20++8290 11 0B 01         ld de, #010B
  20++8293 CD 07 80       call TextMode.gotoXY
  20++8296 21 67 9D       ld hl, hostName
  20++8299 CD 1E 80       call TextMode.printZ
  21++829C 3E 04            ld a, MIME_INPUT
  21++829E CD 1C 80       call TextMode.putC
  22++82A1 3E 20            ld a, ' '
  22++82A3 CD 1C 80       call TextMode.putC
  23++82A6              .wait
  24++82A6 CD E8 86         call Console.getC
  25++82A9 5F               ld e, a
  26++82AA FE 0C            cp Console.BACKSPACE
  26++82AC 28 17          jr z, .removeChar
  27++82AE FE 0D            cp CR
  27++82B0 CA D3 82       jp z, inputNavigate
  28++82B3 FE 20            cp 32
  28++82B5 38 EF          jr c, .wait
  29++82B7              .putC
  30++82B7 AF               xor a
  30++82B8 21 67 9D 01    ld hl, hostName, bc, 48
  30++82BC 30 00
  30++82BE ED B1          cpir
  31++82C0 77               ld (hl), a
  31++82C1 2B             dec hl
  31++82C2 73             ld (hl), e
  32++82C3 18 CB            jr .loop
  33++82C5              .removeChar
  34++82C5 AF               xor a
  35++82C6 21 67 9D 01      ld hl, hostName, bc, 48
  35++82CA 30 00
  35++82CC ED B1          cpir
  36++82CE 2B               dec hl
  36++82CF 2B             dec hl
  36++82D0 77             ld (hl), a
  37++82D1 18 BD            jr .loop
  38++82D3
  39++82D3              inputNavigate:
  40++82D3 21 67 9D 11      ld hl, hostName, de, domain
  40++82D7 06 83
  41++82D9 7E               ld a,(hl)
  42++82DA A7               and a
  43++82DB CA 0C 87         jp z, History.load
  44++82DE              .loop
  45++82DE 7E               ld a, (hl)
  45++82DF A7             and a
  45++82E0 28 05          jr z, .complete
  46++82E2 12               ld (de), a
  46++82E3 23 13          inc hl, de
  47++82E5 18 F7            jr .loop
  48++82E7              .complete
  49++82E7 3E 09            ld a, TAB
  49++82E9 12             ld (de), a
  49++82EA 13             inc de
  50++82EB 3E 37            ld a, '7'
  50++82ED 12             ld (de), a
  50++82EE 13             inc de
  51++82EF 3E 30            ld a, '0'
  51++82F1 12             ld (de), a
  51++82F2 13             inc de
  52++82F3 3E 0D            ld a, CR
  52++82F5 12             ld (de), a
  52++82F6 13             inc de
  53++82F7 3E 0A            ld a, LF
  53++82F9 12             ld (de), a
  53++82FA 13             inc de
  54++82FB 21 01 83         ld hl, navRow
  54++82FE C3 61 87       jp History.navigate
  55++8301
  56++8301 31 20 09 2F  navRow db "1 ", TAB, "/", TAB
  56++8305 09
  57++8306 6E 69 68 69  domain db "nihirash.net"
  57++830A 72 61 73 68
  57++830E 2E 6E 65 74
  58++8312 00 00 00...      ds 64 - ($ - domain)
  59++8346
  60++8346                  IFDEF MB03
  61++8346 ~            header db "      Moon Rabbit "
  62++8346 ~                   db VERSION_STRING
  63++8346 ~                   db " for MB03+  (c) 2021 Alexander Nihirash",13, 0
  64++8346                  ENDIF
  65++8346
  66++8346                  IFDEF UNO
  67++8346 ~            header db "      Moon Rabbit "
  68++8346 ~                   db VERSION_STRING
  69++8346 ~                   db " for ZX-Uno (c) 2021 Alexander Nihirash",13, 0
  70++8346                  ENDIF
  71++8346
  72++8346                  IFDEF AY
  73++8346 ~            header db "      Moon Rabbit "
  74++8346 ~                   db VERSION_STRING
  75++8346 ~                   db " for AYWIFI (c) 2021 Alexander Nihirash",13, 0
  76++8346                  ENDIF
  77++8346
  78++8346                  IFDEF ZW
  79++8346 20 20 20 20  header db "      Moon Rabbit "
  79++834A 20 20 4D 6F
  79++834E 6F 6E 20 52
  79++8352 61 62 62 69
  79++8356 74 20
  80++8358 31 2E 36            db "1.6"
  81++835B 20 66 6F 72         db " for ZX WiFi (c) 2021 Alexander Nihirash",13, 0
  81++835F 20 5A 58 20
  81++8363 57 69 46 69
  81++8367 20 28 63 29
  81++836B 20 32 30 32
  81++836F 31 20 41 6C
  81++8373 65 78 61 6E
  81++8377 64 65 72 20
  81++837B 4E 69 68 69
  81++837F 72 61 73 68
  81++8383 0D 00
  82++8385                  ENDIF
# file closed: gopher/render/ui.asm
   7+ 8385                  include "gopher-page.asm"
# file opened: gopher/render/gopher-page.asm
   1++8385              renderGopherScreen:
   2++8385 CD 1A 82         call Render.prepareScreen
   3++8388
   4++8388              	;поиск и печать первой нужной строки
   5++8388 3A 75 8B         ld a, (page_offset)
   5++838B 47             ld b, a
   5++838C CD EF 81       call findLine ;поиск с начала буфера
   6++838F 7C               ld a, h
   6++8390 B5             or l
   6++8391 28 1F          jr z, .exit2
   7++8393 AF               xor a
   7++8394 E5             push hl
   7++8395 CD F1 80       call renderRow
   7++8398 E1             pop hl ;печать строки 0
   8++8399              	;теперь поиск продолжается
   9++8399
  10++8399 06 12            ld b, PER_PAGE-1 ;одну строку уже обработали
  11++839B              .loop
  12++839B C5               push bc
  13++839C 3E 13            ld a, PER_PAGE
  13++839E 90             sub b
  14++839F 5F               ld e, a
  14++83A0 06 01          ld b, 1
  14++83A2 CD F2 81       call findLine2 ;поиск одной следующей
  15++83A5 7C               ld a, h
  15++83A6 B5             or l
  15++83A7 28 06          jr z, .exit
  16++83A9 7B               ld a, e
  16++83AA E5             push hl
  16++83AB CD F1 80       call renderRow
  16++83AE E1             pop hl ;указатель hl надо сохранить
  17++83AF              .exit
  18++83AF C1               pop bc
  19++83B0 10 E9            djnz .loop
  20++83B2              .exit2
  21++83B2 CD 91 84         call showCursor
  22++83B5 C9               ret
  23++83B6
  24++83B6              checkBorder:
  25++83B6 3A 76 8B         ld a, (cursor_position)
  25++83B9 FE FF          cp #ff
  25++83BB CA B5 84       jp z, pageUp
  26++83BE 3A 76 8B         ld a, (cursor_position)
  26++83C1 FE 13          cp PER_PAGE
  26++83C3 CA D8 84       jp z, pageDn
  27++83C6 CD 91 84         call showCursor
  28++83C9 C3 CC 83         jp workLoop
  29++83CC
  30++83CC              workLoop:
  31++83CC 3A 8B 85         ld a, (play_next)
  31++83CF A7             and a
  31++83D0 C2 4A 84       jp nz, navigate
  32++83D3
  33++83D3                  ; dup 4
  34++83D3                  ; halt
  35++83D3                  ; edup
  36++83D3              .nothing
  37++83D3              	OS_WAIT
  37++83D3 DF          >	rst #18
  38++83D4 CD 93 A2     	call printRTC
  39++83D7 CD F1 86         call Console.peekC
  40++83DA FE FF            cp 255
  40++83DC 28 F5          jr z, .nothing
  41++83DE
  42++83DE FE 0A            cp Console.KEY_DN
  42++83E0 CA A1 84       jp z, cursorDown
  43++83E3 FE 61            cp 'a'
  43++83E5 CA A1 84       jp z, cursorDown
  44++83E8 FE 0B            cp Console.KEY_UP
  44++83EA CA AB 84       jp z, cursorUp
  45++83ED FE 71            cp 'q'
  45++83EF CA AB 84       jp z, cursorUp
  46++83F2 FE 08            cp Console.KEY_LT
  46++83F4 CA B5 84       jp z, pageUp
  47++83F7 FE 6F            cp 'o'
  47++83F9 CA B5 84       jp z, pageUp
  48++83FC FE 09            cp Console.KEY_RT
  48++83FE CA D8 84       jp z, pageDn
  49++8401 FE 70            cp 'p'
  49++8403 CA D8 84       jp z, pageDn
  50++8406
  51++8406 FE 68            cp 'h'
  51++8408 CA 5E 87       jp z, History.home
  52++840B FE 48            cp 'H'
  52++840D CA 5E 87       jp z, History.home
  53++8410
  54++8410 FE 62            cp 'b'
  54++8412 CA F5 86       jp z, History.back
  55++8415 FE 42            cp 'B'
  55++8417 CA F5 86       jp z, History.back
  56++841A FE 0C            cp Console.BACKSPACE
  56++841C CA F5 86       jp z, History.back
  57++841F
  58++841F FE 64            cp 'd'
  58++8421 CA 8D 82       jp z, inputHost
  59++8424 FE 44            cp 'D'
  59++8426 CA 8D 82       jp z, inputHost
  60++8429
  61++8429 FE 0D            cp CR
  61++842B CA 4A 84       jp z, navigate
  62++842E
  63++842E                  ifdef GS
  64++842E FE 4D            cp 'M'
  64++8430 CC 2E A4       call z, GeneralSound.toggleModule
  65++8433 FE 6D            cp 'm'
  65++8435 CC 2E A4       call z, GeneralSound.toggleModule
  66++8438                  endif
  67++8438
  68++8438 FE 53        	cp 'S'
  68++843A CC E2 81       call z, toggleSaveMode
  69++843D FE 73        	cp 's'
  69++843F CC E2 81       call z, toggleSaveMode
  70++8442
  71++8442 FE 18        	cp 24
  72++8444 CA 3A A4     	jp z,exit_dos
  73++8447
  74++8447 C3 CC 83         jp workLoop
  75++844A
  76++844A              navigate:
  77++844A CD DF 86         call Console.waitForKeyUp
  78++844D AF               xor a
  78++844E 32 8B 85       ld (play_next), a
  79++8451
  80++8451 CD 99 84         call hideCursor
  81++8454 3A 75 8B 47      ld a, (page_offset), b, a, a, (cursor_position)
  81++8458 3A 76 8B
  81++845B 80             add b
  81++845C 47             ld b, a
  81++845D CD EF 81       call Render.findLine
  82++8460 7E               ld a, (hl)
  83++8461 FE 31            cp '1'
  83++8463 CA 7B 84       jp z, .load
  84++8466 FE 30            cp '0'
  84++8468 CA 7B 84       jp z, .load
  85++846B FE 39            cp '9'
  85++846D CA 7B 84       jp z, .load
  86++8470 FE 37            cp '7'
  86++8472 CA 83 84       jp z, .input
  87++8475 CD 91 84         call showCursor
  88++8478 C3 CC 83         jp workLoop
  89++847B              .load
  90++847B E5               push hl
  91++847C CD 06 81         call getIcon
  92++847F E1               pop hl
  93++8480 C3 61 87         jp History.navigate
  94++8483              .input
  95++8483 E5               push hl
  96++8484 CD 8C 85         call DialogBox.inputBox
  97++8487 E1               pop hl
  98++8488 3A E1 85         ld a, (DialogBox.inputBuffer)
  98++848B A7             and a
  98++848C CA 0C 87       jp z, History.load
  99++848F 18 EA            jr .load
 100++8491
 101++8491              showCursor:
 102++8491 3A 76 8B         ld a, (cursor_position)
 102++8494 C6 03          add CURSOR_OFFSET
 103++8496 C3 16 80         jp TextMode.highlightLine
 104++8499
 105++8499              hideCursor:
 106++8499 3A 76 8B         ld a, (cursor_position)
 106++849C C6 03          add CURSOR_OFFSET
 107++849E C3 10 80         jp TextMode.usualLine
 108++84A1
 109++84A1              cursorDown:
 110++84A1 CD 99 84         call hideCursor
 111++84A4 21 76 8B         ld hl, cursor_position
 112++84A7 34               inc (hl)
 113++84A8 C3 B6 83         jp checkBorder
 114++84AB
 115++84AB              cursorUp:
 116++84AB CD 99 84         call hideCursor
 117++84AE 21 76 8B         ld hl, cursor_position
 118++84B1 35               dec (hl)
 119++84B2 C3 B6 83         jp checkBorder
 120++84B5
 121++84B5              pageUp:
 122++84B5 3A 75 8B         ld a, (page_offset)
 122++84B8 A7             and a
 122++84B9 28 13          jr z, .skip
 123++84BB 3E 12            ld a, PER_PAGE - 1
 123++84BD 32 76 8B       ld (cursor_position), a
 124++84C0 3A 75 8B         ld a, (page_offset)
 124++84C3 D6 13          sub PER_PAGE
 124++84C5 32 75 8B       ld (page_offset), a
 125++84C8              .exit
 126++84C8 CD 85 83         call renderGopherScreen
 127++84CB C3 CC 83         jp workLoop
 128++84CE              .skip
 129++84CE AF               xor a
 129++84CF 32 76 8B       ld (cursor_position), a
 129++84D2 CD 85 83       call renderGopherScreen
 129++84D5 C3 CC 83       jp workLoop
 130++84D8
 131++84D8              pageDn:
 132++84D8 AF               xor a
 132++84D9 32 76 8B       ld (cursor_position), a
 133++84DC 3A 75 8B         ld a, (page_offset)
 133++84DF C6 13          add PER_PAGE
 133++84E1 32 75 8B       ld (page_offset), a
 134++84E4 18 E2            jr pageUp.exit
# file closed: gopher/render/gopher-page.asm
   8+ 84E6                  include "plaintext.asm"
# file opened: gopher/render/plaintext.asm
   1++84E6              renderPlainTextScreen:
   2++84E6 CD 1A 82         call prepareScreen
   3++84E9
   4++84E9              	;поиск и печать первой нужной строки
   5++84E9 3A 75 8B         ld a, (page_offset)
   5++84EC 47             ld b, a
   5++84ED CD EF 81       call findLine ;поиск с начала буфера
   6++84F0 7C               ld a, h
   6++84F1 B5             or l
   6++84F2 28 2D          jr z, .exit2
   7++84F4 AF               xor a
   8++84F5 C6 03            add CURSOR_OFFSET
   8++84F7 57 1E 01       ld d, a, e, 1
   8++84FA CD 07 80       call TextMode.gotoXY
   9++84FD CD C0 80         call print70Text
  10++8500              	;теперь поиск продолжается
  11++8500
  12++8500 06 12            ld b, PER_PAGE-1
  13++8502              .loop
  14++8502 C5               push bc
  15++8503 3E 13            ld a, PER_PAGE
  15++8505 90             sub b
  16++8506 5F               ld e, a
  16++8507 06 01          ld b, 1
  16++8509 CD F2 81       call Render.findLine2
  17++850C 7C               ld a, h
  17++850D B5             or l
  17++850E 28 10          jr z, .exit
  18++8510 7B               ld a, e
  19++8511 C6 03            add CURSOR_OFFSET
  19++8513 57 1E 01       ld d, a, e, 1
  19++8516 CD 07 80       call TextMode.gotoXY
  20++8519 CD C0 80         call print70Text
  21++851C C1               pop bc
  22++851D 10 E3            djnz .loop
  23++851F C9               ret
  24++8520              .exit
  25++8520 C1               pop bc
  26++8521              .exit2
  27++8521 C9               ret
  28++8522
  29++8522              plainTextLoop:
  30++8522 CD E8 86         call Console.getC
  31++8525
  32++8525 FE 0A            cp Console.KEY_DN
  32++8527 CA 6D 85       jp z, textDown
  33++852A FE 61            cp 'a'
  33++852C CA 6D 85       jp z, textDown
  34++852F
  35++852F FE 0B            cp Console.KEY_UP
  35++8531 CA 7B 85       jp z, textUp
  36++8534 FE 71            cp 'q'
  36++8536 CA 7B 85       jp z, textUp
  37++8539
  38++8539 FE 68            cp 'h'
  38++853B CA 5E 87       jp z, History.home
  39++853E FE 48            cp 'H'
  39++8540 CA 5E 87       jp z, History.home
  40++8543
  41++8543 FE 62            cp 'b'
  41++8545 CA F5 86       jp z, History.back
  42++8548 FE 42            cp 'B'
  42++854A CA F5 86       jp z, History.back
  43++854D
  44++854D FE 0C            cp Console.BACKSPACE
  44++854F CA F5 86       jp z, History.back
  45++8552
  46++8552                  ifdef GS
  47++8552 FE 4D            cp 'M'
  47++8554 CC 2E A4       call z, GeneralSound.toggleModule
  48++8557 FE 6D            cp 'm'
  48++8559 CC 2E A4       call z, GeneralSound.toggleModule
  49++855C                  endif
  50++855C
  51++855C FE 53            cp 'S'
  51++855E CC E2 81       call z, toggleSaveMode
  52++8561 FE 73        	cp 's'
  52++8563 CC E2 81       call z, toggleSaveMode
  53++8566
  54++8566 FE 18        	cp 24
  55++8568 CA 3A A4     	jp z,exit_dos
  56++856B
  57++856B 18 B5            jr plainTextLoop
  58++856D
  59++856D
  60++856D              textDown:
  61++856D 3A 75 8B         ld a, (page_offset)
  61++8570 C6 13          add PER_PAGE
  61++8572 32 75 8B       ld (page_offset), a
  62++8575 CD E6 84         call renderPlainTextScreen
  63++8578 C3 22 85         jp plainTextLoop
  64++857B
  65++857B              textUp:
  66++857B 21 75 8B         ld hl, page_offset
  67++857E 7E               ld a, (hl)
  67++857F A7             and a
  67++8580 28 A0          jr z, plainTextLoop
  68++8582 D6 13            sub PER_PAGE
  68++8584 77             ld (hl), a
  69++8585 CD E6 84         call renderPlainTextScreen
  70++8588 C3 22 85         jp plainTextLoop
# file closed: gopher/render/plaintext.asm
   9+ 858B
  10+ 858B 00           play_next       db  0
  11+ 858C              position        EQU historyBlock.position
  12+ 858C              cursor_position EQU position + 1
  13+ 858C              page_offset     EQU position
  14+ 858C                  ENDMODULE
  15+ 858C
  16+ 858C                  include "dialogbox.asm"
# file opened: gopher/render/dialogbox.asm
   1++858C                  module DialogBox
   2++858C
   3++858C              inputBox:
   4++858C AF               xor a
   4++858D 32 E1 85       ld (inputBuffer), a
   5++8590              .noclear
   6++8590 CD 42 86         call drawBox
   7++8593              .loop
   8++8593 11 05 0B         ld de, #0B05
   8++8596 CD 07 80       call TextMode.gotoXY
   9++8599 21 E1 85         ld hl, inputBuffer
   9++859C CD 1E 80       call TextMode.printZ
  10++859F 3E 04            ld a, MIME_INPUT
  10++85A1 CD 1C 80       call TextMode.putC
  10++85A4 3E 20          ld a, ' '
  10++85A6 CD 1C 80       call TextMode.putC
  11++85A9              .checkkey
  12++85A9 CD E8 86         call Console.getC
  13++85AC FE 0C            cp Console.BACKSPACE
  13++85AE 28 16          jr z, .removeChar
  14++85B0 FE 0D            cp CR
  14++85B2 C8             ret z
  15++85B3 FE 20            cp SPACE
  15++85B5 38 F2          jr c, .checkkey
  16++85B7              .putC
  17++85B7 5F               ld e, a
  18++85B8 AF               xor a
  18++85B9 21 E1 85 01    ld hl, inputBuffer, bc, #ff
  18++85BD FF 00
  18++85BF ED B1          cpir
  19++85C1 77               ld (hl), a
  19++85C2 2B             dec hl
  19++85C3 73             ld (hl), e
  20++85C4 18 CD            jr .loop
  21++85C6              .removeChar
  22++85C6 AF               xor a
  23++85C7 21 E1 85 01      ld hl, inputBuffer, bc, #ff
  23++85CB FF 00
  23++85CD ED B1          cpir
  24++85CF E5               push hl
  25++85D0 11 E2 85             ld de, inputBuffer + 1
  26++85D3 B7                   or a
  26++85D4 ED 52          sbc hl, de
  27++85D6 7C                   ld a, h
  27++85D7 B5             or l
  28++85D8 E1               pop hl
  29++85D9 28 B8            jr z, .loop
  30++85DB AF               xor a
  31++85DC 2B               dec hl
  31++85DD 2B             dec hl
  31++85DE 77             ld (hl), a
  32++85DF 18 B2            jr .loop
  33++85E1
  34++85E1 00 00 00...  inputBuffer ds 80
  35++8631
  36++8631              msgBox:
  37++8631 CD 3A 86         call msgNoWait
  38++8634 06 96            ld b, 150
  39++8636              .loop
  40++8636                  OS_WAIT
  40++8636 DF          >	rst #18
  41++8637 10 FD            djnz .loop
  42++8639 C9               ret
  43++863A
  44++863A              msgNoWait:
  45++863A E5               push hl
  46++863B CD 42 86         call drawBox
  47++863E E1               pop hl
  48++863F C3 1E 80         jp TextMode.printZ
  49++8642
  50++8642              drawBox:
  51++8642 26 0A 3E 09      ld h, #0A, a, BORDER_TOP
  51++8646 CD 0C 80       call TextMode.fillLine
  52++8649 26 0B 3E 20      ld h, #0B, a, ' '
  52++864D CD 0C 80       call TextMode.fillLine
  53++8650 26 0C 3E 08      ld h, #0C, a, BORDER_BOTTOM
  53++8654 CD 0C 80       call TextMode.fillLine
  54++8657
  55++8657                  IFNDEF TIMEX80
  56++8657 3E 0A            ld a, #0a
  56++8659 CD 16 80       call TextMode.highlightLine
  57++865C 3E 0C            ld a, #0c
  57++865E CD 16 80       call TextMode.highlightLine
  58++8661                  ENDIF
  59++8661
  60++8661 11 05 0B         ld de, #0B05
  60++8664 CD 07 80       call TextMode.gotoXY
  61++8667 C9               ret
  62++8668                  endmodule
  63++8668
# file closed: gopher/render/dialogbox.asm
# file closed: gopher/render/index.asm
  18  8668                  include "dos/index.asm"
# file opened: dos/index.asm
   1+ 8668                  IFDEF ESX
   2+ 8668 ~                include "esxdos.asm"
   3+ 8668              	ENDIF
   4+ 8668                  IFDEF TRD
   5+ 8668 ~                include "trdos.asm"
   6+ 8668              	ENDIF
   7+ 8668                  IFDEF ZSFAT
   8+ 8668                  include "zsfat.asm"
# file opened: dos/zsfat.asm
   1++8668              ;trdos driver (izzx)
   2++8668                  MODULE Dos
   3++8668              ; API methods
   4++8668              ESX_GETSETDRV = #89
   5++8668              ESX_FOPEN = #9A
   6++8668              ESX_FCLOSE = #9B
   7++8668              ESX_FSYNC = #9C
   8++8668              ESX_FREAD = #9D
   9++8668              ESX_FWRITE = #9E
  10++8668
  11++8668              ; File modes
  12++8668              FMODE_READ = #01
  13++8668              FMODE_WRITE = #06
  14++8668              FMODE_CREATE = #0E
  15++8668
  16++8668                  ; MACRO esxCall func
  17++8668                  ; rst #8 : db func
  18++8668                  ; ENDM
  19++8668
  20++8668              ;макросы модуля
  21++8668              ;
  22++8668              ;R8DOS			вызов функции R8DOS
  23++8668              ;R8FAT			вызов функции R8FAT
  24++8668              ;R8DOSc			вызов функции R8DOS
  25++8668              ;
  26++8668              ;------------------------------------------------------------------------------
  27++8668              ;вызов функции R8DOS
  28++8668              ;вх: =0 номер функции
  29++8668              ;
  30++8668              	; MACRO	R8DOS nFunc
  31++8668              	; ld	c,nFunc
  32++8668              	; rst	#08
  33++8668              	; db	#81
  34++8668              	; ENDM
  35++8668
  36++8668              ; ;------------------------------------------------------------------------------
  37++8668              ; ;вызов функции R8FAT
  38++8668              ; ;вх: =0 номер функции
  39++8668              ; ;
  40++8668              	; MACRO	R8FAT nFunc
  41++8668              	; ld	c,nFunc
  42++8668              	; rst	#08
  43++8668              	; db	#91
  44++8668              	; ENDM
  45++8668
  46++8668              ; ;------------------------------------------------------------------------------
  47++8668              ; ;вызов функции R8DOS
  48++8668              ; ;вх: c - номер функции
  49++8668              ; ;
  50++8668              	; MACRO	R8DOSc
  51++8668              	; rst	#08
  52++8668              	; db	#81
  53++8668              	; ENDM
  54++8668
  55++8668              ; ;------------------------------------------------------------------------------
  56++8668              ; ;вызов функции #02 (FileMan) R8CONF
  57++8668              ; ;вх: =#00 - номер функции файл менеджера
  58++8668              ; ;
  59++8668              	; MACRO	R8C02FM nFunct
  60++8668              	; ld	bc,#100*nFunct+#02
  61++8668              	; rst	#08
  62++8668              	; db	#8E
  63++8668              	; ENDM
  64++8668
  65++8668              ;==============================================================================
  66++8668              ; r8f00_DeinitFAT		equ #00
  67++8668              ; r8f01_InitFAT		equ #01
  68++8668              ; r8f04_FindPath		equ #04
  69++8668              ; r8f07_FileOpen		equ #07 ;открыть файл для последующих операций с ним
  70++8668              ; r8f09_FileWrite		equ #09	;запись данных из памяти в файл
  71++8668              ; r8f0E_CreateFileLFN	equ #0E ;создание файла с длинным именем в текущем каталоге
  72++8668              ; r8f0F_CreateFileSFN	equ #0F
  73++8668
  74++8668              ; r8d2D_FindPart		equ #2D
  75++8668              ; r8d2E_CngHDD		equ #2E
  76++8668
  77++8668
  78++8668              ;id = 0 файл не открыт
  79++8668              ;id = 1 файл для чтения trdos
  80++8668              ;id = 2 файл для записи trdos
  81++8668              ;id = 3 файл для записи тип TRD trdos
  82++8668              ;id = 4 файл для записи тип SCL trdos
  83++8668              ;id = 5 файл для чтения fat32 (пока не сделано)
  84++8668              ;id = 6 файл для записи fat32
  85++8668
  86++8668              ; HL - filename in ASCIIZ
  87++8668              loadBuffer:
  88++8668 06 01            ld b, Dos.FMODE_READ
  88++866A CD 84 86       call Dos.fopen
  89++866D F5               push af
  90++866E 44           	ld b,h ;bc - длина
  91++866F 4D           	ld c,l ;
  92++8670 11 3E A4         ld de, outputBuffer
  93++8673 19           	add hl,de
  94++8674 30 03        	jr nc,loadBuffer1 ;если не превышает размер буфера
  95++8676 01 C1 5B     	ld bc, #ffff - outputBuffer ;или только размер буфера
  96++8679              loadBuffer1
  97++8679 21 3E A4     	ld hl, outputBuffer
  98++867C CD B5 86     	call Dos.fread
  99++867F              	;перед загрузкой буфер был очищен, поэтому можно в конце не ставить нули
 100++867F                  ;ld hl, outputBuffer : add hl, bc : xor a : ld (hl), a : inc hl : ld (hl), a
 101++867F F1               pop af
 102++8680 CD B1 86         call Dos.fclose
 103++8683 C9               ret
 104++8684
 105++8684
 106++8684              ; Returns:
 107++8684              ;  A - current drive
 108++8684              ; getDefaultDrive: ;нигде не используется
 109++8684                  ; ld a, 0 : esxCall ESX_GETSETDRV
 110++8684                  ; ret
 111++8684
 112++8684
 113++8684
 114++8684              ; Opens file on default drive
 115++8684              ; B - File mode
 116++8684              ; HL - File name
 117++8684              ; Returns:
 118++8684              ;  A - file stream id
 119++8684              fopen:
 120++8684                  ; push bc : push hl
 121++8684                  ; call getDefaultDrive
 122++8684                  ; pop ix : pop bc
 123++8684                  ; esxCall ESX_FOPEN
 124++8684                  ; ret
 125++8684 78           	ld a,b
 126++8685 FE 01        	cp FMODE_READ ;если режим открытие файла
 127++8687 28 06        	jr z,fopen_r
 128++8689 FE 0E        	cp FMODE_CREATE
 129++868B 28 12        	jr z,fopen_c ;если режим создание файла
 130++868D 18 0E        	jr fopen_err ;иначе выход
 131++868F
 132++868F              fopen_r	;открытие существующего файла на чтение (id=1)
 133++868F
 134++868F              	;call format_name ;
 135++868F
 136++868F              	;открыть папку системы по умолчанию
 137++868F E5           	push hl ;сохранить имя файла
 138++8690 21 C5 86     	ld hl,path_os ;папка системы
 139++8693 AF           	xor	a
 140++8694 3D           	dec	a ;установить текущим
 141++8695              	OS_FIND_PATH ;найти папку
 141++8695 0E 29       >    ld c,#29
 141++8697 E7          >    rst #20
 142++8698 E1           	pop hl
 143++8699
 144++8699              	OS_FILE_OPEN
 144++8699 0E 21       >    ld c,#21
 144++869B E7          >    rst #20
 145++869C C9           	ret
 146++869D              	; ld a,(#5D19) ;номер дисковода по умолчанию
 147++869D              	; ld 	(prev_drive),a ;запомним
 148++869D              			;call format_name ;
 149++869D              			; ld      c,#13 ;move file info to syst var
 150++869D                          ; call    call3d13
 151++869D                          ; ld      c,#0a ;find file
 152++869D                          ; call    call3d13
 153++869D                          ; ld      a,c
 154++869D              			; cp 		#ff
 155++869D              			; jr 		z,fopen_err ;если не нашли файла
 156++869D                          ; ld      c,#08 ;read file title
 157++869D                          ; call    call3d13
 158++869D                          ; ;ld      hl,loadadr ;куда
 159++869D                          ; ld      de,(#5ceb) ;начало файла сектор дорожка
 160++869D                          ; ld      (f_r_cur_trk),de
 161++869D
 162++869D                          ; ld      a,(#5cea)
 163++869D                          ; ld      (f_r_len_sec),a ;длина в секторах
 164++869D                          ; ;or      a
 165++869D                          ; ;ret     z    ;выход если пустой
 166++869D
 167++869D              			; ld de,(#5CE8) ; длина файла или программной части для BASIC
 168++869D              			; ld      (f_r_len),de
 169++869D
 170++869D                          ; ; ld      de,(fcurtrk) ;текущие сектор дорожка
 171++869D                          ; ; ld      (#5cf4),de ;восстановим
 172++869D              			; xor a
 173++869D              			; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 174++869D              			; ld 		a,1
 175++869D              			; ld (f_r_flag),a ;флаг что файл для чтения открыт
 176++869D              			; ;id канала будет 1
 177++869D              	;ret
 178++869D
 179++869D              fopen_err
 180++869D              	; ld a,1
 181++869D              	; ld (com_file_err_flag),a
 182++869D              	; xor a ;если никакой файл не открыли, то id = 0
 183++869D 37           	scf ;флаг ошибки
 184++869E C9           	ret
 185++869F
 186++869F
 187++869F              fopen_c	;создание нового файла (id=2-4,6)
 188++869F              	; ld a,(#5D19) ;номер дисковода по умолчанию
 189++869F              	; ld 	(prev_drive),a ;запомним
 190++869F
 191++869F              	;открыть папку загрузок, если есть
 192++869F E5           	push hl ;сохранить имя файла
 193++86A0 21 CA 86     	ld hl,path_download
 194++86A3 AF           	xor	a
 195++86A4 3D           	dec	a ;установить текущим
 196++86A5              	OS_FIND_PATH ;найти папку
 196++86A5 0E 29       >    ld c,#29
 196++86A7 E7          >    rst #20
 197++86A8 E1           	pop hl
 198++86A9
 199++86A9              	;call format_name ;
 200++86A9              	OS_FILE_OPEN ;если есть, откроем
 200++86A9 0E 21       >    ld c,#21
 200++86AB E7          >    rst #20
 201++86AC D0           	ret nc
 202++86AD
 203++86AD              	OS_FILE_CREATE ;или создадим
 203++86AD 0E 22       >    ld c,#22
 203++86AF E7          >    rst #20
 204++86B0 C9           	ret
 205++86B1
 206++86B1              	; call select_drive
 207++86B1              	; cp "y"
 208++86B1              	; jr nz,fopen_err
 209++86B1
 210++86B1              	; ld a,(curr_drive)
 211++86B1              	; cp 4
 212++86B1              	; jp nc,fopen_c_fat ;если выбран FAT
 213++86B1
 214++86B1              	; ;выясним, не образ ли это для разворачивания
 215++86B1                  ; ld hl, trdExt1 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 216++86B1                  ; ld hl, trdExt2 : call CompareBuff.search : and a : jr nz, fopen_c_trd
 217++86B1              	; ld hl, sclExt1 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 218++86B1                  ; ld hl, sclExt2 : call CompareBuff.search : and a : jp nz, fopen_c_scl
 219++86B1
 220++86B1
 221++86B1              	; ;создание произвольного файла (id=2)
 222++86B1              	; call cat_buf_cls
 223++86B1
 224++86B1              	; ld hl,cat_buf ;считаем каталог диска
 225++86B1              	; ld de,0
 226++86B1                  ; ld      bc,#0905 ;
 227++86B1                  ; call    call3d13
 228++86B1
 229++86B1              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 230++86B1              	; cp 128
 231++86B1              	; jp c,fopen_c2 ;если уже максимум
 232++86B1                  ; ld hl, file_err
 233++86B1                  ; call DialogBox.msgBox ;предуреждение
 234++86B1              	; jr fopen_err
 235++86B1
 236++86B1              ; fopen_c2
 237++86B1              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 238++86B1              	; ld a,h
 239++86B1              	; or l
 240++86B1              	; jr nz,fopen_c3 ;если ещё есть место
 241++86B1                  ; ld hl, file_err
 242++86B1                  ; call DialogBox.msgBox ;предуреждение
 243++86B1              	; jr fopen_err
 244++86B1
 245++86B1              ; fopen_c3
 246++86B1              	; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 247++86B1                  ; ld   (#5cf4),de ;отсюда будем писать файл
 248++86B1
 249++86B1              	; xor a
 250++86B1              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 251++86B1              	; ld (sec_shift),a ;переменная
 252++86B1              	; ld hl,0
 253++86B1              	; ld (f_w_len+0),hl
 254++86B1              	; ld (f_w_len+2),hl
 255++86B1              	; ld a,2 ;id канала
 256++86B1              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 257++86B1              	; ret
 258++86B1
 259++86B1
 260++86B1              ; cat_buf_cls ;очистка буфера каталога
 261++86B1              	; ld hl,cat_buf ;очистить место для каталога дискеты
 262++86B1              	; ld de,cat_buf+1
 263++86B1              	; ld (hl),0
 264++86B1              	; ld bc,9*256-1
 265++86B1              	; ldir
 266++86B1              	; ret
 267++86B1
 268++86B1
 269++86B1
 270++86B1              ; fopen_c_trd	;открытие файла для разворачивания образа trd (id=3)
 271++86B1              	; call select_drive
 272++86B1              	; cp "y"
 273++86B1              	; jp nz,fopen_err
 274++86B1
 275++86B1              	; ld      de,0 ;начало сектор дорожка
 276++86B1                  ; ld      (#5cf4),de
 277++86B1
 278++86B1              	; xor a
 279++86B1              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 280++86B1              	; ld (sec_shift),a ;переменная
 281++86B1              	; ld hl,0
 282++86B1              	; ld (f_w_len+0),hl
 283++86B1              	; ld (f_w_len+2),hl
 284++86B1              	; ld a,3 ;id канала
 285++86B1              	; ld (f_w_flag),a ;флаг что trd для записи открыт
 286++86B1              	; ret
 287++86B1
 288++86B1
 289++86B1
 290++86B1              ; fopen_c_scl	;открытие файла для разворачивания образа scl (id=4)
 291++86B1              	; call select_drive
 292++86B1              	; cp "y"
 293++86B1              	; jp nz,fopen_err
 294++86B1
 295++86B1              	; ld      de,0 ;начало сектор дорожка
 296++86B1                  ; ld      (#5cf4),de
 297++86B1
 298++86B1              	; call cat_buf_cls ;почистить место
 299++86B1
 300++86B1              	; call scl_parse ;запуск цикла сборки образа
 301++86B1
 302++86B1              	; xor a
 303++86B1              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 304++86B1              	; ld (sec_shift),a ;переменная
 305++86B1              	; ;ld (scl_que),a
 306++86B1              	; ld hl,0
 307++86B1              	; ld (f_w_len+0),hl
 308++86B1              	; ld (f_w_len+2),hl
 309++86B1              	; ld a,4 ;id канала
 310++86B1              	; ld (f_w_flag),a ;флаг что scl для записи открыт
 311++86B1              	; ret
 312++86B1
 313++86B1
 314++86B1
 315++86B1
 316++86B1              ; fopen_c_fat	;создание файла FAT (id=6)
 317++86B1
 318++86B1              ; ;переинициализация FAT раздела
 319++86B1              	; R8FAT	r8f00_DeinitFAT
 320++86B1              	; jp 		c,fopen_err
 321++86B1
 322++86B1              	; ld a,(curr_drive)
 323++86B1              	; ld bc,typeDrive-4
 324++86B1              	; ld l,a
 325++86B1              	; ld h,0
 326++86B1              	; add hl,bc
 327++86B1              	; ld a,(hl) ;получили код раздела из списка
 328++86B1              	; rlca
 329++86B1              	; rlca
 330++86B1              	; rlca
 331++86B1              	; rlca
 332++86B1              	; and %11110000
 333++86B1                  ; ;         ld      a,%0000????
 334++86B1                                     ; ; ││└┴─── номер раздела
 335++86B1                                     ; ; │└───── master/slave для Hdd
 336++86B1                                     ; ; └────── SD/Hdd
 337++86B1              	; R8FAT	r8f01_InitFAT
 338++86B1                  ; jp      c,fopen_err
 339++86B1
 340++86B1              ; ;поиск пути в разделе
 341++86B1              	; ld	hl,ActPathFAT		;путь к каталогу Download
 342++86B1              	; ld	de,fcb
 343++86B1              	; xor	a
 344++86B1              	; dec	a
 345++86B1              	; R8FAT	r8f04_FindPath
 346++86B1                  ; ;jp      c,fopen_err ;если не нашли, файл будет в корне
 347++86B1
 348++86B1              	; ld	hl,(temp_hl)		;строка с именем
 349++86B1              	; ld	de,fcb
 350++86B1              	; R8FAT r8f07_FileOpen
 351++86B1              	; jp 	nc,fopen_c_fat2 ;если файл есть, откроем
 352++86B1
 353++86B1              ; ;создание файла, если нет
 354++86B1              	; ld	hl,(temp_hl)		;строка с именем
 355++86B1              	; xor	a
 356++86B1              	; ld	(fcb+#14+0),a
 357++86B1              	; ld	(fcb+#14+1),a
 358++86B1              	; ld	(fcb+#14+2),a	;установим размер
 359++86B1              	; ld	(fcb+#14+3),a
 360++86B1              	; ld	de,fcb
 361++86B1              	; R8FAT	r8f0E_CreateFileLFN	;создание файла
 362++86B1              	; jp 	c,fopen_err
 363++86B1
 364++86B1              ; fopen_c_fat2
 365++86B1
 366++86B1              	; ld hl,0
 367++86B1              	; ld (f_w_len+0),hl
 368++86B1              	; ld (f_w_len+2),hl
 369++86B1              	; xor a
 370++86B1              	; ld (com_file_err_flag),a ;флаг что пока ошибок нет
 371++86B1              	; ld a,6 ;id канала
 372++86B1              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 373++86B1              	; ret
 374++86B1
 375++86B1
 376++86B1
 377++86B1
 378++86B1
 379++86B1              ; select_drive	;запрос номера дисковода
 380++86B1              	; ld a,(hdd_init_flag) ;если в первый раз
 381++86B1              	; or a
 382++86B1              	; jr nz,select_drive2
 383++86B1              	; ld a,(#5D19) ;номер дисковода по умолчанию
 384++86B1              	; ld (curr_drive),a
 385++86B1              	; call GetNumPart ;узнаем какая буква последняя, сколько разделов ФАТ
 386++86B1              	; add "D"
 387++86B1              	; ld (write_ima_e),a	;выбор до этой буквы
 388++86B1              	; sub "D"
 389++86B1              	; inc a
 390++86B1              	; add "d"
 391++86B1              	; ld (next_lett),a ;эта буква первая свободная
 392++86B1              	; ld a,1
 393++86B1              	; ld (hdd_init_flag),a
 394++86B1              ; select_drive2
 395++86B1              	; ld a,(curr_drive) ;номер дисковода по умолчанию
 396++86B1              	; add a,"A"
 397++86B1              	; ld (write_ima_d),a ;подставим букву в запросе
 398++86B1                  ; ld hl, write_ima
 399++86B1                  ; call DialogBox.msgNoWait ;текст запроса
 400++86B1              ; select_drive_wait
 401++86B1              	; ;halt
 402++86B1              	; call Console.getC
 403++86B1              	; cp 255
 404++86B1              	; JR Z,select_drive_wait	;ждём любую клавишу
 405++86B1              	; cp "y"
 406++86B1              	; jr z,select_drive_ex
 407++86B1              	; cp "n"
 408++86B1              	; ret z
 409++86B1              	; cp "a" ;от буквы A
 410++86B1              	; jr c,select_drive_wait
 411++86B1              	; ld hl,next_lett
 412++86B1              	; cp (hl) ;до первой свободной буквы
 413++86B1              	; jr nc,select_drive_wait
 414++86B1              	; sub "a"
 415++86B1              	; ld (curr_drive),a ;новый номер диска
 416++86B1              	; jr select_drive2 ;обновить строку
 417++86B1              ; select_drive_ex ;выход
 418++86B1              	; ld a,(curr_drive)
 419++86B1              	; cp 4 ;начиная с буквы E идёт HDD
 420++86B1              	; jr nc,select_drive3
 421++86B1                  ; ld      (#5d19) ,a ;если дискета, настроим trdos
 422++86B1                  ; ld      c,1
 423++86B1                  ; call    call3d13
 424++86B1                  ; ld      c,#18
 425++86B1                  ; call    call3d13
 426++86B1              ; select_drive3
 427++86B1              	; ld a,"y"
 428++86B1              	; ret
 429++86B1
 430++86B1
 431++86B1              ; ; restore_drive ;восстановить дисковод по умолчанию
 432++86B1              	; ; ld 	a,(prev_drive)
 433++86B1                  ; ; ld      (#5d19) ,a
 434++86B1                  ; ; ld      c,1
 435++86B1                  ; ; call    call3d13
 436++86B1                  ; ; ld      c,#18
 437++86B1                  ; ; call    call3d13
 438++86B1              	; ; ret
 439++86B1
 440++86B1
 441++86B1              ; call3d13 ;фикс для GMX
 442++86B1              	; ifndef ZSGMX
 443++86B1                  ; jp    #3d13
 444++86B1              	; endif
 445++86B1
 446++86B1              	; ; ifdef ZSGMX
 447++86B1                  ; ; call    #3d13
 448++86B1              	; ; exx
 449++86B1              	; ; call TextMode.gmxscron
 450++86B1              	; ; exx
 451++86B1              	; ; endif
 452++86B1              	; ret
 453++86B1
 454++86B1
 455++86B1
 456++86B1              ; A - file stream id
 457++86B1              fclose:
 458++86B1              	OS_FILE_CLOSE
 458++86B1 0E 25       >    ld c,#25
 458++86B3 E7          >    rst #20
 459++86B4 C9           	ret
 460++86B5
 461++86B5                  ; ;esxCall ESX_FCLOSE
 462++86B5              	; ; push af
 463++86B5              	; ; pop af
 464++86B5              	; cp 2 ;если обычный файл
 465++86B5              	; jp nz,fclose_scl
 466++86B5
 467++86B5              	; ;дописать остаток файла
 468++86B5              	; ld a,(write_end_flag) ;нужно записывать остаток?
 469++86B5              	; or a
 470++86B5              	; jr nz,fclose_f ;не нужно
 471++86B5
 472++86B5              	; ld hl,sec_buf
 473++86B5              	; ld bc,#0106
 474++86B5              	; ld de,(#5cf4)
 475++86B5              	; call call3d13
 476++86B5
 477++86B5              	; ld a,"0" ;номер части файла
 478++86B5              	; ld (file_num),a
 479++86B5
 480++86B5              ; fclose_f ;поправить каталог
 481++86B5              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 482++86B5              	; ld hl,(f_w_len+0)
 483++86B5              	; or h
 484++86B5              	; or l
 485++86B5              	; jp z,fclose_ex ;выход если длина 0
 486++86B5
 487++86B5              	; ;проверки на заполнение
 488++86B5              	; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 489++86B5              	; cp 128
 490++86B5              	; jp nc,fclose_ex ;если уже максимум
 491++86B5              	; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 492++86B5              	; ld a,h
 493++86B5              	; or l
 494++86B5              	; jp z,fclose_ex ;если места нет
 495++86B5
 496++86B5              	; ld a,(f_w_len+2) ;самый старший байт длины файла
 497++86B5              	; or a
 498++86B5              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 499++86B5              	; ld a,(f_w_len+1)
 500++86B5              	; cp 255
 501++86B5              	; jr nz,fclose_f1
 502++86B5              	; ld a,(f_w_len+0)
 503++86B5              	; jr nz,fclose_f_multi ;если файл больше 255 секторов (65280)
 504++86B5              ; fclose_f1
 505++86B5              	; ;файл не превышает максимальный размер для trdos
 506++86B5              	; ld de,(f_w_len+0)
 507++86B5              	; ld hl,f_name+11 ;длина файла
 508++86B5              	; ld (hl),e
 509++86B5              	; inc hl
 510++86B5              	; ld (hl),d
 511++86B5              	; inc hl
 512++86B5              	; ld a,(f_w_len+1) ;длина секторов
 513++86B5              	; ld (hl),a
 514++86B5              	; ld a,(f_w_len+0) ;длина младший
 515++86B5              	; or a
 516++86B5              	; jr z,fclose_f2
 517++86B5              	; inc (hl) ;коррекция секторов
 518++86B5              ; fclose_f2
 519++86B5              	; call fclose_f_one ;записать информацию
 520++86B5              	; jp fclose_ex ;готово
 521++86B5
 522++86B5              ; fclose_f_multi ;файл большой, будет несколько записей в каталоге
 523++86B5              	; ld a,(file_num)
 524++86B5              	; ld (f_name+7),a ;в конце имени номер
 525++86B5
 526++86B5              	; ld hl,f_name+11 ;длина файла
 527++86B5              	; ld (hl),0
 528++86B5              	; inc hl
 529++86B5              	; ld (hl),#ff ;65280
 530++86B5              	; inc hl
 531++86B5              	; ;длина секторов
 532++86B5              	; ld (hl),#ff
 533++86B5              	; call fclose_f_one ;записать информацию
 534++86B5
 535++86B5              	; ;вычесть длину записанного
 536++86B5              	; ld hl,(f_w_len+1) ;старший и средний байт
 537++86B5              	; ld bc,255
 538++86B5              	; and a
 539++86B5              	; sbc hl,bc ;вычесть 255 секторов
 540++86B5              	; ld (f_w_len+1),hl
 541++86B5
 542++86B5              	; ld a,(file_num)
 543++86B5              	; inc a
 544++86B5              	; ld (file_num),a
 545++86B5              	; ld (f_name+7),a ;в конце имени номер
 546++86B5
 547++86B5              	; jr fclose_f ;сначала
 548++86B5
 549++86B5
 550++86B5              ; fclose_f_one ;запись об одном файле
 551++86B5              			; ld a,(cat_buf+8*256+#e4) ; общее количество файлов
 552++86B5              			; ld l,a ;узнать в каком секторе будет запись о файле
 553++86B5              			; ld h,0
 554++86B5              			; add hl,hl ;*2
 555++86B5              			; add hl,hl ;*4
 556++86B5              			; add hl,hl ;*8
 557++86B5              			; add hl,hl ;*16
 558++86B5              			; ld a,h ;запомнить номер сетора в каталоге
 559++86B5              			; ld (sec_cat),a
 560++86B5              			; ld bc,cat_buf
 561++86B5              			; add hl,bc ;здесь будет запись о новом файле
 562++86B5              			; ex de,hl
 563++86B5
 564++86B5              			; ld hl,f_name ;запись о файле
 565++86B5              			; ld bc,16
 566++86B5              			; ldir ;скопировать
 567++86B5              			; ex de,hl
 568++86B5              			; dec hl
 569++86B5              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка назначения
 570++86B5              			; ld (hl),d ;дорожка
 571++86B5              			; dec hl
 572++86B5              			; ld (hl),e ;сектор
 573++86B5
 574++86B5              			; ld l,0 ;записать сектор целиком по ровному адресу
 575++86B5              			; ld d,0
 576++86B5              			; ld a,(sec_cat)
 577++86B5              			; ld e,a ;номер сектора
 578++86B5              			; ld bc,#0106 ;1 сектор записать
 579++86B5              			; call call3d13
 580++86B5
 581++86B5              			; ;служебный сектор
 582++86B5              			; ld de,(cat_buf+8*256+#e1) ;первые свободные сектор-дорожка
 583++86B5              			; ld a,(f_name+13) ;размер файла в секторах
 584++86B5              			; ld b,a
 585++86B5              			; call calc_next_pos2
 586++86B5              			; ld (cat_buf+8*256+#e1),de
 587++86B5
 588++86B5              			; ld hl,(cat_buf+8*256+#e5) ; количество свободных секторов на диске
 589++86B5              			; ld a,(f_name+13) ;размер файла в секторах
 590++86B5              			; ld c,a
 591++86B5              			; ld b,0
 592++86B5              			; and a
 593++86B5              			; sbc hl,bc
 594++86B5              			; jr nc,fclose_f_one2
 595++86B5              			; ld hl,0 ;если было отрицательное
 596++86B5              ; fclose_f_one2
 597++86B5              			; ld (cat_buf+8*256+#e5),hl
 598++86B5
 599++86B5              			; ld hl,cat_buf+8*256+#e4 ; общее количество файлов
 600++86B5              			; inc (hl)
 601++86B5
 602++86B5              			; ld hl,cat_buf+8*256
 603++86B5              			; ld de,#0008
 604++86B5              			; ld bc,#0106 ;1 сектор записать
 605++86B5              			; call call3d13
 606++86B5              			; ret
 607++86B5
 608++86B5
 609++86B5              ; fclose_scl
 610++86B5              	; cp 4 ;если scl
 611++86B5              	; jr nz,fclose_ex
 612++86B5              	; ld hl,sec_buf ;
 613++86B5              	; ld b,1
 614++86B5              	; call scl_write_buf ;допишем остаток scl, если есть
 615++86B5
 616++86B5              ; fclose_ex
 617++86B5              	; xor a ;закрываем все файлы
 618++86B5              	; ld (f_r_flag),a
 619++86B5              	; ld (f_w_flag),a
 620++86B5
 621++86B5              	; ld a,(com_file_err_flag) ;была ли ошибка
 622++86B5              	; or a
 623++86B5              	; ret z
 624++86B5              	; ld a,2 ;если была
 625++86B5              	; out (254),a ;бордюр красный
 626++86B5                  ; ld hl, com_file_err ;общая ошибка
 627++86B5                  ; call DialogBox.msgBox ;предуреждение
 628++86B5              	; xor a ;
 629++86B5              	; out (254),a
 630++86B5              	; ;call restore_drive ;вернуть диск, какой был
 631++86B5                  ; ret
 632++86B5
 633++86B5
 634++86B5
 635++86B5
 636++86B5              ; A - file stream id
 637++86B5              ; BC - length
 638++86B5              ; HL - buffer
 639++86B5              ; Returns
 640++86B5              ;  BC - length(how much was actually read)
 641++86B5              fread: ;(id=1)
 642++86B5 59           	ld e,c ;сохранить длину
 643++86B6 50           	ld d,b
 644++86B7 C5           	push bc
 645++86B8              	OS_FILE_READ
 645++86B8 0E 23       >    ld c,#23
 645++86BA E7          >    rst #20
 646++86BB C1           	pop bc ;вернуть ту же длину
 647++86BC C9           	ret
 648++86BD
 649++86BD                  ; push hl : pop ix
 650++86BD                  ; esxCall ESX_FREAD
 651++86BD              	; push af
 652++86BD              	; ld a,4
 653++86BD              	; out (254),a
 654++86BD              	; xor a
 655++86BD              	; out (254),a
 656++86BD              	; pop af
 657++86BD
 658++86BD              	; cp 1 ;id = 1?
 659++86BD              	; jr nz,fread_no_chek ;выход если номер потока не = 1
 660++86BD              	; ld a,(f_r_flag)
 661++86BD              	; or a
 662++86BD              	; jr nz,fread_chek ;файл уже открыт?
 663++86BD              ; fread_no_chek ;выход с ошибкой
 664++86BD              	; xor a
 665++86BD              	; scf ;флаг ошибки
 666++86BD              	; ld bc,0 ;ничего мы не считали
 667++86BD              	; ret
 668++86BD
 669++86BD              ; fread_chek
 670++86BD              	; ld bc,(f_r_len_sec-1) ;загружаем файл целиком, не смотря на то, сколько байт было запрошено
 671++86BD                  ; ld      c,5 ;read читаем целыми секторами
 672++86BD              	; ld de,(f_r_cur_trk)
 673++86BD                  ; call    call3d13
 674++86BD              	; ld bc,(f_r_len) ;возвратим сколько считали байт (длину файла)
 675++86BD              	; xor a ;флаги сбросим
 676++86BD                  ; ret
 677++86BD
 678++86BD              ; A - file stream id
 679++86BD              ; BC - length
 680++86BD              ; HL - buffer
 681++86BD              ; Returns:
 682++86BD              ;   BC - actually written bytes
 683++86BD              fwrite: ;
 684++86BD 59           	ld e,c ;сохранить длину
 685++86BE 50           	ld d,b
 686++86BF C5           	push bc
 687++86C0              	OS_FILE_WRITE
 687++86C0 0E 24       >    ld c,#24
 687++86C2 E7          >    rst #20
 688++86C3 C1           	pop bc ;вернуть ту же длину
 689++86C4 C9           	ret
 690++86C5
 691++86C5                  ; push hl : pop ix
 692++86C5                  ; esxCall ESX_FWRITE
 693++86C5
 694++86C5              	; push af
 695++86C5              	; ld a,2
 696++86C5              	; out (254),a
 697++86C5
 698++86C5              	; xor a
 699++86C5              	; out (254),a
 700++86C5              	; pop af
 701++86C5
 702++86C5              	; cp 2 ;id = 2?
 703++86C5              	; jr z,fwrite_chek ;проверка id потока
 704++86C5              	; cp 3 ;id = 3?
 705++86C5              	; jr z,fwrite_chek_trd ;проверка id потока
 706++86C5              	; cp 4 ;id = 4?
 707++86C5              	; jp z,fwrite_chek_scl ;проверка id потока
 708++86C5              	; cp 6 ;id = 6?
 709++86C5              	; jp z,fwrite_chek_fat ;проверка id потока
 710++86C5
 711++86C5
 712++86C5              ; fwrite_no_chek ;выход с ошибкой
 713++86C5              	; ld a,1
 714++86C5              	; ld (com_file_err_flag),a
 715++86C5              	; xor a
 716++86C5              	; scf ;флаг ошибки
 717++86C5              	; ld bc,0 ;ничего мы не записали
 718++86C5              	; ret
 719++86C5
 720++86C5              ; fwrite_chek ;запись произвольного типа файла (id=2)
 721++86C5
 722++86C5              	; ;не отличается от записи trd, пишется входящий поток на диск, отличия при открытии и закрытии файла
 723++86C5
 724++86C5
 725++86C5
 726++86C5
 727++86C5
 728++86C5              ; fwrite_chek_trd ;запись trd файла (разворачивание образа, id=3)
 729++86C5              	; ; ld a,2
 730++86C5              	; ; out (254),a
 731++86C5
 732++86C5              	; ; xor a
 733++86C5              	; ; out (254),a
 734++86C5              	; ld a,(f_w_flag)
 735++86C5              	; or a
 736++86C5              	; jr z,fwrite_no_chek ;файл уже открыт?
 737++86C5              	; ld (temp_bc),bc ;длина
 738++86C5              	; ld (temp_hl),hl ;адрес данных
 739++86C5              	; ld a,b
 740++86C5              	; or c
 741++86C5              	; jr z,fwrite_no_chek ; если длина 0, то выход
 742++86C5
 743++86C5              	; ;защита от переполнения диска
 744++86C5              	; ld de,(#5cf4)
 745++86C5              	; ld a,d
 746++86C5              	; cp #a0 ;последняя дорожка 160
 747++86C5              	; jr nc,fwrite_no_chek
 748++86C5
 749++86C5              	; xor a
 750++86C5              	; ld (sec_part),a ;обнулить переменные
 751++86C5              	; ld (sec_shift2),a
 752++86C5              	; ld (sec_shift2+1),a
 753++86C5              	; ld (sec_shift_flag),a
 754++86C5              	; ld (write_end_flag),a ;
 755++86C5
 756++86C5
 757++86C5              	; ld a,(sec_shift)
 758++86C5              	; or a
 759++86C5              	; jr z,fwrite_trd3 ;если смещения нет, то первую часть пропустим
 760++86C5
 761++86C5
 762++86C5              	; ld c,a
 763++86C5              	; ld b,0
 764++86C5              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 765++86C5              	; add hl,bc
 766++86C5
 767++86C5              	; ld a,1
 768++86C5              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 769++86C5
 770++86C5              	; ld a,h
 771++86C5              	; or a
 772++86C5              	; jr nz,fwrite_trd4
 773++86C5              	; ld a,1
 774++86C5              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 775++86C5
 776++86C5              ; fwrite_trd4
 777++86C5              	; ld hl,sec_buf ;буфер последнего сектора
 778++86C5              	; add hl,bc ;на этой точке остановились
 779++86C5              	; ex de,hl
 780++86C5              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 781++86C5              	; ; ld a,c
 782++86C5              	; ; or a
 783++86C5              	; ; jr nz,fwrite_trd2
 784++86C5              	; ; inc b ;коррекция
 785++86C5              ; ; fwrite_trd2
 786++86C5              	; ; ld c,a
 787++86C5              	; xor a
 788++86C5              	; sub c
 789++86C5              	; ld c,a ;сколько осталось перенести до заполнения сектора
 790++86C5              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 791++86C5              	; ldir
 792++86C5
 793++86C5              	; ld a,(sec_shift_flag)
 794++86C5              	; or a
 795++86C5              	; jr nz,fwrite_trd3 ;если сектор ещё не заполнен писать не будем
 796++86C5
 797++86C5              	; ld hl,sec_buf
 798++86C5              	; ld de,(#5cf4)
 799++86C5              	; ;ld (f_w_cur_trk),de	;запомним позицию
 800++86C5                  ; ld      bc,#0106 ;пишем 1 сектор из буфера
 801++86C5                  ; call    call3d13
 802++86C5              	; ld a,c
 803++86C5              	; cp 255
 804++86C5              	; jp z,fwrite_no_chek ;выход если ошибка
 805++86C5
 806++86C5              	; xor a
 807++86C5              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 808++86C5              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 809++86C5              	; ; ld (#5cf4),de
 810++86C5              	; ; ld b,1 ;на сектор вперёд
 811++86C5              	; ; ld de,(f_w_cur_trk)
 812++86C5              	; ; call calc_next_pos
 813++86C5              	; ; ld (f_w_cur_trk),de
 814++86C5
 815++86C5              ; fwrite_trd3
 816++86C5              	; ld hl,(temp_hl) ;запишем остаток данных
 817++86C5              	; ;ld a,(sec_shift)
 818++86C5              	; ;ld c,a
 819++86C5              	; ;ld b,0
 820++86C5              	; ld bc,(sec_shift2)
 821++86C5              	; add hl,bc ;с этой точки пишем
 822++86C5              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
 823++86C5
 824++86C5              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 825++86C5              	; and a
 826++86C5              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
 827++86C5              	; ld c,l
 828++86C5              	; ld b,h
 829++86C5              	; jr nc,fwrite_trd5
 830++86C5              	; ld b,0 ;коррекция если вышел минус
 831++86C5              ; fwrite_trd5
 832++86C5              	; ld hl,(temp_hl)
 833++86C5              	; add hl,bc
 834++86C5
 835++86C5              	; ld de,outputBuffer
 836++86C5              	; and a
 837++86C5              	; sbc hl,de
 838++86C5
 839++86C5              	; ld a,l
 840++86C5              	; ld (sec_shift),a ;смещение на следующий раз
 841++86C5              	; ;ld hl,(temp_hl)
 842++86C5
 843++86C5
 844++86C5              	; ; or a
 845++86C5              	; ; jr z,fwrite_trd1
 846++86C5              	; ; inc b  ;коррекция количества секторов
 847++86C5
 848++86C5              	; ld a,b ;нужна проверка на количество секторов!!!
 849++86C5              	; ld (sec_part),a ;запомним сколько секторов во второй части
 850++86C5
 851++86C5              	; ;ld a,b
 852++86C5              	; or a
 853++86C5              	; jr z,fwrite_trd1 ;если размер данных меньше сектора, то пропустим запись
 854++86C5
 855++86C5              	; ld hl,(temp_hl2)
 856++86C5              	; ;push bc
 857++86C5              	; ld de,(#5cf4)
 858++86C5                  ; ld      c,6 ;пишем целыми секторами
 859++86C5                  ; call    call3d13
 860++86C5              	; ld a,c
 861++86C5              	; ;pop bc
 862++86C5              	; cp 255
 863++86C5              	; jp z,fwrite_no_chek ;выход если ошибка
 864++86C5              	; ; ld de,(f_w_cur_trk)
 865++86C5              	; ; call calc_next_pos
 866++86C5              	; ; ld (f_w_cur_trk),de
 867++86C5
 868++86C5              	; xor a
 869++86C5              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 870++86C5
 871++86C5              ; fwrite_trd1
 872++86C5              	; ld a,(write_end_flag) ;нужно записывать остаток?
 873++86C5              	; or a
 874++86C5              	; jr nz,fwrite_trd_ex ;не нужно
 875++86C5
 876++86C5              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
 877++86C5              	; ld a,(sec_part)
 878++86C5              	; ld b,a
 879++86C5              	; ld c,0
 880++86C5              	; add hl,bc
 881++86C5              	; ld de,sec_buf
 882++86C5              	; ld bc,256
 883++86C5              	; ldir
 884++86C5              ; ;fwrite_trd2
 885++86C5
 886++86C5
 887++86C5              ; fwrite_trd_ex
 888++86C5              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 889++86C5              	; ;посчитаем общую длину записанного
 890++86C5              	; ld hl,(f_w_len)
 891++86C5              	; add hl,bc
 892++86C5              	; ld (f_w_len),hl
 893++86C5              	; jr nc,fwrite_trd_ex1
 894++86C5              	; ld hl,(f_w_len+2)
 895++86C5              	; inc hl
 896++86C5              	; ld (f_w_len+2),hl
 897++86C5
 898++86C5              ; fwrite_trd_ex1
 899++86C5              	; xor a ;флаги сбросим
 900++86C5                  ; ret
 901++86C5
 902++86C5
 903++86C5
 904++86C5
 905++86C5
 906++86C5              ; ;------------------scl----------------------
 907++86C5              ; fwrite_chek_scl ;запись scl файла (разворачивание образа, id=4)
 908++86C5              	; ; ld a,2
 909++86C5              	; ; out (254),a
 910++86C5
 911++86C5              	; ; xor a
 912++86C5              	; ; out (254),a
 913++86C5              	; ld a,(f_w_flag)
 914++86C5              	; or a
 915++86C5              	; jp z,fwrite_no_chek ;файл уже открыт?
 916++86C5              	; ld (temp_bc),bc ;длина
 917++86C5              	; ld (temp_hl),hl ;адрес данных
 918++86C5              	; ld a,b
 919++86C5              	; or c
 920++86C5              	; jp z,fwrite_no_chek ; если длина 0, то выход
 921++86C5
 922++86C5              	; ; ld a,b
 923++86C5              	; ; or a
 924++86C5              	; ; jr nz,testt1
 925++86C5              	; ; nop
 926++86C5
 927++86C5              ; ; testt1
 928++86C5
 929++86C5              	; xor a
 930++86C5              	; ld (sec_part),a ;обнулить переменные
 931++86C5              	; ld (sec_shift2),a
 932++86C5              	; ld (sec_shift2+1),a
 933++86C5              	; ld (sec_shift_flag),a
 934++86C5              	; ld (write_end_flag),a ;
 935++86C5
 936++86C5
 937++86C5              	; ld a,(sec_shift)
 938++86C5              	; or a
 939++86C5              	; jr z,fwrite_scl3 ;если смещения нет, то первую часть пропустим
 940++86C5
 941++86C5
 942++86C5              	; ld c,a
 943++86C5              	; ld b,0
 944++86C5              	; ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 945++86C5              	; add hl,bc
 946++86C5
 947++86C5              	; ld a,1
 948++86C5              	; ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 949++86C5
 950++86C5              	; ld a,h
 951++86C5              	; or a
 952++86C5              	; jr nz,fwrite_scl4
 953++86C5              	; ld a,1
 954++86C5              	; ld (sec_shift_flag),a ;флаг что не заполнен сектор
 955++86C5
 956++86C5              ; fwrite_scl4
 957++86C5              	; ld hl,sec_buf ;буфер последнего сектора
 958++86C5              	; add hl,bc ;на этой точке остановились
 959++86C5              	; ex de,hl
 960++86C5              	; ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 961++86C5              	; ; ld a,c
 962++86C5              	; ; or a
 963++86C5              	; ; jr nz,fwrite_scl2
 964++86C5              	; ; inc b ;коррекция
 965++86C5              ; ; fwrite_scl2
 966++86C5              	; ; ld c,a
 967++86C5              	; xor a
 968++86C5              	; sub c
 969++86C5              	; ld c,a ;сколько осталось перенести до заполнения сектора
 970++86C5              	; ld (sec_shift2),bc ;сохраним сколько добавили байт
 971++86C5              	; ldir
 972++86C5
 973++86C5              	; ld a,(sec_shift_flag)
 974++86C5              	; or a
 975++86C5              	; jr nz,fwrite_scl3 ;если сектор ещё не заполнен писать не будем
 976++86C5
 977++86C5              	; ld hl,sec_buf
 978++86C5              	; ;ld de,(#5cf4)
 979++86C5              	; ;ld (f_w_cur_trk),de	;запомним позицию
 980++86C5                  ; ld      b,#01 ;пишем 1 сектор из буфера
 981++86C5                  ; call    scl_write_buf
 982++86C5              	; ; ld a,c
 983++86C5              	; ; cp 255
 984++86C5              	; ; jp z,fwrite_no_chek ;выход если ошибка
 985++86C5
 986++86C5              	; xor a
 987++86C5              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
 988++86C5              	; ; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 989++86C5              	; ; ld (#5cf4),de
 990++86C5              	; ; ld b,1 ;на сектор вперёд
 991++86C5              	; ; ld de,(f_w_cur_trk)
 992++86C5              	; ; call calc_next_pos
 993++86C5              	; ; ld (f_w_cur_trk),de
 994++86C5
 995++86C5              ; fwrite_scl3
 996++86C5              	; ld hl,(temp_hl) ;запишем остаток данных
 997++86C5              	; ;ld a,(sec_shift)
 998++86C5              	; ;ld c,a
 999++86C5              	; ;ld b,0
1000++86C5              	; ld bc,(sec_shift2)
1001++86C5              	; add hl,bc ;с этой точки пишем
1002++86C5              	; ld (temp_hl2),hl ;сохраним начало записи второго сектора
1003++86C5
1004++86C5              	; ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
1005++86C5              	; and a
1006++86C5              	; sbc hl,bc ;вычтем то, что добавили к первому сектору
1007++86C5              	; ld c,l
1008++86C5              	; ld b,h
1009++86C5              	; jr nc,fwrite_scl5
1010++86C5              	; ld b,0 ;коррекция если вышел минус
1011++86C5              ; fwrite_scl5
1012++86C5              	; ld hl,(temp_hl)
1013++86C5              	; add hl,bc
1014++86C5
1015++86C5              	; ld de,outputBuffer
1016++86C5              	; and a
1017++86C5              	; sbc hl,de
1018++86C5
1019++86C5              	; ld a,l
1020++86C5              	; ld (sec_shift),a ;смещение на следующий раз
1021++86C5              	; ;ld hl,(temp_hl)
1022++86C5
1023++86C5
1024++86C5              	; ; or a
1025++86C5              	; ; jr z,fwrite_scl1
1026++86C5              	; ; inc b  ;коррекция количества секторов
1027++86C5
1028++86C5              	; ld a,b ;нужна проверка на количество секторов!!!
1029++86C5              	; ld (sec_part),a ;запомним сколько секторов во второй части
1030++86C5
1031++86C5              	; ;ld a,b
1032++86C5              	; or a
1033++86C5              	; jr z,fwrite_scl1 ;если размер данных меньше сектора, то пропустим запись
1034++86C5
1035++86C5              	; ld hl,(temp_hl2)
1036++86C5              	; ;push bc
1037++86C5              	; ;ld de,(#5cf4)
1038++86C5                  ; ;ld      c,6 ;пишем целыми секторами
1039++86C5                  ; call    scl_write_buf
1040++86C5              	; ;ld a,c
1041++86C5              	; ;pop bc
1042++86C5              	; ; cp 255
1043++86C5              	; ; jp z,fwrite_no_chek ;выход если ошибка
1044++86C5              	; ; ld de,(f_w_cur_trk)
1045++86C5              	; ; call calc_next_pos
1046++86C5              	; ; ld (f_w_cur_trk),de
1047++86C5
1048++86C5              	; xor a
1049++86C5              	; ld (write_end_flag),a ;флаг что нужно дописывать остаток
1050++86C5
1051++86C5              ; fwrite_scl1
1052++86C5              	; ld a,(write_end_flag) ;нужно записывать остаток?
1053++86C5              	; or a
1054++86C5              	; jr nz,fwrite_scl_ex ;не нужно
1055++86C5
1056++86C5              	; ld hl,(temp_hl2) ;сохраним незаписанный остаток
1057++86C5              	; ld a,(sec_part)
1058++86C5              	; ld b,a
1059++86C5              	; ld c,0
1060++86C5              	; add hl,bc
1061++86C5              	; ld de,sec_buf
1062++86C5              	; ld bc,256
1063++86C5              	; ldir
1064++86C5              ; ;fwrite_scl2
1065++86C5
1066++86C5
1067++86C5              ; fwrite_scl_ex
1068++86C5              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1069++86C5              	; ;посчитаем общую длину записанного
1070++86C5              	; ld hl,(f_w_len)
1071++86C5              	; add hl,bc
1072++86C5              	; ld (f_w_len),hl
1073++86C5              	; jr nc,fwrite_scl_ex1
1074++86C5              	; ld hl,(f_w_len+2)
1075++86C5              	; inc hl
1076++86C5              	; ld (f_w_len+2),hl
1077++86C5
1078++86C5              ; fwrite_scl_ex1
1079++86C5              	; xor a ;флаги сбросим
1080++86C5                  ; ret
1081++86C5
1082++86C5
1083++86C5
1084++86C5
1085++86C5
1086++86C5
1087++86C5              ; scl_write_buf ;заполнение промежуточного буфера
1088++86C5              	; push bc ;сколько пакетов указано в b
1089++86C5              	; ld de,scl_buf ;перенесём сектор во временный буфер
1090++86C5              	; ld bc,256
1091++86C5              	; ldir
1092++86C5              	; ld (scl_temp_hl2),hl ;сохраним адрес данных
1093++86C5              	; ld a,(scl_que) ;проверим флаг что нужны данные
1094++86C5              	; or a
1095++86C5              	; jr z,scl_write_buf_ret ;не будем вызывать парсер если не нужны
1096++86C5              	; ld hl,scl_write_buf_ret ;адрес возврата
1097++86C5              	; push hl
1098++86C5              	; ld hl,(scl_parse_ret_adr) ;адрес для продолжения основного цикла сборки
1099++86C5              	; jp (hl) ;отдадим пакет 256 байт парсеру
1100++86C5              ; scl_write_buf_ret
1101++86C5              	; ld hl,(scl_temp_hl2)
1102++86C5              	; pop bc
1103++86C5              	; djnz scl_write_buf
1104++86C5
1105++86C5              	; ret
1106++86C5
1107++86C5
1108++86C5
1109++86C5              ; scl_parse ;разбор образа scl в trd, основной цикл
1110++86C5              	; ;получить первый сектор
1111++86C5              ; ;запрос порции данных по 256 байт
1112++86C5              	; ld (scl_temp_hl),hl
1113++86C5              	; ld (scl_temp_de),de
1114++86C5              	; ld (scl_temp_bc),bc
1115++86C5              	; ld a,1
1116++86C5              	; ld (scl_que),a ;включим флаг что нужны данные
1117++86C5              	; ld hl,scl_parse_ret ;сохраним адрес возврата
1118++86C5              	; ld (scl_parse_ret_adr),hl
1119++86C5              	; ret ;вернёмся для ожидания данных
1120++86C5              ; scl_parse_ret
1121++86C5              	; xor a
1122++86C5              	; ld (scl_que),a
1123++86C5              	; ld hl,(scl_temp_hl)
1124++86C5              	; ld de,(scl_temp_de)
1125++86C5              	; ld bc,(scl_temp_bc)
1126++86C5
1127++86C5              	; ld de,scl_buf ;проверка метки образа
1128++86C5              	; ld hl,scl_sign
1129++86C5              	; ld b,8
1130++86C5              ; scl_parse_chk
1131++86C5              	; ld a,(de)
1132++86C5              	; cp (hl)
1133++86C5              	; jr nz,scl_parse_chk_no
1134++86C5              	; inc hl
1135++86C5              	; inc de
1136++86C5              	; djnz scl_parse_chk
1137++86C5              	; jr scl_parse_chk_ok
1138++86C5              ; scl_parse_chk_no ;если не совпало, значит плохой образ
1139++86C5                  ; ld hl, scl_err
1140++86C5                  ; call DialogBox.msgBox ;предуреждение
1141++86C5              	; xor a
1142++86C5              	; ld (scl_que),a ;выключим флаг что нужны данные
1143++86C5              	; ld a,4 ;закроем файл
1144++86C5              	; call fclose
1145++86C5              	; ret
1146++86C5              ; scl_parse_chk_ok ;сигнатура правильная
1147++86C5
1148++86C5              ; ;формирование каталога
1149++86C5              	; ld a,(scl_buf+8)
1150++86C5              	; ld (scl_files),a ;всего файлов
1151++86C5              	; ld (scl_cat_cycl),a ;цикл
1152++86C5              	; ld hl,scl_buf+9 ;адрес первого заголовка
1153++86C5              	; ld de,cat_buf ;адрес формируемого каталога trd
1154++86C5              ; scl_parse_cat2
1155++86C5              	; ld b,14 ;14 байт одна запись
1156++86C5              ; scl_parse_cat
1157++86C5              	; ld a,(hl)
1158++86C5              	; ld (de),a
1159++86C5              	; inc de
1160++86C5              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1161++86C5              	; jr nz,scl_parse_cat1
1162++86C5              	; ;тут пора запросить следующий сектор
1163++86C5              ; ;запрос порции данных по 256 байт
1164++86C5              	; ld (scl_temp_hl),hl
1165++86C5              	; ld (scl_temp_de),de
1166++86C5              	; ld (scl_temp_bc),bc
1167++86C5              	; ld a,1
1168++86C5              	; ld (scl_que),a ;включим флаг что нужны данные
1169++86C5              	; ld hl,scl_parse_ret1 ;сохраним адрес возврата
1170++86C5              	; ld (scl_parse_ret_adr),hl
1171++86C5              	; ret ;вернёмся для ожидания данных
1172++86C5              ; scl_parse_ret1
1173++86C5              	; xor a
1174++86C5              	; ld (scl_que),a
1175++86C5              	; ld hl,(scl_temp_hl)
1176++86C5              	; ld de,(scl_temp_de)
1177++86C5              	; ld bc,(scl_temp_bc)
1178++86C5
1179++86C5              ; scl_parse_cat1
1180++86C5              	; djnz scl_parse_cat
1181++86C5              	; inc de
1182++86C5              	; inc de
1183++86C5              	; ld a,(scl_cat_cycl)
1184++86C5              	; dec a
1185++86C5              	; ld (scl_cat_cycl),a
1186++86C5              	; jr nz,scl_parse_cat2
1187++86C5
1188++86C5              	; ld (scl_temp_hl),hl ;запомнить где остановились
1189++86C5
1190++86C5              ; ;подсчёт секторов и дорожек
1191++86C5              	; push ix
1192++86C5              	; ld a,(scl_files)
1193++86C5              	; ld de,#0100 ;данные с первой дорожки
1194++86C5              	; ld ix,cat_buf
1195++86C5              	; ld (ix+14),e
1196++86C5              	; ld (ix+15),d
1197++86C5              	; ld hl,0 ;общее количество секторов
1198++86C5              ; scl_cacl
1199++86C5              	; ld (scl_cat_cycl),a ;цикл
1200++86C5              	; ld a,(ix+13) ;длина файла в секторах
1201++86C5              	; ld c,a
1202++86C5              	; ld b,0
1203++86C5              	; add hl,bc ;секторов
1204++86C5
1205++86C5              	; ld bc,16
1206++86C5              	; add ix,bc
1207++86C5              	; ld b,a
1208++86C5              	; call calc_next_pos
1209++86C5              	; ld a,(scl_cat_cycl)
1210++86C5              	; cp 1
1211++86C5              	; jr z,scl_cacl2 ;в последний раз пропусим
1212++86C5              	; ld (ix+14),e
1213++86C5              	; ld (ix+15),d
1214++86C5              ; scl_cacl2
1215++86C5              	; dec a
1216++86C5              	; jr nz,scl_cacl
1217++86C5              	; ;теперь узнаем первый свободный сектор
1218++86C5              	; ld a,(ix+13) ;длина файла в секторах
1219++86C5              	; ld c,a
1220++86C5              	; ld b,0
1221++86C5              	; add hl,bc
1222++86C5              	; ; ld b,a
1223++86C5              	; ; call calc_next_pos
1224++86C5              	; ld (cat_buf+8*256+#e1),de ;Первый свободный сектор и дорожка на дискете
1225++86C5              	; ld de,16*159
1226++86C5              	; ex de,hl
1227++86C5              	; and a
1228++86C5              	; sbc hl,de
1229++86C5              	; ld (cat_buf+8*256+#e5),hl ;Число свободных секторов на диске
1230++86C5              	; pop ix
1231++86C5
1232++86C5
1233++86C5
1234++86C5              ; ;запись содержимого файлов
1235++86C5              	; ld a,(scl_files) ;всего файлов
1236++86C5              	; ld (scl_cat_cycl),a ;цикл
1237++86C5              	; ld hl,cat_buf+13 ;адрес размер секторов файла
1238++86C5              	; ld (cat_cur_adr),hl
1239++86C5
1240++86C5              	; ld hl,#0100 ;начиная с первой дорожки
1241++86C5              	; ld (#5cf4),hl
1242++86C5              ; scl_parse_file2
1243++86C5              	; ld hl,(scl_temp_hl) ;адрес данных
1244++86C5              	; ld de,(cat_cur_adr) ;адрес сектор дорожка файла
1245++86C5              	; ;dec de
1246++86C5              	; ld a,(de) ;количество секторов, цикл
1247++86C5              	; ld c,a
1248++86C5              ; scl_parse_file3
1249++86C5              	; ld de,scl_buf2 ;адрес ещё одного буфера
1250++86C5              	; ld b,0 ;256 байт один сектор, цикл
1251++86C5              ; scl_parse_file
1252++86C5              	; ld a,(hl)
1253++86C5              	; ld (de),a
1254++86C5              	; inc de
1255++86C5              	; inc l ;адрес увеличиваем только в пределах младшего регистра
1256++86C5              	; jr nz,scl_parse_file1
1257++86C5              	; ;тут пора запросить следующий сектор
1258++86C5              ; ;запрос порции данных по 256 байт
1259++86C5              	; ld (scl_temp_hl),hl
1260++86C5              	; ld (scl_temp_de),de
1261++86C5              	; ld (scl_temp_bc),bc
1262++86C5              	; ld a,1
1263++86C5              	; ld (scl_que),a ;включим флаг что нужны данные
1264++86C5              	; ld hl,scl_parse_ret2 ;сохраним адрес возврата
1265++86C5              	; ld (scl_parse_ret_adr),hl
1266++86C5              	; ret ;вернёмся для ожидания данных
1267++86C5              ; scl_parse_ret2
1268++86C5              	; xor a
1269++86C5              	; ld (scl_que),a
1270++86C5              	; ld hl,(scl_temp_hl)
1271++86C5              	; ld de,(scl_temp_de)
1272++86C5              	; ld bc,(scl_temp_bc)
1273++86C5
1274++86C5              ; scl_parse_file1
1275++86C5              	; djnz scl_parse_file
1276++86C5              	; ld (scl_temp_hl),hl
1277++86C5              	; ld (scl_temp_bc),bc
1278++86C5
1279++86C5              	; ld hl,scl_buf2 ;;запишем один сектор
1280++86C5              	; ld  de,(#5cf4)
1281++86C5                  ; ld      bc,#0106 ;
1282++86C5                  ; call    call3d13
1283++86C5              	; ; ld a,c
1284++86C5              	; ; cp 255
1285++86C5              	; ; jp z,fwrite_no_chek ;выход если ошибка
1286++86C5              	; ld hl,(scl_temp_hl)
1287++86C5              	; ld bc,(scl_temp_bc)
1288++86C5
1289++86C5              	; dec c
1290++86C5              	; jr nz,scl_parse_file3
1291++86C5
1292++86C5              	; ld hl,(cat_cur_adr) ;адрес сектор дорожка файла
1293++86C5              	; ; ld e,(hl)
1294++86C5              	; ; inc hl
1295++86C5              	; ; ld d,(hl)
1296++86C5              	; ld bc,16
1297++86C5              	; add hl,bc ;на следующий файл
1298++86C5              	; ld (cat_cur_adr),hl
1299++86C5
1300++86C5
1301++86C5              	; ld a,(scl_cat_cycl)
1302++86C5              	; dec a
1303++86C5              	; ld (scl_cat_cycl),a
1304++86C5              	; jr nz,scl_parse_file2	;на следующий файл
1305++86C5
1306++86C5
1307++86C5
1308++86C5              ; ;формирование системного сектора №9 (8)
1309++86C5              	; ;
1310++86C5              	; ;ld (cat_buf+8*256+#e1),a ;// #E1 Первый свободный сектор на дискете
1311++86C5              	; ;
1312++86C5              	; ;ld (cat_buf+8*256+#e2),a ;// #E2 Первый свободный трек
1313++86C5              	; ld a,#16
1314++86C5              	; ld (cat_buf+8*256+#e3),a ;// #E3 16 80 дорожек, 2 стороны
1315++86C5              	; ld a,(scl_files)
1316++86C5              	; ld (cat_buf+8*256+#e4),a ;// #E4 Общее количество файлов записанных на диск
1317++86C5              	; ;
1318++86C5              	; ;ld (cat_buf+8*256+#e5),a ;// #Е5,Е6 Число свободных секторов на диске
1319++86C5              	; ;ld (cat_buf+8*256+#e6),a
1320++86C5              	; ld a,#10
1321++86C5              	; ld (cat_buf+8*256+#e7),a ;// #E7 Код  #10,определяющий принадлежность к TR-DOS
1322++86C5
1323++86C5              	; ld hl,f_name ;запишем имя диска, взяв для этого имя файла
1324++86C5              	; ld de,cat_buf+8*256+#f5 ;// #F5-#FC Имя диска в ASCII формате
1325++86C5              	; ld bc,8
1326++86C5              	; ldir
1327++86C5
1328++86C5              	; ld hl,cat_buf ;запишем каталог на диск
1329++86C5              	; ld de,0
1330++86C5                  ; ld      bc,#0906 ;
1331++86C5                  ; call    call3d13
1332++86C5              	; ; ld a,c
1333++86C5              	; ; cp 255
1334++86C5              	; ; jp z,fwrite_no_chek ;выход если ошибка
1335++86C5              	; ret
1336++86C5
1337++86C5
1338++86C5              ; ;-----------scl end --------------------
1339++86C5
1340++86C5
1341++86C5
1342++86C5              ; ;---------------------------------------
1343++86C5              ; fwrite_chek_fat ;запись файла fat
1344++86C5              	; ld (temp_bc),bc ;длина
1345++86C5              	; ld a,c ;младший байт длины
1346++86C5              	; ld	de,fcb
1347++86C5              	; R8FAT r8f09_FileWrite	;записать в файл
1348++86C5              	; jp 	c,fwrite_no_chek
1349++86C5
1350++86C5              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
1351++86C5              	; ;посчитаем общую длину записанного
1352++86C5              	; ld hl,(f_w_len)
1353++86C5              	; add hl,bc
1354++86C5              	; ld (f_w_len),hl
1355++86C5              	; jr nc,fwrite_fat_ex1
1356++86C5              	; ld hl,(f_w_len+2)
1357++86C5              	; inc hl
1358++86C5              	; ld (f_w_len+2),hl
1359++86C5              ; fwrite_fat_ex1
1360++86C5              	; xor a ;флаги сбросим
1361++86C5              	; ret
1362++86C5              ;---------------------------------------
1363++86C5
1364++86C5
1365++86C5
1366++86C5              ; A - file stream id
1367++86C5              ; fsync:
1368++86C5              ;     esxCall ESX_FSYNC
1369++86C5                  ; ret
1370++86C5
1371++86C5
1372++86C5              ; ; HL - name (name.ext)
1373++86C5              ; ; Returns:
1374++86C5              ; ; HL - name (name    e)
1375++86C5              ; format_name ;подгоняет имя файла под стандарт trdos (8+1)
1376++86C5
1377++86C5              	; ;сначала попробуем убрать из пути подпапку, если она есть
1378++86C5              	; ld (temp_hl),hl ;сохраним адрес исходного имени
1379++86C5              	; ld b,#00 ;не больше 255 символов
1380++86C5              ; format_name5
1381++86C5              	; ld a,(hl)
1382++86C5              	; cp "/" ;если есть подпапка
1383++86C5              	; jr z,format_name_path_yep
1384++86C5              	; ld a,(hl)
1385++86C5              	; cp "." ;если ещё не дошли до расширения
1386++86C5              	; jr nz,format_name6
1387++86C5              	; ld hl,(temp_hl) ;если дошли до расширения, то путей нет, вернёмся на начало имени
1388++86C5              	; jr format_name_7 ;на выход
1389++86C5              ; format_name6
1390++86C5              	; inc hl
1391++86C5              	; djnz format_name5
1392++86C5
1393++86C5              ; format_name_path_yep ;нашли
1394++86C5              	; inc hl ;пропустим знак "/"
1395++86C5
1396++86C5              ; format_name_7
1397++86C5
1398++86C5              	; push hl ;очистим место для нового имени
1399++86C5              	; ld hl,f_name
1400++86C5              	; ld de,f_name+1
1401++86C5              	; ld (hl)," "
1402++86C5              	; ld bc,8+1
1403++86C5              	; ldir
1404++86C5              	; ld (hl),0
1405++86C5              	; ld bc,16-8-1-1
1406++86C5              	; ldir
1407++86C5              	; pop hl
1408++86C5
1409++86C5              	; ld bc,#09ff ;длина имени 9 символов
1410++86C5              	; ld de,f_name ;куда
1411++86C5              ; format_name2
1412++86C5              	; ld a,(hl)
1413++86C5              	; cp "."
1414++86C5              	; jr nz,format_name1
1415++86C5              	; ld de,f_name+8
1416++86C5              	; inc hl
1417++86C5              	; ldi ; и в конце расширение 3 буквы
1418++86C5              	; ldi
1419++86C5              	; ldi
1420++86C5              	; ;ex de,hl ;сохраним адрес исходного расширения
1421++86C5              	; jr format_name_e
1422++86C5              ; format_name1
1423++86C5              	; ldi
1424++86C5              	; djnz format_name2
1425++86C5
1426++86C5              	; ;если имя длинное, пропустим лишнее до расширения
1427++86C5              	; ld b,#00 ;не больше 255 символов
1428++86C5              ; format_name3
1429++86C5              	; ld a,(hl)
1430++86C5              	; cp "."
1431++86C5              	; jr nz,format_name4
1432++86C5              	; ld de,f_name+8
1433++86C5              	; inc hl
1434++86C5              	; ldi ; и в конце расширение 3 буквы
1435++86C5              	; ldi
1436++86C5              	; ldi
1437++86C5              	; ;ex de,hl ;сохраним адрес исходного расширения
1438++86C5              	; jr format_name_e
1439++86C5              ; format_name4
1440++86C5              	; inc hl
1441++86C5              	; djnz format_name3
1442++86C5
1443++86C5              ; format_name_e ;выход
1444++86C5              	; ld hl,f_name ;вернём результат
1445++86C5              	; ret
1446++86C5
1447++86C5              ; ; DE - trk/sec
1448++86C5              ; ; B - sectors step
1449++86C5              ; ; Returns:
1450++86C5              ; ; DE - trk/sec
1451++86C5              ; calc_next_pos		;вперёд на N секторов
1452++86C5              			; ;ld b,4
1453++86C5              			; ;ld  de,(#5ceb)
1454++86C5              ; calc_next_pos2
1455++86C5              			; inc e
1456++86C5              			; ld a,e
1457++86C5              			; cp 16
1458++86C5              			; jr c,calc_next_pos1
1459++86C5              			; inc d
1460++86C5              			; ld e,0
1461++86C5              ; calc_next_pos1
1462++86C5              			; ;ld (#5ceb),de
1463++86C5              			; djnz calc_next_pos2
1464++86C5              			; ret
1465++86C5
1466++86C5
1467++86C5              ; ;testt db "123.trd"
1468++86C5              ; write_ima db "Select disk "
1469++86C5              ; write_ima_d db "A: (A-" ;текущая буква
1470++86C5              ; write_ima_e	db "D). " ;последняя буква
1471++86C5              		; db "All data may be lost! Press Y or N.",0
1472++86C5              ; ;prev_drive db 0 ;предыдущий номер дисковода
1473++86C5              ; curr_drive db 0 ;текущий диск
1474++86C5
1475++86C5              ; trdExt1 db ".trd", 0
1476++86C5              ; trdExt2 db ".TRD", 0
1477++86C5
1478++86C5              ; sclExt1 db ".scl", 0
1479++86C5              ; sclExt2 db ".SCL", 0
1480++86C5
1481++86C5              ;f_name ds 16 ;имя файла
1482++86C5              ; f_r_cur_trk dw 	 0 ;текущие сектор-дорожка файла на чтение
1483++86C5              ; f_r_len_sec db 0 ;длина файла на чтение в секторах
1484++86C5              ; f_r_len dw 0;длина файла в байтах
1485++86C5              ; f_r_flag db 0 ;флаг что открыт файл на чтение
1486++86C5
1487++86C5              ; f_w_cur_trk dw 	 0 ;текущие сектор-дорожка файла на запись
1488++86C5              ; f_w_len_sec db 0 ;длина файла на запись в секторах
1489++86C5              ; f_w_flag db 0 ;флаг что открыт файл на запись
1490++86C5              ; f_w_len ds 4 ;длина записанных данных
1491++86C5              ; write_end_flag db 0 ;флаг что нужно записать остаток
1492++86C5
1493++86C5              ; temp_bc dw 0 ;хранение регистра
1494++86C5              ;temp_hl dw 0 ;хранение регистра
1495++86C5              ; temp_hl2 dw 0 ;хранение регистра
1496++86C5
1497++86C5              ; sec_shift db 0 ;указатель на каком байте остановлена запись
1498++86C5              ; sec_shift2 db 0 ;указатель на каком байте остановлена запись (остаток)
1499++86C5              ; sec_part db 0 ;сколько секторов во второй порции для записи
1500++86C5              ; sec_shift_flag db 0 ;флаг что буфер сектора не заполнен
1501++86C5
1502++86C5              ; ;секция scl
1503++86C5              ; scl_sign db "SINCLAIR" ;метка
1504++86C5              ; scl_que db 0 ;флаг запроса порции данных
1505++86C5              ; scl_err db "SCL image error!",0
1506++86C5              ; scl_parse_ret_adr dw 0; адрес возврата в цикл
1507++86C5              ; scl_cat_cycl db 0 ;переменная цикла
1508++86C5              ; scl_files db 0 ;всего файлов
1509++86C5              ; scl_temp_hl dw 0;;хранение регистра
1510++86C5              ; scl_temp_hl2 dw 0;
1511++86C5              ; scl_temp_de dw 0;
1512++86C5              ; scl_temp_bc dw 0;
1513++86C5              ; cat_cur_adr dw 0;
1514++86C5              ; ;scl end
1515++86C5
1516++86C5              ; ;секция сохранения любого файла
1517++86C5              ; file_err db "Not enough space!",0
1518++86C5              ; sec_cat db 0 ;сектор каталога
1519++86C5              ; file_num db "0" ;номер части для больших файлов
1520++86C5
1521++86C5              	; ;по адресу #4000 шрифт
1522++86C5              ; cat_buf equ #4800 ;буфер для кататога диска 9*256
1523++86C5              ; sec_buf equ cat_buf + 9*256 ;буфер сектора для записи 256
1524++86C5              ; scl_buf equ sec_buf + 512 ;промежуточный буфер 256
1525++86C5              ; scl_buf2 equ scl_buf + 512 ;промежуточный буфер 256
1526++86C5              ; ;общая ошибка с файлами
1527++86C5              ; com_file_err db "File error!",0
1528++86C5              ; com_file_err_flag db 0 ;общая ошибка
1529++86C5
1530++86C5
1531++86C5
1532++86C5
1533++86C5              ; ;Раздел SMUC и SD ------------------------------------
1534++86C5
1535++86C5
1536++86C5              ; ;список доступных разделов на винчестерах
1537++86C5              ; ;7,=0/1 тип раздела MFS/FAT
1538++86C5              ; ;6,=1 раздел есть
1539++86C5              ; ;3,=0/1 Hdd/SD card
1540++86C5              ; ;2,=0/1 для HDD master/slave
1541++86C5              ; ;0..1,=?? номер раздела
1542++86C5              ; ;
1543++86C5              ; typeDrive	ds 3*4+1
1544++86C5              ; ;typeDriveFAT	ds 3*4+1 ;список всех разделов FAT
1545++86C5              ; numDrives db 0 ;количество устройств
1546++86C5              ; ;numDrivesFAT db 0 ;количество устройств FAT
1547++86C5              ; next_lett db 0 ;следующая свободная буква диска
1548++86C5
1549++86C5              ; ;подсчет количества доступных разделов на всех устройствах
1550++86C5              ; ;вых: hl,a - количество устройств
1551++86C5              ; ;     typeDrives - сформированная таблица
1552++86C5              ; ;     cy=1 не обнаружено ни одного устройства
1553++86C5              ; ;
1554++86C5              ; GetNumPart
1555++86C5              ; ;
1556++86C5              	; push	de
1557++86C5              	; push	bc
1558++86C5              	; ld	hl,typeDrive
1559++86C5              	; push	hl
1560++86C5              	; xor	a
1561++86C5              	; call	proc_01			;HDD master
1562++86C5              	; ld	a,#01
1563++86C5              	; call	proc_01			;HDD slave
1564++86C5              	; ld	a,#02
1565++86C5              	; call	proc_01			;SD card
1566++86C5              	; pop	de
1567++86C5              	; or	a
1568++86C5              	; sbc	hl,de			;количество разделов на HDD
1569++86C5              	; IFDEF	useTRD
1570++86C5              	 ; ld	a,l
1571++86C5              	 ; add	a,#04
1572++86C5              	 ; ld	l,a
1573++86C5              	; ELSE
1574++86C5              	 ; ld	a,l
1575++86C5              	; ENDIF
1576++86C5              	; pop	bc
1577++86C5              	; pop	de
1578++86C5              	; ld	(numDrives),a
1579++86C5              	; cp	1
1580++86C5              	; ret
1581++86C5
1582++86C5              ; ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1583++86C5              ; ;формирование таблицы с доступными разделами на винчестере
1584++86C5              ; ;вх:  a =#00 выбрать master
1585++86C5              ; ;       =#01 выбрать slave
1586++86C5              ; ;       =#02 выбрать SD card
1587++86C5              ; ;     hl - адрес в таблице разделов typeDrives
1588++86C5              ; ;вых: hl - новый адрес в таблице разделов typeDrives
1589++86C5              ; ;
1590++86C5              ; proc_01	ld	c,a
1591++86C5              	; push	hl
1592++86C5              	; push	bc
1593++86C5              	; R8DOS	r8d2E_CngHDD
1594++86C5              	; jr	c,goto001		;на текущем канале нет винчестера
1595++86C5              	; R8DOS	r8d2D_FindPart
1596++86C5              ; goto001	pop	bc
1597++86C5              	; pop	hl
1598++86C5              	; ret	c			;на текущем винчестере нет разделов
1599++86C5              	; ld	b,a
1600++86C5              	; ld	a,c
1601++86C5              	; add	a,a
1602++86C5              	; add	a,a
1603++86C5              	; ld	c,a			;номер винчестера и первого раздела
1604++86C5              	; ld	a,b
1605++86C5              	; ld	b,#04
1606++86C5              ; loop001	ld	(hl),#00
1607++86C5              	; rra
1608++86C5              	; jr	nc,goto002		;нет раздела
1609++86C5              	; IFDEF	useMFS
1610++86C5              	 ; ld	(hl),c
1611++86C5              	 ; set	6,(hl)			;=%01???hpp MFS
1612++86C5              	 ; rra
1613++86C5              	 ; jr	nc,goto003		;это MFS
1614++86C5              	 ; set	7,(hl)			;=%11???hpp это FAT
1615++86C5              	; ELSE
1616++86C5              	 ; rra
1617++86C5              	 ; jr	nc,goto004		;это MFS
1618++86C5              	 ; ld	(hl),c
1619++86C5              	 ; set	6,(hl)			;раздел есть
1620++86C5              	 ; set	7,(hl)			;=%11???hpp это FAT
1621++86C5              	; ENDIF
1622++86C5              ; goto003	inc	hl
1623++86C5              	; rla
1624++86C5              ; goto002	rra
1625++86C5              ; goto004	inc	c
1626++86C5              	; djnz	loop001
1627++86C5              	; ret
1628++86C5
1629++86C5
1630++86C5
1631++86C5              ; hdd_init_flag: db 0 ;флаг инициализации
1632++86C5              ; ;fcb_tmp ds 32 ;буфер fcb временно
1633++86C5              ; ActPathFAT db "\\Download",0 ;папка для сохранений
1634++86C5              ; fcb ds 32	;буфер fcb
1635++86C5              	; nop
1636++86C5              ; ;конец секции SMUC и SD ----------------------------
1637++86C5 5C 4F 53 5A  path_os db "\\OSZ",0
1637++86C9 00
1638++86CA 5C 4F 53 5A  path_download db "\\OSZ\\Download\\MoonR",0
1638++86CE 5C 44 6F 77
1638++86D2 6E 6C 6F 61
1638++86D6 64 5C 4D 6F
1638++86DA 6F 6E 52 00
1639++86DE              ;path_deskr ds 32 ;дескриптор каталога
1640++86DE
1641++86DE
1642++86DE                  ENDMODULE
# file closed: dos/zsfat.asm
   9+ 86DE              	ENDIF
  10+ 86DE                  include "console.asm"
# file opened: dos/console.asm
   1++86DE                  module Console
   2++86DE              KEY_UP = 11
   3++86DE              KEY_DN = 10
   4++86DE              KEY_LT = 8
   5++86DE              KEY_RT = 9
   6++86DE              BACKSPACE = 12
   7++86DE 00           keyCode db 0
   8++86DF
   9++86DF              ;BASIC_KEY = #5C08
  10++86DF
  11++86DF              waitForKeyUp:
  12++86DF              	OS_WAIT
  12++86DF DF          >	rst #18
  13++86E0              	OS_GET_CHAR
  13++86E0 0E 10       >    ld c,#10
  13++86E2 E7          >    rst #20
  14++86E3 FE FF           cp 255
  15++86E5 20 F8           jr nz, waitForKeyUp
  16++86E7
  17++86E7                 ; ld (BASIC_KEY), a
  18++86E7 C9              ret
  19++86E8
  20++86E8              getC:
  21++86E8              	OS_WAIT
  21++86E8 DF          >	rst #18
  22++86E9              	OS_GET_CHAR
  22++86E9 0E 10       >    ld c,#10
  22++86EB E7          >    rst #20
  23++86EC                 ;ld a,(BASIC_KEY)
  24++86EC                 ;and a : jr z, getC
  25++86EC FE FF           cp 255
  26++86EE 28 F8           jr z, getC
  27++86F0                 ;ld b,a
  28++86F0                 ;xor a : ld (BASIC_KEY), a
  29++86F0                 ;ld a, b
  30++86F0 C9              ret
  31++86F1
  32++86F1              peekC:
  33++86F1              	OS_GET_CHAR
  33++86F1 0E 10       >    ld c,#10
  33++86F3 E7          >    rst #20
  34++86F4                  ;xor a: ld (BASIC_KEY),a
  35++86F4                  ;call inkey
  36++86F4 C9               ret
  37++86F5
  38++86F5              ; inkey:
  39++86F5                 ; ld de,0
  40++86F5                 ; ld bc,$fefe
  41++86F5                 ; in a,(c)
  42++86F5                 ; or $e1
  43++86F5                 ; cp $ff
  44++86F5                 ; jr nz, .keyhitA
  45++86F5
  46++86F5                 ; ld e,5
  47++86F5                 ; ld b,$fd
  48++86F5                 ; in a,(c)
  49++86F5                 ; or $e0
  50++86F5                 ; cp $ff
  51++86F5                 ; jr nz, .keyhitA
  52++86F5
  53++86F5                 ; ld e,10
  54++86F5                 ; ld b,$fb
  55++86F5                 ; in a,(c)
  56++86F5                 ; or $e0
  57++86F5                 ; cp $ff
  58++86F5                 ; jr nz, .keyhitA
  59++86F5
  60++86F5                 ; ld e,15
  61++86F5                 ; ld b,$f7
  62++86F5                 ; in a,(c)
  63++86F5                 ; or $e0
  64++86F5                 ; cp $ff
  65++86F5                 ; jr nz, .keyhitA
  66++86F5
  67++86F5                 ; ld e,20
  68++86F5                 ; ld b,$ef
  69++86F5                 ; in a,(c)
  70++86F5                 ; or $e0
  71++86F5                 ; cp $ff
  72++86F5                 ; jr nz, .keyhitA
  73++86F5
  74++86F5                 ; ld e,25
  75++86F5                 ; ld b,$df
  76++86F5                 ; in a,(c)
  77++86F5                 ; or $e0
  78++86F5                 ; cp $ff
  79++86F5                 ; jr nz, .keyhitA
  80++86F5
  81++86F5                 ; ld e,30
  82++86F5                 ; ld b,$bf
  83++86F5                 ; in a,(c)
  84++86F5                 ; or $e0
  85++86F5                 ; cp $ff
  86++86F5                 ; jr nz, .keyhitA
  87++86F5
  88++86F5                 ; ld e,35
  89++86F5                 ; ld b,$7f
  90++86F5                 ; in a,(c)
  91++86F5                 ; or $e2
  92++86F5                 ; cp $ff
  93++86F5                 ; ld c,a
  94++86F5                 ; jr nz, .keyhitB
  95++86F5
  96++86F5              ; .nokey
  97++86F5                 ; xor a
  98++86F5                 ; ret
  99++86F5
 100++86F5              ; .keyhitA
 101++86F5
 102++86F5                 ; ld c,a
 103++86F5
 104++86F5                 ; ld a,b
 105++86F5                 ; cpl
 106++86F5                 ; or $81
 107++86F5                 ; in a,($fe)
 108++86F5                 ; or $e0
 109++86F5                 ; cp $ff
 110++86F5                 ; jr nz, .nokey
 111++86F5
 112++86F5                 ; ld a,$7f
 113++86F5                 ; in a,($fe)
 114++86F5                 ; or $e2
 115++86F5                 ; cp $ff
 116++86F5                 ; jr nz, .nokey
 117++86F5
 118++86F5              ; .keyhitB
 119++86F5
 120++86F5                 ; ld b,0
 121++86F5                 ; ld hl,.rowtbl-$e0
 122++86F5                 ; add hl,bc
 123++86F5                 ; ld a,(hl)
 124++86F5                 ; cp 5
 125++86F5                 ; jr nc, .nokey
 126++86F5                 ; add a,e
 127++86F5                 ; ld e,a
 128++86F5
 129++86F5                 ; ld hl,.table
 130++86F5                 ; add hl,de
 131++86F5
 132++86F5                 ; ld a,$fe
 133++86F5                 ; in a,($fe)
 134++86F5                 ; and $01
 135++86F5                 ; jr nz, .nocaps
 136++86F5                 ; ld e,40
 137++86F5                 ; add hl,de
 138++86F5
 139++86F5              ; .nocaps
 140++86F5
 141++86F5                 ; ld a,$7f
 142++86F5                 ; in a,($fe)
 143++86F5                 ; and $02
 144++86F5                 ; jr nz, .nosym
 145++86F5                 ; ld e,80
 146++86F5                 ; add hl,de
 147++86F5
 148++86F5              ; .nosym
 149++86F5
 150++86F5                 ; ld a,(hl)
 151++86F5                 ; ret
 152++86F5
 153++86F5              ; .rowtbl
 154++86F5                 ; defb 255,255,255,255,255,255,255
 155++86F5                 ; defb 255,255,255,255,255,255,255,255
 156++86F5                 ; defb 4,255,255,255,255,255,255
 157++86F5                 ; defb 255,3,255,255,255,2,255,1
 158++86F5                 ; defb 0,255
 159++86F5
 160++86F5              ; .table
 161++86F5                 ; db 0,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
 162++86F5                 ; db 'a','s','d','f','g'      ; A, S, D, F, G
 163++86F5                 ; db 'q','w','e','r','t'      ; Q, W, E, R, T
 164++86F5                 ; db '1','2','3','4','5'      ; 1, 2, 3, 4, 5
 165++86F5                 ; db '0','9','8','7','6'      ; 0, 9, 8, 7, 6
 166++86F5                 ; db 'p','o','i','u','y'      ; P, O, I, U, Y
 167++86F5                 ; db 13,'l','k','j','h'       ; ENTER, L, K, J, H
 168++86F5                 ; db ' ',0,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B
 169++86F5
 170++86F5                 ; ; the following are CAPS SHIFTed
 171++86F5
 172++86F5                 ; db 0,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
 173++86F5                 ; db 'A','S','D','F','G'      ; A, S, D, F, G
 174++86F5                 ; db 'Q','W','E','R','T'      ; Q, W, E, R, T
 175++86F5                 ; db 7,6,128,129,8            ; 1, 2, 3, 4, 5
 176++86F5                 ; db 12,0,9,11,10             ; 0, 9, 8, 7, 6
 177++86F5                 ; db 'P','O','I','U','Y'      ; P, O, I, U, Y
 178++86F5                 ; db 13,'L','K','J','H'       ; ENTER, L, K, J, H
 179++86F5                 ; db ' ',0,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B
 180++86F5
 181++86F5                 ; ; the following are SYM SHIFTed
 182++86F5
 183++86F5                 ; db 0,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
 184++86F5                 ; db '~','|',92,'{','}'       ; A, S, D, F, G
 185++86F5                 ; db 131,132,133,'<','>'      ; Q, W, E, R, T
 186++86F5                 ; db '!','@','#','$','%'      ; 1, 2, 3, 4, 5
 187++86F5                 ; db '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
 188++86F5                 ; db 34,';',130,']','['       ; P, O, I, U, Y
 189++86F5                 ; db 13,'=','+','-','^'       ; ENTER, L, K, J, H
 190++86F5                 ; db ' ',0,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B
 191++86F5
 192++86F5                 ; ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)
 193++86F5
 194++86F5                 ; db 0,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
 195++86F5                 ; db 1,19,4,6,7               ; A, S, D, F, G
 196++86F5                 ; db 17,23,5,18,20            ; Q, W, E, R, T
 197++86F5                 ; db 27,28,29,30,31           ; 1, 2, 3, 4, 5
 198++86F5                 ; db 127,0,134,'`',135      ; 0, 9, 8, 7, 6
 199++86F5                 ; db 16,15,9,21,25            ; P, O, I, U, Y
 200++86F5                 ; db 13,12,11,10,8            ; ENTER, L, K, J, H
 201++86F5                 ; db ' ',0,13,14,2          ; SPACE, SYM SHIFT, M, N, B
 202++86F5
 203++86F5                  endmodule
# file closed: dos/console.asm
# file closed: dos/index.asm
  19  86F5                  include "gopher/engine/history/index.asm"
# file opened: gopher/engine/history/index.asm
   1+ 86F5                  include "controler.asm"
# file opened: gopher/engine/history/controler.asm
   1++86F5                  module History
   2++86F5              back:
   3++86F5 3A 2E 88         ld a, (depth)
   3++86F8 FE 01          cp 1
   3++86FA CA 0C 87       jp z, load
   4++86FD 21 77 8B 11      ld hl, historyBlock + HistoryRecord, de, historyBlock, bc, (total - 1) * HistoryRecord
   4++8701 2F 88 01 20
   4++8705 0D
   4++8706 ED B0          ldir ; Move history up
   5++8708 21 2E 88         ld hl, depth
   5++870B 35             dec (hl)
   6++870C              ; Loads current resource
   7++870C              load:
   8++870C 21 29 87         ld hl, .msg
   8++870F CD 3A 86       call DialogBox.msgNoWait
   9++8712 AF               xor a
   9++8713 21 3E A4 11    ld hl, outputBuffer, de, outputBuffer + 1
   9++8717 3F A4
  10++8719 01 C0 5B         ld bc, #ffff - outputBuffer - 1
  11++871C 77               ld (hl), a
  12++871D ED B0            ldir
  13++871F
  14++871F 3A 2F 88         ld a, (historyBlock.isFile)
  14++8722 A7             and a
  14++8723 C2 F7 9D       jp nz, Fetcher.fetchFromFS
  15++8726 C3 A7 9D         jp Fetcher.fetchFromNet
  16++8729
  17++8729 4C 6F 61 64  .msg db "Loading resource! Please wait! It will be here soon!", 0
  17++872D 69 6E 67 20
  17++8731 72 65 73 6F
  17++8735 75 72 63 65
  17++8739 21 20 50 6C
  17++873D 65 61 73 65
  17++8741 20 77 61 69
  17++8745 74 21 20 49
  17++8749 74 20 77 69
  17++874D 6C 6C 20 62
  17++8751 65 20 68 65
  17++8755 72 65 20 73
  17++8759 6F 6F 6E 21
  17++875D 00
  18++875E
  19++875E              home:
  20++875E 21 0F 88         ld hl, homePage
  21++8761              ; HL - gopher row
  22++8761              navigate:
  23++8761 54 5D            ld de, hl
  24++8763 CD 20 9C         call UrlEncoder.isValidGopherRow
  25++8766 30 A4            jr nc, load ; Not valid - reload last
  26++8768 62 6B            ld hl, de
  27++876A E5               push hl
  28++876B
  29++876B E5               push hl
  30++876C 21 96 98 11      ld hl, HistoryEnd - HistoryRecord, de, HistoryEnd, bc,  HistoryRecord * total
  30++8770 DE 9B 01 68
  30++8774 10
  30++8775 ED B8          lddr
  31++8777
  32++8777 ED 5B 75 8B      ld de, (Render.position), (historyBlock.position + HistoryRecord), de
  32++877B ED 53 BD 8E
  33++877F                  ; Clean up struct
  34++877F AF               xor a
  34++8780 21 2F 88 11    ld hl, historyBlock, de, historyBlock + 1, bc, historyBlockSize - 1, (hl), a
  34++8784 30 88 01 47
  34++8788 03 77
  34++878A ED B0          ldir
  35++878C E1               pop hl
  36++878D
  37++878D                  ; Fill record
  38++878D 54 5D            ld de, hl
  39++878F CD DF 9B         call UrlEncoder.isFile
  40++8792 EB               ex hl, de
  41++8793 11 2F 88         ld de, historyBlock
  42++8796 12               ld (de), a
  42++8797 13             inc de
  43++8798 7E               ld a, (hl)
  43++8799 E5 D5          push hl, de
  43++879B CD 06 81       call Render.getIcon
  43++879E D1 E1          pop de, hl
  44++87A0 12               ld (de), a
  44++87A1 13             inc de
  45++87A2 3E 09 01 FF      ld a, 9, bc, #fff
  45++87A6 0F
  45++87A7 ED B1          cpir
  46++87A9              .locatorCopy
  47++87A9 7E               ld a, (hl)
  47++87AA FE 09          cp 9
  47++87AC 28 05          jr z, 1f
  48++87AE 12               ld (de), a
  48++87AF 23 13          inc hl, de
  49++87B1 18 F6            jr .locatorCopy
  50++87B3              1
  51++87B3 23               inc hl
  51++87B4 AF             xor a
  51++87B5 12             ld (de), a
  52++87B6 11 30 8A         ld de, historyBlock.host
  53++87B9              .hostCopy
  54++87B9 7E               ld a, (hl)
  54++87BA FE 09          cp 9
  54++87BC 28 05          jr z, 1f
  55++87BE 12               ld (de), a
  55++87BF 23 13          inc hl, de
  56++87C1 18 F6            jr .hostCopy
  57++87C3              1
  58++87C3 23               inc hl
  58++87C4 AF             xor a
  58++87C5 12             ld (de), a
  59++87C6 11 70 8A         ld de, historyBlock.port
  60++87C9              .portCopy
  61++87C9 7E               ld a, (hl)
  62++87CA FE 09            cp 9
  62++87CC 28 11          jr z, 1f
  63++87CE FE 0D            cp 13
  63++87D0 28 0D          jr z, 1f
  64++87D2 FE 0A            cp 10
  64++87D4 28 09          jr z, 1f
  65++87D6 FE 00            cp 0
  65++87D8 28 05          jr z, 1f
  66++87DA 12               ld (de), a
  66++87DB 23 13          inc hl, de
  67++87DD 18 EA            jr .portCopy
  68++87DF AF           1   xor a
  68++87E0 12             ld (de), a
  69++87E1 21 E1 85 11      ld hl, DialogBox.inputBuffer, de, historyBlock.search, bc, #ff
  69++87E5 76 8A 01 FF
  69++87E9 00
  69++87EA ED B0          ldir
  70++87EC 11 00 00 ED      ld de, 0, (historyBlock.position), de
  70++87F0 53 75 8B
  71++87F3 E1               pop hl
  72++87F4 3A 2E 88         ld a, (depth)
  72++87F7 FE 05          cp total
  72++87F9 30 04          jr nc, 1f
  73++87FB 3C               inc a
  73++87FC 32 2E 88       ld (depth), a
  74++87FF              1
  75++87FF 3A 30 88         ld a,(historyBlock.mediaType)
  75++8802 FE 01          cp MIME_DOWNLOAD
  75++8804 CA FE 9E       jp z, Gopher.download
  76++8807
  77++8807                  ifdef GS
  78++8807 FE 07            cp MIME_MOD
  78++8809 CA A0 9E       jp z, Gopher.loadMod
  79++880C                  endif
  80++880C
  81++880C C3 0C 87         jp load
  82++880F
  83++880F              homePage:
  84++880F 31 48 6F 6D      db "1Home", TAB, "data/index.gph"
  84++8813 65 09 64 61
  84++8817 74 61 2F 69
  84++881B 6E 64 65 78
  84++881F 2E 67 70 68
  85++8823 09 66 69 6C      db TAB, "file", TAB, "70", CR, LF, 0
  85++8827 65 09 37 30
  85++882B 0D 0A 00
  86++882E                  endmodule
# file closed: gopher/engine/history/controler.asm
   2+ 882E                  include "model.asm"
# file opened: gopher/engine/history/model.asm
   1++882E              total   equ 5
   2++882E 00           depth   db 0
   3++882F
   4++882F              historyBlock:
   5++882F 00           .isFile    db  0
   6++8830 00           .mediaType db  0
   7++8831 00 00 00...  .locator   ds  #1ff
   8++8A30 00 00 00...  .host      ds  64
   9++8A70 00 00 00...  .port      ds  6
  10++8A76 00 00 00...  .search    ds  #ff
  11++8B75 00 00        .position  dw  #00
  12++8B77
  13++8B77              historyBlockSize = $ - historyBlock
  14++8B77
  15++8B77              HistoryRecord EQU $ - historyBlock
  16++8B77                  dup total
  17++8B77 00 00 00... >    ds HistoryRecord
  17++8EBF 00 00 00... >    ds HistoryRecord
  17++9207 00 00 00... >    ds HistoryRecord
  17++954F 00 00 00... >    ds HistoryRecord
  17++9897 00 00 00... >    ds HistoryRecord
  18++989B                  edup
  19++9BDF              HistoryEnd equ $ - 1
# file closed: gopher/engine/history/model.asm
# file closed: gopher/engine/history/index.asm
  20  9BDF                  include "gopher/engine/urlencoder.asm"
# file opened: gopher/engine/urlencoder.asm
   1+ 9BDF                  MODULE UrlEncoder
   2+ 9BDF              ; HL - pointer to line in gopher page
   3+ 9BDF              ; C - flag set when it's file
   4+ 9BDF              isFile:
   5+ 9BDF              .findServerLoop
   6+ 9BDF 7E               ld a, (hl)
   6+ 9BE0 A7             and a
   6+ 9BE1 28 3B          jr z, .notFile
   6+ 9BE3 23             inc hl
   7+ 9BE4 FE 0D            cp 13
   7+ 9BE6 28 36          jr z, .notFile
   8+ 9BE8 FE 09            cp 9
   8+ 9BEA 28 02          jr z, .skipPath
   9+ 9BEC 18 F1            jr .findServerLoop
  10+ 9BEE              .skipPath
  11+ 9BEE 7E               ld a, (hl)
  11+ 9BEF A7             and a
  11+ 9BF0 28 2C          jr z, .notFile
  11+ 9BF2 23             inc hl
  12+ 9BF3 FE 0D            cp 13
  12+ 9BF5 28 27          jr z, .notFile
  13+ 9BF7 FE 09            cp 9
  13+ 9BF9 28 02          jr z, .compareServer
  14+ 9BFB 18 F1            jr .skipPath
  15+ 9BFD              .compareServer
  16+ 9BFD 7E               ld a, (hl)
  16+ 9BFE FE 66          cp "f"
  16+ 9C00 20 1C          jr nz, .notFile
  16+ 9C02 23             inc hl
  17+ 9C03 7E               ld a, (hl)
  17+ 9C04 FE 69          cp "i"
  17+ 9C06 20 16          jr nz, .notFile
  17+ 9C08 23             inc hl
  18+ 9C09 7E               ld a, (hl)
  18+ 9C0A FE 6C          cp "l"
  18+ 9C0C 20 10          jr nz, .notFile
  18+ 9C0E 23             inc hl
  19+ 9C0F 7E               ld a, (hl)
  19+ 9C10 FE 65          cp "e"
  19+ 9C12 20 0A          jr nz, .notFile
  19+ 9C14 23             inc hl
  20+ 9C15 7E               ld a, (hl)
  20+ 9C16 FE 09          cp 9
  20+ 9C18 20 04          jr nz, .notFile
  20+ 9C1A 23             inc hl
  21+ 9C1B 3E 01            ld a, 1
  22+ 9C1D C9               ret
  23+ 9C1E              .notFile
  24+ 9C1E AF               xor a
  25+ 9C1F C9               ret
  26+ 9C20
  27+ 9C20              ; Is enough fields to encode
  28+ 9C20              ; HL - pointer to line in gopher page
  29+ 9C20              ; C - flag set when there is enough fields
  30+ 9C20              isValidGopherRow:
  31+ 9C20 7E               ld a, (hl)
  31+ 9C21 A7             and a
  31+ 9C22 28 FA          jr z, isFile.notFile
  31+ 9C24 23             inc hl
  32+ 9C25 FE 0D            cp 13
  32+ 9C27 28 F5          jr z, isFile.notFile
  33+ 9C29 FE 09            cp 9
  33+ 9C2B 28 02          jr z, .skipPath
  34+ 9C2D 18 F1            jr isValidGopherRow
  35+ 9C2F              .skipPath
  36+ 9C2F 7E               ld a, (hl)
  36+ 9C30 A7             and a
  36+ 9C31 28 EB          jr z, isFile.notFile
  36+ 9C33 23             inc hl
  37+ 9C34 FE 0D            cp 13
  37+ 9C36 28 E6          jr z, isFile.notFile
  38+ 9C38 FE 09            cp 9
  38+ 9C3A 28 02          jr z, .skipHost
  39+ 9C3C 18 F1            jr .skipPath
  40+ 9C3E              .skipHost
  41+ 9C3E 7E               ld a, (hl)
  41+ 9C3F A7             and a
  41+ 9C40 28 DC          jr z, isFile.notFile
  41+ 9C42 23             inc hl
  42+ 9C43 FE 0D            cp 13
  42+ 9C45 28 D7          jr z, isFile.notFile
  43+ 9C47 FE 09            cp 9
  43+ 9C49 28 02           jr z, .isValid
  44+ 9C4B 18 F1            jr .skipHost
  45+ 9C4D              .isValid:
  46+ 9C4D 37               scf
  47+ 9C4E C9               ret
  48+ 9C4F
  49+ 9C4F              extractPath:
  50+ 9C4F 21 31 88 11      ld hl, historyBlock.locator, de, nameBuffer, bc, #ff
  50+ 9C53 67 9C 01 FF
  50+ 9C57 00
  50+ 9C58 ED B0          ldir
  51+ 9C5A C9               ret
  52+ 9C5B
  53+ 9C5B              extractHostName:
  54+ 9C5B 21 30 8A 11      ld hl, historyBlock.host, de, hostName, bc, 64
  54+ 9C5F 67 9D 01 40
  54+ 9C63 00
  54+ 9C64 ED B0          ldir
  55+ 9C66 C9               ret
  56+ 9C67
  57+ 9C67                  ENDMODULE
  58+ 9C67
  59+ 9C67 00 00 00...  nameBuffer ds #ff, 0
  60+ 9D66
  61+ 9D66 00                    db 0
  62+ 9D67 00 00 00...  hostName ds 64
# file closed: gopher/engine/urlencoder.asm
  21  9DA7                  include "gopher/engine/fetcher.asm"
# file opened: gopher/engine/fetcher.asm
   1+ 9DA7                  MODULE Fetcher
   2+ 9DA7
   3+ 9DA7              fetchFromNet:
   4+ 9DA7 CD 6E 9E         call Gopher.makeRequest
   4+ 9DAA 38 06          jr c, .error
   5+ 9DAC CD 87 9E         call Gopher.loadBuffer
   6+ 9DAF C3 03 9E         jp MediaProcessor.processResource
   7+ 9DB2              .error
   8+ 9DB2              	OS_ESP_CLOSE ;закрыть соединение, если было
   8+ 9DB2 0E 0C       >    ld c,#0c
   8+ 9DB4 E7          >    rst #20
   9+ 9DB5 21 BE 9D         ld hl, .err
   9+ 9DB8 CD 31 86       call DialogBox.msgBox
  10+ 9DBB C3 F5 86         jp History.back
  11+ 9DBE
  12+ 9DBE 44 6F 63 75  .err db "Document fetch error! Check your connection or hostname!", 0
  12+ 9DC2 6D 65 6E 74
  12+ 9DC6 20 66 65 74
  12+ 9DCA 63 68 20 65
  12+ 9DCE 72 72 6F 72
  12+ 9DD2 21 20 43 68
  12+ 9DD6 65 63 6B 20
  12+ 9DDA 79 6F 75 72
  12+ 9DDE 20 63 6F 6E
  12+ 9DE2 6E 65 63 74
  12+ 9DE6 69 6F 6E 20
  12+ 9DEA 6F 72 20 68
  12+ 9DEE 6F 73 74 6E
  12+ 9DF2 61 6D 65 21
  12+ 9DF6 00
  13+ 9DF7
  14+ 9DF7
  15+ 9DF7              fetchFromFS:
  16+ 9DF7 CD 4F 9C         call UrlEncoder.extractPath
  17+ 9DFA              loadFile
  18+ 9DFA 21 67 9C         ld hl, nameBuffer
  19+ 9DFD CD 68 86         call Dos.loadBuffer
  20+ 9E00 C3 03 9E         jp MediaProcessor.processResource
  21+ 9E03                  ENDMODULE
# file closed: gopher/engine/fetcher.asm
  22  9E03                  include "gopher/engine/media-processor.asm"
# file opened: gopher/engine/media-processor.asm
   1+ 9E03                  MODULE MediaProcessor
   2+ 9E03              processResource:
   3+ 9E03 CD 5B 9C         call UrlEncoder.extractHostName
   4+ 9E06 3A 30 88         ld a, (historyBlock.mediaType)
   5+ 9E09 FE 05            cp MIME_MUSIC
   5+ 9E0B 28 17          jr z, processPT
   6+ 9E0D FE 02            cp MIME_LINK
   6+ 9E0F 28 1F          jr z, processPage
   7+ 9E11 FE 04            cp MIME_INPUT
   7+ 9E13 28 1B          jr z, processPage
   8+ 9E15 FE 06            cp MIME_IMAGE
   8+ 9E17 CA 64 A2       jp z, ScreenViewer.display
   9+ 9E1A              	ifdef GS
  10+ 9E1A FE 07            cp MIME_MOD
  10+ 9E1C 28 0C          jr z, processMOD
  11+ 9E1E              	endif
  12+ 9E1E              ; Fallback to plain text
  13+ 9E1E              processText:
  14+ 9E1E CD E6 84         call Render.renderPlainTextScreen
  15+ 9E21 C3 22 85         jp   Render.plainTextLoop
  16+ 9E24
  17+ 9E24              processPT:
  18+ 9E24 CD CF A1         call VortexProcessor.play
  19+ 9E27 C3 F5 86         jp History.back
  20+ 9E2A
  21+ 9E2A                  ifdef GS
  22+ 9E2A              processMOD:
  23+ 9E2A CD 23 A2         call ModProcessor.play
  24+ 9E2D C3 F5 86         jp History.back
  25+ 9E30              	endif
  26+ 9E30
  27+ 9E30              processPage:
  28+ 9E30 3A 8B 85         ld a, (Render.play_next)
  28+ 9E33 A7             and a
  28+ 9E34 20 06          jr nz, .playNext
  29+ 9E36 CD 85 83         call Render.renderGopherScreen
  30+ 9E39 C3 CC 83         jp   Render.workLoop
  31+ 9E3C              .playNext
  32+ 9E3C 21 76 8B         ld hl, Render.cursor_position
  33+ 9E3F 34               inc (hl)
  34+ 9E40 C3 B6 83         jp Render.checkBorder
  35+ 9E43
  36+ 9E43
  37+ 9E43                  ENDMODULE
# file closed: gopher/engine/media-processor.asm
  23  9E43                  include "gopher/gopher.asm"
# file opened: gopher/gopher.asm
   1+ 9E43                  module Gopher
   2+ 9E43              extractRequest:
   3+ 9E43 21 31 88         ld hl, historyBlock.locator
   4+ 9E46 11 D0 9F         ld de, requestbuffer
   5+ 9E49              .loop
   6+ 9E49 7E               ld a, (hl)
   7+ 9E4A 12               ld (de), a
   8+ 9E4B 23               inc hl
   9+ 9E4C 13               inc de
  10+ 9E4D FE 00            cp 0
  11+ 9E4F 28 02            jr z, .search
  12+ 9E51 18 F6            jr .loop
  13+ 9E53              .search
  14+ 9E53 1B               dec de
  15+ 9E54 3A 30 88         ld a, (historyBlock.mediaType)
  16+ 9E57 FE 04            cp MIME_INPUT
  17+ 9E59 20 10            jr nz, .exit
  18+ 9E5B 21 76 8A         ld hl, historyBlock.search
  19+ 9E5E 3E 09            ld a, TAB
  20+ 9E60 12               ld (de), a
  21+ 9E61 13               inc de
  22+ 9E62              .searchCopy
  23+ 9E62 7E               ld a, (hl)
  24+ 9E63 A7               and a
  24+ 9E64 28 05          jr z, .exit
  25+ 9E66 12               ld (de), a
  26+ 9E67 23               inc hl
  26+ 9E68 13             inc de
  27+ 9E69 18 F7            jr .searchCopy
  28+ 9E6B              .exit
  29+ 9E6B AF               xor a
  30+ 9E6C 12               ld (de), a
  31+ 9E6D C9               ret
  32+ 9E6E
  33+ 9E6E
  34+ 9E6E              makeRequest:
  35+ 9E6E CD 43 9E         call extractRequest
  36+ 9E71
  37+ 9E71 21 30 8A         ld hl, historyBlock.host
  38+ 9E74 11 70 8A         ld de, historyBlock.port
  39+ 9E77 CD 06 A3         call Wifi.openTCP
  40+ 9E7A D8               ret c
  41+ 9E7B
  42+ 9E7B 21 D0 9F         ld hl, requestbuffer
  43+ 9E7E CD 36 A3         call Wifi.tcpSendZ
  44+ 9E81 D8           	ret c
  45+ 9E82 AF               xor a
  45+ 9E83 32 01 A3       ld (Wifi.closed), a
  46+ 9E86 C9               ret
  47+ 9E87
  48+ 9E87
  49+ 9E87              loadBuffer:
  50+ 9E87 21 00 00     	ld hl,0
  51+ 9E8A 22 02 A3     	ld (Wifi.bytes_avail_all),hl ;обнулить всего байт принято
  52+ 9E8D 22 04 A3     	ld (Wifi.bytes_avail_all+2),hl
  53+ 9E90 21 3E A4         ld hl, outputBuffer
  54+ 9E93 22 FF A2         ld (Wifi.buffer_pointer), hl
  55+ 9E96              .loop
  56+ 9E96 CD 57 A3         call Wifi.getPacket
  57+ 9E99 3A 01 A3         ld a, (Wifi.closed)
  57+ 9E9C A7             and a
  57+ 9E9D C0             ret nz
  58+ 9E9E                  ;call Wifi.continue
  59+ 9E9E 18 F6            jr .loop
  60+ 9EA0
  61+ 9EA0                  ifdef GS
  62+ 9EA0              loadMod:
  63+ 9EA0 AF               xor a
  63+ 9EA1 CD D7 A3       call GeneralSound.init
  64+ 9EA4 21 DE 9E         ld hl, .progress
  64+ 9EA7 CD 3A 86       call DialogBox.msgNoWait
  65+ 9EAA CD 6E 9E         call makeRequest
  65+ 9EAD DA B2 9D       jp c, Fetcher.fetchFromNet.error
  66+ 9EB0 CD E4 A3         call GeneralSound.loadModule
  67+ 9EB3              .loop
  68+ 9EB3 21 3E A4 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
  68+ 9EB7 FF A2
  69+ 9EB9 CD 57 A3         call Wifi.getPacket
  70+ 9EBC 3A 01 A3         ld a, (Wifi.closed)
  70+ 9EBF A7             and a
  70+ 9EC0 20 16          jr nz, .exit
  71+ 9EC2 21 3E A4 ED      ld hl, outputBuffer, bc, (Wifi.bytes_avail)
  71+ 9EC6 4B FD A2
  72+ 9EC9              .loadLoop
  73+ 9EC9 78               ld a, b
  73+ 9ECA B1             or c
  73+ 9ECB A7             and a
  73+ 9ECC 28 08          jr z, .nextFrame
  74+ 9ECE 7E               ld a, (hl)
  74+ 9ECF CD F7 A3       call GeneralSound.sendByte
  75+ 9ED2 0B               dec bc
  76+ 9ED3 23               inc hl
  77+ 9ED4 18 F3            jr .loadLoop
  78+ 9ED6              .nextFrame
  79+ 9ED6                  ;call Wifi.continue
  80+ 9ED6 18 DB            jr .loop
  81+ 9ED8              .exit
  82+ 9ED8 CD FF A3         call GeneralSound.finishLoadingModule
  83+ 9EDB                  ;jp History.back
  84+ 9EDB C3 03 9E     	jp MediaProcessor.processResource
  85+ 9EDE 4D 4F 44 20  .progress db "MOD downloading directly to GS!", 0
  85+ 9EE2 64 6F 77 6E
  85+ 9EE6 6C 6F 61 64
  85+ 9EEA 69 6E 67 20
  85+ 9EEE 64 69 72 65
  85+ 9EF2 63 74 6C 79
  85+ 9EF6 20 74 6F 20
  85+ 9EFA 47 53 21 00
  86+ 9EFE                  endif
  87+ 9EFE
  88+ 9EFE
  89+ 9EFE              download:
  90+ 9EFE
  91+ 9EFE 11 31 88         ld de, historyBlock.locator
  92+ 9F01 62 6B            ld hl, de
  93+ 9F03              .findFileName
  94+ 9F03 1A               ld a, (de)
  94+ 9F04 13             inc de
  95+ 9F05 FE 2F            cp '/'
  95+ 9F07 20 02          jr nz, .skip
  96+ 9F09 62 6B            ld hl, de
  97+ 9F0B              .skip
  98+ 9F0B A7               and a
  98+ 9F0C 20 F5          jr nz, .findFileName
  99+ 9F0E              .copy
 100+ 9F0E                  ;; HL - filename pointer
 101+ 9F0E 11 E1 85         ld de, DialogBox.inputBuffer
 102+ 9F11              .copyFileName
 103+ 9F11 7E               ld a, (hl)
 103+ 9F12 A7             and a
 103+ 9F13 28 05          jr z, .finishCopy
 104+ 9F15
 105+ 9F15 12               ld (de), a
 105+ 9F16 23 13          inc hl, de
 106+ 9F18 18 F7            jr .copyFileName
 107+ 9F1A              .finishCopy
 108+ 9F1A 12               ld (de), a
 109+ 9F1B CD 90 85         call DialogBox.inputBox.noclear
 110+ 9F1E 3A E1 85         ld a, (DialogBox.inputBuffer)
 110+ 9F21 A7             and a
 110+ 9F22 CA F5 86       jp z, History.back
 111+ 9F25
 112+ 9F25 CD 6E 9E         call makeRequest
 112+ 9F28 DA B2 9D       jp c, Fetcher.fetchFromNet.error
 113+ 9F2B
 114+ 9F2B 06 0E 21 E1      ld b, Dos.FMODE_CREATE, hl, DialogBox.inputBuffer
 114+ 9F2F 85
 115+ 9F30 CD 84 86         call Dos.fopen
 116+ 9F33 32 CE 9F         ld (.fp), a
 117+ 9F36
 118+ 9F36 21 A9 9F         ld hl, .progress
 118+ 9F39 CD 3A 86       call DialogBox.msgNoWait
 119+ 9F3C              .loop
 120+ 9F3C 21 3E A4 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
 120+ 9F40 FF A2
 121+ 9F42 CD 57 A3         call Wifi.getPacket
 122+ 9F45 3A 01 A3         ld a, (Wifi.closed)
 122+ 9F48 A7             and a
 122+ 9F49 20 0F          jr nz, .exit
 123+ 9F4B
 124+ 9F4B 3A CE 9F 21      ld a, (.fp), hl, outputBuffer, bc, (Wifi.bytes_avail)
 124+ 9F4F 3E A4 ED 4B
 124+ 9F53 FD A2
 125+ 9F55 CD BD 86         call Dos.fwrite
 126+ 9F58
 127+ 9F58                  ;call Wifi.continue
 128+ 9F58 18 E2            jr .loop
 129+ 9F5A              .exit
 130+ 9F5A 3A CE 9F         ld a, (.fp)
 131+ 9F5D CD B1 86         call Dos.fclose
 132+ 9F60 C3 F5 86         jp History.back
 133+ 9F63              ;.error
 134+ 9F63 3A CE 9F         ld a, (.fp)
 135+ 9F66 CD B1 86         call Dos.fclose
 136+ 9F69
 137+ 9F69 21 72 9F         ld hl, .err
 138+ 9F6C CD 31 86         call DialogBox.msgBox
 139+ 9F6F C3 F5 86         jp History.back
 140+ 9F72 4F 70 65 72  .err db "Operation failed! Sorry! Check filename or disk space!",0
 140+ 9F76 61 74 69 6F
 140+ 9F7A 6E 20 66 61
 140+ 9F7E 69 6C 65 64
 140+ 9F82 21 20 53 6F
 140+ 9F86 72 72 79 21
 140+ 9F8A 20 43 68 65
 140+ 9F8E 63 6B 20 66
 140+ 9F92 69 6C 65 6E
 140+ 9F96 61 6D 65 20
 140+ 9F9A 6F 72 20 64
 140+ 9F9E 69 73 6B 20
 140+ 9FA2 73 70 61 63
 140+ 9FA6 65 21 00
 141+ 9FA9 44 6F 77 6E  .progress db "Downloading in progress! Wait a bit!", 0
 141+ 9FAD 6C 6F 61 64
 141+ 9FB1 69 6E 67 20
 141+ 9FB5 69 6E 20 70
 141+ 9FB9 72 6F 67 72
 141+ 9FBD 65 73 73 21
 141+ 9FC1 20 57 61 69
 141+ 9FC5 74 20 61 20
 141+ 9FC9 62 69 74 21
 141+ 9FCD 00
 142+ 9FCE 00           .fp db 0
 143+ 9FCF
 144+ 9FCF 00           socket db 0
 145+ 9FD0
 146+ 9FD0 00 00 00...  requestbuffer ds #1ff
 147+ A1CF                  endmodule
 148+ A1CF
# file closed: gopher/gopher.asm
  24  A1CF                  include "player/vortex-processor.asm"
# file opened: player/vortex-processor.asm
   1+ A1CF                  MODULE VortexProcessor
   2+ A1CF              play:
   3+ A1CF CD DF 86         call Console.waitForKeyUp
   4+ A1D2
   5+ A1D2 21 0E A2         ld hl, message
   5+ A1D5 CD 3A 86       call DialogBox.msgNoWait
   6+ A1D8
   7+ A1D8 21 3E A4         ld hl, outputBuffer
   7+ A1DB                OS_VTPL_INIT
   7+ A1DB 0E 15       >    ld c,#15
   7+ A1DD E7          >    rst #20
   8+ A1DE
   9+ A1DE
  10+ A1DE 3E 01 32 8B      ld a, 1, (Render.play_next), a
  10+ A1E2 85
  11+ A1E3                  ifdef GS
  12+ A1E3 CD 1B A4         call GeneralSound.stopModule
  13+ A1E6                  endif
  14+ A1E6              	OS_VTPL_PLAY
  14+ A1E6 0E 16       >    ld c,#16
  14+ A1E8 E7          >    rst #20
  15+ A1E9              .loop
  16+ A1E9                  OS_WAIT
  16+ A1E9 DF          >	rst #18
  16+ A1EA               ; di : call VTPL.PLAY : ei
  17+ A1EA              	OS_GET_CHAR
  17+ A1EA 0E 10       >    ld c,#10
  17+ A1EC E7          >    rst #20
  18+ A1ED FE 20        	cp " " ;останов по пробелу
  19+ A1EF CA 08 A2     	jp z, .stopKey
  20+ A1F2 CD 93 A2     	call printRTC
  21+ A1F5              	OS_GET_VTPL_SETUP
  21+ A1F5 0E 18       >    ld c,#18
  21+ A1F7 E7          >    rst #20
  22+ A1F8 7E               ld a, (hl)
  22+ A1F9
  23+ A1F9 17           	rla
  23+ A1FA 30 ED          jr nc, .loop
  24+ A1FC 3E 01 32 8B      ld a, 1, (Render.play_next), a
  24+ A200 85
  25+ A201              .stop
  26+ A201              	OS_VTPL_MUTE
  26+ A201 0E 17       >    ld c,#17
  26+ A203 E7          >    rst #20
  27+ A204
  28+ A204                  IFDEF AY
  29+ A204 ~                call restoreAyState
  30+ A204                  ENDIF
  31+ A204
  32+ A204 CD DF 86         call Console.waitForKeyUp
  33+ A207 C9               ret
  34+ A208              .stopKey
  35+ A208 AF               xor a
  35+ A209 32 8B 85       ld (Render.play_next), a
  36+ A20C 18 F3            jr .stop
  37+ A20E
  38+ A20E                  IFDEF AY
  39+ A20E ~            restoreAyState:
  40+ A20E ~                ld a, #07
  41+ A20E ~                ld bc, #fffd
  42+ A20E ~                out (c), a
  43+ A20E ~                ld a, #fc
  44+ A20E ~                ld b, #bf
  45+ A20E ~                out (c), a ; Enable read mode
  46+ A20E ~
  47+ A20E ~                ld a, #0e
  48+ A20E ~                ld bc, #fffd
  49+ A20E ~                out (c), a
  50+ A20E ~                ret
  51+ A20E                  ENDIF
  52+ A20E
  53+ A20E 50 72 65 73  message db "Press key to stop...", 0
  53+ A212 73 20 6B 65
  53+ A216 79 20 74 6F
  53+ A21A 20 73 74 6F
  53+ A21E 70 2E 2E 2E
  53+ A222 00
  54+ A223                  ENDMODULE
  55+ A223                  ;include "player.asm"
  56+ A223
# file closed: player/vortex-processor.asm
  25  A223                  include "player/mod-processor.asm"
# file opened: player/mod-processor.asm
   1+ A223                  MODULE ModProcessor
   2+ A223                  ifdef GS
   3+ A223
   4+ A223                  macro _WaitCommand2
   5+ A223 ~            .wait
   6+ A223 ~                in a, (CMD)
   7+ A223 ~                rrca
   8+ A223 ~                jr c, .wait
   9+ A223                  endm
  10+ A223
  11+ A223                  macro _SendCommand2 nn
  12+ A223 ~                ld a, nn
  12+ A223 ~              out (CMD), a
  13+ A223                  endm
  14+ A223
  15+ A223              play:
  16+ A223 CD DF 86         call Console.waitForKeyUp
  17+ A226
  18+ A226 21 D0 9F         ld hl, Gopher.requestbuffer
  18+ A229 CD 3A 86       call DialogBox.msgNoWait
  19+ A22C
  20+ A22C                  ;ld a, 1, (Render.play_next), a
  21+ A22C AF           	xor a
  22+ A22D 32 63 A2     	ld (last_song_position),a
  23+ A230
  24+ A230              .loop
  25+ A230                  OS_WAIT
  25+ A230 DF          >	rst #18
  25+ A231
  26+ A231                  OS_GET_CHAR
  26+ A231 0E 10       >    ld c,#10
  26+ A233 E7          >    rst #20
  27+ A234 FE 20        	cp " " ;пробел
  28+ A236 CA 5D A2     	jp z, .stopKey
  29+ A239 CD 93 A2     	call printRTC
  30+ A23C                  ;проверка что MOD начал играть сначала
  31+ A23C                  _SendCommand2 CMD_GET_SONG_POSITION
  31+ A23C 3E 60       >    ld a, CMD_GET_SONG_POSITION
  31+ A23E D3 BB       >  out (CMD), a
  32+ A240                  _WaitCommand2
  32+ A240             >.wait
  32+ A240 DB BB       >    in a, (CMD)
  32+ A242 0F          >    rrca
  32+ A243 38 FB       >    jr c, .wait
  33+ A245 3A 63 A2     	ld a,(last_song_position) ;предыдущая позиция
  34+ A248 4F           	ld c,a
  35+ A249 DB B3        	in a,(DATA) ;текущая позиция
  36+ A24B 32 63 A2     	ld (last_song_position),a
  37+ A24E B9           	cp c
  38+ A24F 30 DF        	jr nc, .loop ;если не меньше, продолжаем играть
  39+ A251 3E 01 32 8B      ld a, 1, (Render.play_next), a ;флаг что надо будет играть следующий файл
  39+ A255 85
  40+ A256              .stop
  41+ A256 CD 1B A4         call GeneralSound.stopModule
  42+ A259
  43+ A259 CD DF 86         call Console.waitForKeyUp
  44+ A25C C9               ret
  45+ A25D              .stopKey
  46+ A25D AF               xor a
  46+ A25E 32 8B 85       ld (Render.play_next), a ;флаг что не надо играть следующий файл
  47+ A261 18 F3            jr .stop
  48+ A263
  49+ A263
  50+ A263              ;message db "Press key to stop...", 0
  51+ A263
  52+ A263
  53+ A263              CMD_GET_SONG_POSITION     = #60
  54+ A263 00           last_song_position db 0
  55+ A264
  56+ A264              ;; Control ports
  57+ A264              CMD  = 187
  58+ A264              DATA = 179
  59+ A264
  60+ A264                  endif
  61+ A264                  ENDMODULE
  62+ A264
  63+ A264
# file closed: player/mod-processor.asm
  26  A264                  include "screen/screen.asm"
# file opened: screen/screen.asm
   1+ A264                  module ScreenViewer
   2+ A264              display:
   3+ A264 CD DF 86         call Console.waitForKeyUp
   4+ A267
   5+ A267              display_wait1
   6+ A267 3E 07        	ld a,7
   7+ A269              	OS_SET_SCREEN ;включить экран
   7+ A269 0E 1D       >    ld c,#1d
   7+ A26B E7          >    rst #20
   8+ A26C 30 03        	jr nc,display_wait1_ok
   9+ A26E              	OS_WAIT
   9+ A26E DF          >	rst #18
  10+ A26F 18 F6        	jr display_wait1 ;пока не получилось, может не в фокусе приложение
  11+ A271
  12+ A271              display_wait1_ok
  13+ A271
  14+ A271              	OS_GET_MAIN_PAGES
  14+ A271 0E 1E       >    ld c,#1e
  14+ A273 E7          >    rst #20
  15+ A274 78           	ld a,b ; страница с буфером
  16+ A275 06 07        	ld b,7 ;страница назначения
  17+ A277 21 3E A4     	ld hl,outputBuffer
  18+ A27A 11 00 C0     	ld de,#c000
  19+ A27D DD 21 00 1B  	ld ix,6912
  20+ A281              	OS_RAM_COPY
  20+ A281 0E 19       >    ld c,#19
  20+ A283 E7          >    rst #20
  21+ A284                  ;call TextMode.disable
  22+ A284              .wait
  23+ A284              	OS_WAIT
  23+ A284 DF          >	rst #18
  24+ A285              	OS_GET_CHAR
  24+ A285 0E 10       >    ld c,#10
  24+ A287 E7          >    rst #20
  25+ A288 FE FF        	cp 255
  26+ A28A 28 F8        	jr z, .wait
  27+ A28C AF           	xor a ;текстовый экран
  28+ A28D              	OS_SET_SCREEN
  28+ A28D 0E 1D       >    ld c,#1d
  28+ A28F E7          >    rst #20
  29+ A290                  ;call TextMode.cls
  30+ A290 C3 F5 86         jp History.back
  31+ A293
  32+ A293                  endmodule
  33+ A293
# file closed: screen/screen.asm
  27  A293                  include "screen/rtc.asm"
# file opened: screen/rtc.asm
   1+ A293              printRTC
   2+ A293              	ifndef SMUCRTC
   3+ A293 C9           	ret
   4+ A294              	endif
   5+ A294              	ifdef SMUCRTC
   6+ A294 ~            	;печать текущего времени
   7+ A294 ~            	call Clock.readTime
   8+ A294 ~            	jr nc,read_time_ok
   9+ A294 ~            	; ld hl,mes_no_RTC
  10+ A294 ~            	; call print_mes
  11+ A294 ~            	; scf
  12+ A294 ~            	ret ;выход
  13+ A294 ~            read_time_ok
  14+ A294 ~            	push bc
  15+ A294 ~            	ld l,e ;часы
  16+ A294 ~            	ld h,0
  17+ A294 ~            	call toDecimal
  18+ A294 ~            	ld de,00 ;координаты
  19+ A294 ~            	call TextMode.gotoXY
  20+ A294 ~            	ld hl,decimalS+3
  21+ A294 ~            	call TextMode.printZ
  22+ A294 ~            	ld a,":"
  23+ A294 ~            	call TextMode.putC
  24+ A294 ~            	pop bc
  25+ A294 ~            	ld l,b ;минуты
  26+ A294 ~            	ld h,0
  27+ A294 ~            	call toDecimal
  28+ A294 ~            	ld hl,decimalS+3
  29+ A294 ~            	call TextMode.printZ
  30+ A294 ~            	; ld a,":"
  31+ A294 ~            	; call TextMode.putC
  32+ A294 ~            	; ld l,c ;секунды
  33+ A294 ~            	; ld h,0
  34+ A294 ~            	; call toDecimal
  35+ A294 ~            	; ld hl,decimalS+3
  36+ A294 ~            	; call TextMode.printZ
  37+ A294 ~            	; or a ;нет ошибки
  38+ A294 ~            	ret
  39+ A294 ~
  40+ A294              	endif
  41+ A294
  42+ A294              toDecimal		;конвертирует 2 байта в 5 десятичных цифр
  43+ A294              				;на входе в HL число
  44+ A294 11 10 27     			ld de,10000 ;десятки тысяч
  45+ A297 3E FF        			ld a,255
  46+ A299              toDecimal10k
  47+ A299 A7           			and a
  48+ A29A ED 52        			sbc hl,de
  49+ A29C 3C           			inc a
  50+ A29D 30 FA        			jr nc,toDecimal10k
  51+ A29F 19           			add hl,de
  52+ A2A0 C6 30        			add a,48
  53+ A2A2 32 ED A2     			ld (decimalS),a
  54+ A2A5 11 E8 03     			ld de,1000 ;тысячи
  55+ A2A8 3E FF        			ld a,255
  56+ A2AA              toDecimal1k
  57+ A2AA A7           			and a
  58+ A2AB ED 52        			sbc hl,de
  59+ A2AD 3C           			inc a
  60+ A2AE 30 FA        			jr nc,toDecimal1k
  61+ A2B0 19           			add hl,de
  62+ A2B1 C6 30        			add a,48
  63+ A2B3 32 EE A2     			ld (decimalS+1),a
  64+ A2B6 11 64 00     			ld de,100 ;сотни
  65+ A2B9 3E FF        			ld a,255
  66+ A2BB              toDecimal01k
  67+ A2BB A7           			and a
  68+ A2BC ED 52        			sbc hl,de
  69+ A2BE 3C           			inc a
  70+ A2BF 30 FA        			jr nc,toDecimal01k
  71+ A2C1 19           			add hl,de
  72+ A2C2 C6 30        			add a,48
  73+ A2C4 32 EF A2     			ld (decimalS+2),a
  74+ A2C7 11 0A 00     			ld de,10 ;десятки
  75+ A2CA 3E FF        			ld a,255
  76+ A2CC              toDecimal001k
  77+ A2CC A7           			and a
  78+ A2CD ED 52        			sbc hl,de
  79+ A2CF 3C           			inc a
  80+ A2D0 30 FA        			jr nc,toDecimal001k
  81+ A2D2 19           			add hl,de
  82+ A2D3 C6 30        			add a,48
  83+ A2D5 32 F0 A2     			ld (decimalS+3),a
  84+ A2D8 11 01 00     			ld de,1 ;единицы
  85+ A2DB 3E FF        			ld a,255
  86+ A2DD              toDecimal0001k
  87+ A2DD A7           			and a
  88+ A2DE ED 52        			sbc hl,de
  89+ A2E0 3C           			inc a
  90+ A2E1 30 FA        			jr nc,toDecimal0001k
  91+ A2E3 19           			add hl,de
  92+ A2E4 C6 30        			add a,48
  93+ A2E6 32 F1 A2     			ld (decimalS+4),a
  94+ A2E9 21 ED A2     			ld hl,decimalS
  95+ A2EC C9           			ret
  96+ A2ED
  97+ A2ED 00 00 00...  decimalS	ds 6 ;десятичные цифры
  98+ A2F3
  99+ A2F3
# file closed: screen/rtc.asm
  28  A2F3                  include "drivers/index.asm"
# file opened: drivers/index.asm
   1+ A2F3                  IFDEF UNO
   2+ A2F3 ~                include "uno-uart.asm"
   3+ A2F3                  ENDIF
   4+ A2F3
   5+ A2F3                  IFDEF MB03
   6+ A2F3 ~                include "mb03-uart.asm"
   7+ A2F3                  ENDIF
   8+ A2F3
   9+ A2F3                  IFDEF AY
  10+ A2F3 ~                include "ay-uart.asm"
  11+ A2F3                  ENDIF
  12+ A2F3
  13+ A2F3                  IFDEF ZW
  14+ A2F3                  include "zx-wifi.asm"
# file opened: drivers/zx-wifi.asm
   1++A2F3              ; ; This driver works with 16c550 uart that's support AFE
   2++A2F3                  ; module Uart
   3++A2F3              ; ; Make init shorter and readable:-)
   4++A2F3                  ; macro outp port, value
   5++A2F3              	; ld b, port
   6++A2F3              	; ld c, #EF
   7++A2F3                  ; ld a, value
   8++A2F3                  ; out (c), a
   9++A2F3                  ; endm
  10++A2F3
  11++A2F3              ; ; Internal port constants
  12++A2F3              ; RBR_THR = #F8
  13++A2F3              ; IER     = RBR_THR + 1
  14++A2F3              ; IIR_FCR = RBR_THR + 2
  15++A2F3              ; LCR     = RBR_THR + 3
  16++A2F3              ; MCR     = RBR_THR + 4
  17++A2F3              ; LSR     = RBR_THR + 5
  18++A2F3              ; MSR     = RBR_THR + 6
  19++A2F3              ; SR      = RBR_THR + 7
  20++A2F3
  21++A2F3              ; init:
  22++A2F3                  ; outp MCR,     #0d  // Assert RTS
  23++A2F3                  ; outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  24++A2F3                  ; outp LCR,     #83  // 8n1, DLAB=1
  25++A2F3                  ; outp RBR_THR, #01  // 115200 (divider 1)
  26++A2F3                  ; outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  27++A2F3
  28++A2F3                  ; outp LCR,     #03 // 8n1, DLAB=0
  29++A2F3                  ; outp IER,     #00 // Disable int
  30++A2F3                  ; outp MCR,     #2f // Enable AFE
  31++A2F3                  ; ret
  32++A2F3
  33++A2F3              ; ;retry_rec_count_max equ %00011111 ;ждать столько прерываний
  34++A2F3
  35++A2F3              ; ; Flag C <- Data available
  36++A2F3              ; ; isAvailable:
  37++A2F3                  ; ; ld a, LSR
  38++A2F3                  ; ; in a, (#EF)
  39++A2F3                  ; ; rrca
  40++A2F3                  ; ; ret
  41++A2F3
  42++A2F3              ; ; Non-blocking read
  43++A2F3              ; ; Flag C <- is byte was readen
  44++A2F3              ; ; A <- byte
  45++A2F3              ; ; read1:
  46++A2F3                  ; ; ld a, LSR
  47++A2F3                  ; ; in a, (#EF)
  48++A2F3                  ; ; rrca
  49++A2F3                  ; ; ret nc
  50++A2F3                  ; ; ld a, RBR_THR
  51++A2F3                  ; ; in a, (#EF)
  52++A2F3                  ; ; scf
  53++A2F3                  ; ; ret
  54++A2F3
  55++A2F3              ; ; Tries read byte with timeout
  56++A2F3              ; ; Flag C <- is byte read
  57++A2F3              ; ; A <- byte
  58++A2F3              ; read:
  59++A2F3              	; ;xor a ;4
  60++A2F3              	; ;ld (#5C78),a ;обнулить счётчик ожидания ;13
  61++A2F3              ; .wait
  62++A2F3                  ; ld a, LSR
  63++A2F3                  ; in a, (#EF)
  64++A2F3                  ; rrca
  65++A2F3              	; jr nc, .wait
  66++A2F3                  ; ld a, RBR_THR
  67++A2F3                  ; in a, (#EF)
  68++A2F3              	; ret
  69++A2F3              ; ; .readW
  70++A2F3              	; ; OS_GETTIMER
  71++A2F3              	; ; ld a,e
  72++A2F3              	; ; and retry_rec_count_max
  73++A2F3              	; ; ;ld a,(#5C78)
  74++A2F3              	; ; ;cp retry_rec_count_max
  75++A2F3              	; ; jr nz, .wait ;ещё попытка
  76++A2F3              	; ; xor a ;выключим флаг переноса если время вышло
  77++A2F3              	; ; ret
  78++A2F3
  79++A2F3
  80++A2F3
  81++A2F3
  82++A2F3              ; ; Blocking read
  83++A2F3              ; ; A <- Byte
  84++A2F3              ; ; readB:
  85++A2F3                  ; ; ld a, LSR
  86++A2F3                  ; ; in a, (#EF)
  87++A2F3                  ; ; rrca
  88++A2F3                  ; ; jr nc, readB
  89++A2F3              	; ; ld a, RBR_THR
  90++A2F3                  ; ; in a, (#EF)
  91++A2F3                  ; ; ret
  92++A2F3
  93++A2F3              ; ; A -> byte to send
  94++A2F3              ; write:
  95++A2F3                  ; push af
  96++A2F3              ; .wait
  97++A2F3              	; ld a, LSR
  98++A2F3                  ; in a, (#EF)
  99++A2F3                  ; and #20
 100++A2F3                  ; jr z, .wait
 101++A2F3                  ; pop af
 102++A2F3              	; ld b, RBR_THR
 103++A2F3              	; ld c, #EF
 104++A2F3                  ; out (c), a
 105++A2F3                  ; ret
 106++A2F3
 107++A2F3                  ; endmodule
# file closed: drivers/zx-wifi.asm
  15+ A2F3                  ENDIF
  16+ A2F3
  17+ A2F3                  IFDEF SMUCRTC
  18+ A2F3 ~                include "smuc-rtc.asm"
  19+ A2F3                  ENDIF
  20+ A2F3
  21+ A2F3                  include "utils.asm"
# file opened: drivers/utils.asm
   1++A2F3              ; ;;; Macroses!!!!
   2++A2F3                  ; MACRO EspSend Text
   3++A2F3                  ; ld hl, .txtB
   4++A2F3                  ; ld e, (.txtE - .txtB)
   5++A2F3                  ; call espSend
   6++A2F3                  ; jr .txtE
   7++A2F3              ; .txtB
   8++A2F3                  ; db Text
   9++A2F3              ; .txtE
  10++A2F3                  ; ENDM
  11++A2F3
  12++A2F3                  ; MACRO EspCmd Text
  13++A2F3                  ; ld hl, .txtB
  14++A2F3                  ; ld e, (.txtE - .txtB)
  15++A2F3                  ; call espSend
  16++A2F3                  ; jr .txtE
  17++A2F3              ; .txtB
  18++A2F3                  ; db Text
  19++A2F3                  ; db 13, 10
  20++A2F3              ; .txtE
  21++A2F3                  ; ENDM
  22++A2F3
  23++A2F3                  ; MACRO EspCmdOkErr text
  24++A2F3                  ; EspCmd text
  25++A2F3                  ; call checkOkErr
  26++A2F3                  ; ENDM
  27++A2F3
  28++A2F3              ; IN DE - string pointer
  29++A2F3              ; OUT HL - string len
  30++A2F3              strLen:
  31++A2F3 21 00 00         ld hl, 0
  32++A2F6              .loop
  33++A2F6 1A               ld a, (de)
  33++A2F7 A7             and a
  33++A2F8 C8             ret z
  34++A2F9 13 23            inc de, hl
  35++A2FB 18 F9            jr .loop
# file closed: drivers/utils.asm
  22+ A2FD                  include "wifi.asm"
# file opened: drivers/wifi.asm
   1++A2FD                  MODULE Wifi
   2++A2FD 00 00        bytes_avail dw 0
   3++A2FF 00 00        buffer_pointer dw 0
   4++A301 01           closed db 1
   5++A302 00 00 00 00  bytes_avail_all ds 4; всего принято
   6++A306              wait_count equ 5*50 ; ожидание в кадрах
   7++A306              buffer_top equ #fa;ограничение буфера сверху #ffff - 1500
   8++A306              ; ; Initialize Wifi chip to work
   9++A306              ;init:
  10++A306              	;ld hl,uartGetID : call TextMode.printZ
  11++A306              ; init1:
  12++A306              	; halt
  13++A306              	; xor a ;CY=0
  14++A306              	; OS_ESP_LINK_ID ;получить номер соединения
  15++A306              	; jr c,init1:
  16++A306              	; ld (link_id),a
  17++A306              	;ret
  18++A306                  ; ; ld hl, .uartIniting : call TextMode.printZ
  19++A306                  ; ; call Uart.init
  20++A306                  ; ld hl, .chipIniting : call TextMode.printZ
  21++A306                  ; EspCmdOkErr "ATE0"
  22++A306                  ; jr c, .initError
  23++A306
  24++A306                  ; EspCmdOkErr "AT+CIPSERVER=0"
  25++A306                  ; EspCmdOkErr "AT+CIPCLOSE" ; Close if there some connection was. Don't care about result
  26++A306                  ; EspCmdOkErr "AT+CIPMUX=0" ; Single connection mode
  27++A306                  ; jr c, .initError
  28++A306
  29++A306                  ; EspCmdOkErr "AT+CIPDINFO=0" ; Disable additional info
  30++A306                  ; jr c, .initError
  31++A306
  32++A306                  ; ld hl, .doneInit : call TextMode.printZ
  33++A306
  34++A306                  ; or a
  35++A306                  ; ret
  36++A306              ; .initError
  37++A306                  ; ld hl, .errMsg : call DialogBox.msgBox
  38++A306                  ; scf
  39++A306                  ; ret
  40++A306              ; .errMsg db "WiFi chip init failed!",0
  41++A306              ;.uartIniting db "Uart initing...",13,0
  42++A306              ;uartGetID db "Get link ID...",13,0
  43++A306              ; .chipIniting db "Chip initing...",13,0
  44++A306              ; .doneInit    db "Done!",0
  45++A306                  ; IFNDEF PROXY
  46++A306              ; ; HL - host pointer in gopher row
  47++A306              ; ; DE - port pointer in gopher row
  48++A306              openTCP:
  49++A306              	;ld a,(link_id)
  50++A306              	OS_ESP_CLOSE ;если уже пытались раньше, то закрыть
  50++A306 0E 0C       >    ld c,#0c
  50++A308 E7          >    rst #20
  51++A309
  52++A309 AF           	xor a ;TCP
  53++A30A              	OS_ESP_OPEN
  53++A30A 0E 0D       >    ld c,#0d
  53++A30C E7          >    rst #20
  54++A30D 30 0E        	jr nc,openTCP_wait1_ok ;если сразу получилось открыть очередь
  55++A30F
  56++A30F 06 FA        	ld b,wait_count ; пробуем открыть очередь с ожиданием
  57++A311              openTCP_wait1
  58++A311              	OS_WAIT
  58++A311 DF          >	rst #18
  59++A312 C5           	push bc
  60++A313 AF           	xor a ;TCP
  61++A314              	OS_ESP_OPEN
  61++A314 0E 0D       >    ld c,#0d
  61++A316 E7          >    rst #20
  62++A317 C1           	pop bc
  63++A318 30 03        	jr nc,openTCP_wait1_ok
  64++A31A 10 F5        	djnz openTCP_wait1
  65++A31C C9           	ret ;не удалось, наверное очередь
  66++A31D              openTCP_wait1_ok
  67++A31D
  68++A31D              	;подождём подтверждения открытия
  69++A31D 06 FA        	ld b,wait_count ;
  70++A31F              openTCP_wait
  71++A31F              	OS_WAIT
  71++A31F DF          >	rst #18
  72++A320 DD 7E 02     	ld a,(ix+2) ;флаг
  73++A323 07           	rlca
  74++A324 D8           	ret c ;если ошибка (=255)
  75++A325 B7           	or a
  76++A326 20 04        	jr nz,openTCP_wait_skip
  77++A328 10 F5        	djnz openTCP_wait
  78++A32A 37           	scf
  79++A32B C9           	ret
  80++A32C              openTCP_wait_skip
  81++A32C DD 7E 02     	ld a,(ix+2) ;флаг
  82++A32F EE 01        	xor 1
  83++A331 32 01 A3     	ld (closed), a
  84++A334 B7           	or a ;успешно
  85++A335 C9           	ret
  86++A336
  87++A336
  88++A336
  89++A336                  ; push de
  90++A336                  ; push hl
  91++A336                  ; EspCmdOkErr "AT+CIPCLOSE" ; Don't care about result. Just close if it didn't happens before
  92++A336                  ; EspSend 'AT+CIPSTART="TCP","'
  93++A336                  ; pop hl
  94++A336                  ; call espSendT
  95++A336                  ; EspSend '",'
  96++A336                  ; pop hl
  97++A336                  ; call espSendT
  98++A336                  ; ld a, 13 : call Uart.write
  99++A336                  ; ld a, 10 : call Uart.write
 100++A336                  ; xor a : ld (closed), a
 101++A336                  ; jp checkOkErr
 102++A336
 103++A336              ; continue:
 104++A336                  ; ret
 105++A336                  ; ENDIF
 106++A336
 107++A336
 108++A336
 109++A336              ; checkOkErr:
 110++A336                  ; call Uart.read
 111++A336                  ; cp 'O' : jr z, .okStart ; OK
 112++A336                  ; cp 'E' : jr z, .errStart ; ERROR
 113++A336                  ; cp 'F' : jr z, .failStart ; FAIL
 114++A336                  ; jr checkOkErr
 115++A336              ; .okStart
 116++A336                  ; call Uart.read : cp 'K' : jr nz, checkOkErr
 117++A336                  ; call Uart.read : cp 13  : jr nz, checkOkErr
 118++A336                  ; call .flushToLF
 119++A336                  ; or a
 120++A336                  ; ret
 121++A336              ; .errStart
 122++A336                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 123++A336                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 124++A336                  ; call Uart.read : cp 'O' : jr nz, checkOkErr
 125++A336                  ; call Uart.read : cp 'R' : jr nz, checkOkErr
 126++A336                  ; call .flushToLF
 127++A336                  ; scf
 128++A336                  ; ret
 129++A336              ; .failStart
 130++A336                  ; call Uart.read : cp 'A' : jr nz, checkOkErr
 131++A336                  ; call Uart.read : cp 'I' : jr nz, checkOkErr
 132++A336                  ; call Uart.read : cp 'L' : jr nz, checkOkErr
 133++A336                  ; call .flushToLF
 134++A336                  ; scf
 135++A336                  ; ret
 136++A336              ; .flushToLF
 137++A336                  ; call Uart.read
 138++A336                  ; cp 10 : jr nz, .flushToLF
 139++A336                  ; ret
 140++A336
 141++A336              ; ; Send buffer to UART
 142++A336              ; ; HL - buff
 143++A336              ; ; E - count
 144++A336              ; espSend:
 145++A336                  ; ld a, (hl) : call Uart.write
 146++A336                  ; inc hl
 147++A336                  ; dec e
 148++A336                  ; jr nz, espSend
 149++A336                  ; ret
 150++A336
 151++A336              ; ; HL - string that ends with one of the terminator(CR/LF/TAB/NULL)
 152++A336              ; espSendT:
 153++A336                  ; ld a, (hl)
 154++A336
 155++A336                  ; and a : ret z
 156++A336                  ; cp 9 : ret z
 157++A336                  ; cp 13 : ret z
 158++A336                  ; cp 10 : ret z
 159++A336
 160++A336                  ; call Uart.write
 161++A336                  ; inc hl
 162++A336                  ; jr espSendT
 163++A336
 164++A336              ; ; HL - stringZ to send
 165++A336              ; ; Adds CR LF
 166++A336              tcpSendZ:
 167++A336 E5           	push hl
 168++A337 EB           	ex de,hl
 169++A338 CD F3 A2     	call strLen ;узнать длину
 170++A33B EB           	ex de,hl
 171++A33C E1           	pop hl ;буфер
 172++A33D E5           	push hl
 173++A33E 19           	add hl,de ;добавить в конце 13 и 10
 174++A33F 36 0D        	ld (hl),13
 175++A341 23           	inc hl
 176++A342 36 0A        	ld (hl),10
 177++A344 E1           	pop hl
 178++A345 13           	inc de ;увеличить длину
 179++A346 13           	inc de
 180++A347
 181++A347              	;call Wifi.tcpSendZ ;послать запрос
 182++A347              	;ld a,(link_id)
 183++A347              	OS_ESP_SEND
 183++A347 0E 0E       >    ld c,#0e
 183++A349 E7          >    rst #20
 184++A34A              	;ret c ;сразу не удалось (может, очередь)
 185++A34A              	;ждём когда запрос пройдёт
 186++A34A 06 FA        	ld b,wait_count ;
 187++A34C              tcpSendZ_wait1 ;ждём подтверждения
 188++A34C              	OS_WAIT
 188++A34C DF          >	rst #18
 189++A34D DD 7E 04     	ld a,(ix+4) ;флаг
 190++A350 FE 01        	cp 1
 191++A352 C8           	ret z
 192++A353 10 F7        	djnz tcpSendZ_wait1
 193++A355 37           	scf ;не дождались
 194++A356 C9           	ret
 195++A357
 196++A357
 197++A357                  ; push hl
 198++A357                  ; EspSend "AT+CIPSEND="
 199++A357                  ; pop de : push de
 200++A357                  ; call strLen
 201++A357                  ; inc hl : inc hl ; +CRLF
 202++A357                  ; call hlToNumEsp
 203++A357                  ; ld a, 13 : call Uart.write
 204++A357                  ; ld a, 10 : call Uart.write
 205++A357                  ; call checkOkErr : ret c
 206++A357              ; .wait
 207++A357                  ; call Uart.read : cp '>' : jr nz, .wait
 208++A357                  ; pop hl
 209++A357              ; .loop
 210++A357                  ; ld a, (hl) : and a : jr z, .exit
 211++A357                  ; call Uart.write
 212++A357                  ; inc hl
 213++A357                  ; jp .loop
 214++A357              ; .exit
 215++A357                  ; ld a, 13 : call Uart.write
 216++A357                  ; ld a, 10 : call Uart.write
 217++A357                  ; jp checkOkErr
 218++A357
 219++A357              ;вх: hl - адрес буфера
 220++A357              getPacket:
 221++A357              	;переделано под ОС
 222++A357 7C           	ld a,h
 223++A358 FE FA        	cp buffer_top ;ограничение буфера
 224++A35A 38 10        	jr c,getPacket_skip_over ; ниже ограничения грузим
 225++A35C 3E 01        	ld a,1 ;или прекращаем
 226++A35E 32 01 A3     	ld (closed),a ;флаг закрытия
 227++A361 21 00 00     	ld hl,0
 228++A364 22 FD A2     	ld (bytes_avail), hl
 229++A367              	OS_ESP_CLOSE ;освободить очередь
 229++A367 0E 0C       >    ld c,#0c
 229++A369 E7          >    rst #20
 230++A36A 37           	scf
 231++A36B C9           	ret
 232++A36C              getPacket_skip_over
 233++A36C
 234++A36C              	;ld a,(link_id)
 235++A36C              	OS_ESP_GET
 235++A36C 0E 0F       >    ld c,#0f
 235++A36E E7          >    rst #20
 236++A36F              	; ret c ;сразу не удалось (может, очередь)
 237++A36F              	; ld b,wait_count ;
 238++A36F              getPacket_wait1 ;бесконечно ждём подтверждения
 239++A36F              	OS_WAIT
 239++A36F DF          >	rst #18
 240++A370 DD 7E 06     	ld a,(ix+6) ;флаг результат приёма
 241++A373              	; rlca
 242++A373              	; ret c ;если ошибка (=255)
 243++A373 FE 01        	cp 1
 244++A375 20 F8        	jr nz,getPacket_wait1
 245++A377
 246++A377
 247++A377              ;getPacket_wait1_skip
 248++A377 2A FF A2     	ld hl,(buffer_pointer)
 249++A37A DD 4E 09     	ld c,(ix+9) ; длина принятого
 250++A37D DD 46 0A     	ld b,(ix+10)
 251++A380 ED 43 FD A2  	ld (bytes_avail), bc
 252++A384 09           	add hl,bc
 253++A385 22 FF A2     	ld (buffer_pointer),hl ;продолжить загружать с этого места
 254++A388
 255++A388              	;печать общего количества загруженного
 256++A388 E5           	push hl
 257++A389 C5           	push bc
 258++A38A 11 00 18     	ld de,#1800
 259++A38D              	OS_SET_XY
 259++A38D 0E 01       >    ld c,#01
 259++A38F E7          >    rst #20
 260++A390 C1           	pop bc
 261++A391 2A 02 A3     	ld hl,(bytes_avail_all) ;младшие байты
 262++A394 09           	add hl,bc
 263++A395 22 02 A3     	ld (bytes_avail_all),hl
 264++A398 30 07        	jr nc,getPacket_print
 265++A39A 2A 04 A3     	ld hl,(bytes_avail_all+2) ;старшие байты
 266++A39D 23           	inc hl
 267++A39E 22 04 A3     	ld (bytes_avail_all+2),hl
 268++A3A1              getPacket_print
 269++A3A1              ;разделить на 1024
 270++A3A1 2A 03 A3     	ld hl,(bytes_avail_all+1) ;средние байты (уже /256)
 271++A3A4 CB 3C        	srl h ; младший бит придёт на флаг C , на старший бит придёт 0
 272++A3A6 CB 1D        	rr l ; младший бит придёт на флаг C, на старший флаг C
 273++A3A8 CB 3C        	srl h ; /1024
 274++A3AA CB 1D        	rr l ;
 275++A3AC
 276++A3AC CD 94 A2     	call toDecimal
 277++A3AF              	OS_PRINTZ
 277++A3AF 0E 09       >    ld c,#09
 277++A3B1 E7          >    rst #20
 278++A3B2 E1           	pop hl
 279++A3B3
 280++A3B3
 281++A3B3 DD 7E 02     	ld a,(ix+2) ;!!! closed
 282++A3B6 EE 01        	xor 1
 283++A3B8 32 01 A3     	ld (closed),a ;флаг закрытия
 284++A3BB 28 03        	jr z,getPacket_ex
 285++A3BD              	OS_ESP_CLOSE ;освободить очередь
 285++A3BD 0E 0C       >    ld c,#0c
 285++A3BF E7          >    rst #20
 286++A3C0              getPacket_ex
 287++A3C0 B7           	or a
 288++A3C1 C9           	ret
 289++A3C2
 290++A3C2
 291++A3C2                  ; call Uart.read
 292++A3C2                  ; cp '+' : jr z, .ipdBegun    ; "+IPD," packet
 293++A3C2                  ; cp 'O' : jr z, .closedBegun ; It enough to check "OSED\n" :-)
 294++A3C2                  ; jr getPacket
 295++A3C2              ; .closedBegun
 296++A3C2                  ; call Uart.read : cp 'S' : jr nz, getPacket
 297++A3C2                  ; call Uart.read : cp 'E' : jr nz, getPacket
 298++A3C2                  ; call Uart.read : cp 'D' : jr nz, getPacket
 299++A3C2                  ; call Uart.read : cp 13 : jr nz, getPacket
 300++A3C2                  ; ld a, 1, (closed), a
 301++A3C2                  ; ret
 302++A3C2              ; .ipdBegun
 303++A3C2                  ; call Uart.read : cp 'I' : jr nz, getPacket
 304++A3C2                  ; call Uart.read : cp 'P' : jr nz, getPacket
 305++A3C2                  ; call Uart.read : cp 'D' : jr nz, getPacket
 306++A3C2                  ; call Uart.read ; Comma
 307++A3C2                  ; call .count_ipd_lenght : ld (bytes_avail), hl
 308++A3C2                  ; ld bc, hl
 309++A3C2                  ; ld hl, (buffer_pointer)
 310++A3C2              ; .readp
 311++A3C2                  ; ld a, h : cp #ff : jr nc, .skipbuff
 312++A3C2                  ; push bc, hl
 313++A3C2                  ; call Uart.read
 314++A3C2                  ; pop hl, bc
 315++A3C2                  ; ld (hl), a
 316++A3C2                  ; dec bc : inc hl
 317++A3C2                  ; ld a, b : or c : jr nz, .readp
 318++A3C2                  ; ld (buffer_pointer), hl
 319++A3C2                  ; ret
 320++A3C2              ; .skipbuff
 321++A3C2                  ; push bc
 322++A3C2                  ; call Uart.read
 323++A3C2                  ; pop bc
 324++A3C2                  ; dec bc : ld a, b : or c : jr nz, .skipbuff
 325++A3C2                  ; ret
 326++A3C2              ; .count_ipd_lenght
 327++A3C2              		; ld hl,0			; count lenght
 328++A3C2              ; .cil1	push  hl
 329++A3C2                      ; call Uart.read
 330++A3C2                      ; pop hl
 331++A3C2              		; cp ':' : ret z
 332++A3C2              		; sub 0x30 : ld c,l : ld b,h : add hl,hl : add hl,hl : add hl,bc : add hl,hl : ld c,a : ld b,0 : add hl,bc
 333++A3C2              		; jr .cil1
 334++A3C2
 335++A3C2              ; ; Based on: https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
 336++A3C2              ; ; HL - number
 337++A3C2              ; ; It will be written to UART
 338++A3C2              ; hlToNumEsp:
 339++A3C2              	; ld	bc,-10000
 340++A3C2              	; call	.n1
 341++A3C2              	; ld	bc,-1000
 342++A3C2              	; call	.n1
 343++A3C2              	; ld	bc,-100
 344++A3C2              	; call	.n1
 345++A3C2              	; ld	c,-10
 346++A3C2              	; call	.n1
 347++A3C2              	; ld	c,-1
 348++A3C2              ; .n1	ld	a,'0'-1
 349++A3C2              ; .n2	inc	a
 350++A3C2              	; add	hl,bc
 351++A3C2              	; jr	c, .n2
 352++A3C2              	; sbc	hl,bc
 353++A3C2                  ; push bc
 354++A3C2              	; call Uart.write
 355++A3C2                  ; pop bc
 356++A3C2                  ; ret
 357++A3C2
 358++A3C2                  ENDMODULE
# file closed: drivers/wifi.asm
  23+ A3C2                  include "proxy.asm"
# file opened: drivers/proxy.asm
   1++A3C2                  IFDEF PROXY
   2++A3C2 ~                MODULE Wifi
   3++A3C2 ~            ; Same singature as wifi.openTCP
   4++A3C2 ~            ; HL - host pointer in gopher row
   5++A3C2 ~            ; DE - port pointer in gopher row
   6++A3C2 ~            openTCP:
   7++A3C2 ~                push de
   8++A3C2 ~                push hl
   9++A3C2 ~
  10++A3C2 ~                xor a
  10++A3C2 ~              ld hl, hostBuff, de, hostBuff + 1, bc, 102, (hl), a
  10++A3C2 ~              ldir
  11++A3C2 ~
  12++A3C2 ~                EspCmdOkErr "AT+CIPCLOSE"
  13++A3C2 ~                EspCmdOkErr 'AT+CIPSTART="TCP","138.68.76.243",6912' // Replace here for yourown proxy. If you wish
  14++A3C2 ~                jr c, .error
  15++A3C2 ~                pop hl
  15++A3C2 ~              ld de, hostBuff
  16++A3C2 ~            .copyHost
  17++A3C2 ~                ld a, (hl)
  17++A3C2 ~              and a
  17++A3C2 ~              jr z, 1F
  17++A3C2 ~              and a
  17++A3C2 ~              jr z, 1F
  18++A3C2 ~                ld (de), a
  18++A3C2 ~              inc hl, de
  19++A3C2 ~                jr .copyHost
  20++A3C2 ~            1   xor a
  20++A3C2 ~              ld (de), a
  21++A3C2 ~                pop hl
  21++A3C2 ~              ld de, portBuff
  22++A3C2 ~            .copyPort
  23++A3C2 ~                ld a, (hl)
  23++A3C2 ~              and a
  23++A3C2 ~              jr z, 1F
  23++A3C2 ~              and a
  23++A3C2 ~              jr z, 1F
  24++A3C2 ~                ld (de), a
  24++A3C2 ~              inc hl, de
  25++A3C2 ~                jr .copyPort
  26++A3C2 ~            1   ld hl, hostBuff
  26++A3C2 ~              call tcpSendZ
  27++A3C2 ~                ld hl, portBuff
  27++A3C2 ~              call tcpSendZ
  28++A3C2 ~                xor a
  28++A3C2 ~              ld (closed), a
  29++A3C2 ~                ret
  30++A3C2 ~            .error
  31++A3C2 ~                pop hl
  31++A3C2 ~              pop de
  32++A3C2 ~                ret
  33++A3C2 ~
  34++A3C2 ~            continue:
  35++A3C2 ~                EspCmdOkErr "AT+CIPSEND=1"
  36++A3C2 ~                ret c
  37++A3C2 ~            .wait
  38++A3C2 ~                call Uart.read
  38++A3C2 ~              cp '>'
  38++A3C2 ~              jr nz, .wait
  39++A3C2 ~                ld a, 'c'
  39++A3C2 ~              call Uart.write
  40++A3C2 ~                jp checkOkErr
  41++A3C2 ~
  42++A3C2 ~            hostBuff ds 96
  43++A3C2 ~            portBuff ds 7
  44++A3C2 ~                ENDMODULE
  45++A3C2                  ENDIF
# file closed: drivers/proxy.asm
  24+ A3C2                  include "memory.asm"
# file opened: drivers/memory.asm
   1++A3C2                  module Memory
   2++A3C2              BANKM = #5b5c
   3++A3C2              MEM_PORT = #7ffd
   4++A3C2
   5++A3C2              init:
   6++A3C2 F3               di
   7++A3C3 FD CB 01 A6      res 4, (iy + 1)
   8++A3C7
   9++A3C7 AF               xor a
   9++A3C8 CD CC A3       call setPage
  10++A3CB C9               ret
  11++A3CC
  12++A3CC              ; a - page
  13++A3CC              setPage:
  14++A3CC F6 18            or #18
  14++A3CE 32 5C 5B       ld (BANKM), a
  15++A3D1 01 FD 7F         ld bc, MEM_PORT
  15++A3D4 ED 79          out (c), a
  16++A3D6 C9               ret
  17++A3D7
  18++A3D7                  endmodule
# file closed: drivers/memory.asm
  25+ A3D7                  include "general-sound.asm"
# file opened: drivers/general-sound.asm
   1++A3D7                  ifdef GS
   2++A3D7                  macro _WaitCommand
   3++A3D7 ~            .wait
   4++A3D7 ~                in a, (GeneralSound.CMD)
   5++A3D7 ~                rrca
   6++A3D7 ~                jr c, .wait
   7++A3D7                  endm
   8++A3D7
   9++A3D7                  macro _WaitData
  10++A3D7 ~            .wait
  11++A3D7 ~                in a, (GeneralSound.CMD)
  12++A3D7 ~                rlca
  13++A3D7 ~                jr c, .wait
  14++A3D7                  endm
  15++A3D7
  16++A3D7                  macro _SendCommand nn
  17++A3D7 ~                ld a, nn
  17++A3D7 ~              out (GeneralSound.CMD), a
  18++A3D7                  endm
  19++A3D7
  20++A3D7                  module GeneralSound
  21++A3D7              ;; Control ports
  22++A3D7              CMD  = 187
  23++A3D7              DATA = 179
  24++A3D7
  25++A3D7              ;; Commands
  26++A3D7              CMD_WARM_RESET      = #F3
  27++A3D7              CMD_COLD_RESET      = #F4
  28++A3D7              CMD_LOAD_MODULE     = #30
  29++A3D7              CMD_PLAY_MODULE     = #31
  30++A3D7              CMD_STOP_MODULE     = #32
  31++A3D7              CMD_CONTINUE_MODULE = #33
  32++A3D7              CMD_OPEN_STREAM     = #D1
  33++A3D7              CMD_CLOSE_STREAM    = #D2
  34++A3D7
  35++A3D7              ; A - 0 warm reset, other - cold
  36++A3D7              init:
  37++A3D7 A7               and a
  37++A3D8 20 05          jr nz, .cold
  38++A3DA                  _SendCommand CMD_WARM_RESET
  38++A3DA 3E F3       >    ld a, CMD_WARM_RESET
  38++A3DC D3 BB       >  out (GeneralSound.CMD), a
  39++A3DE C9               ret
  40++A3DF              .cold
  41++A3DF                  _SendCommand CMD_COLD_RESET
  41++A3DF 3E F4       >    ld a, CMD_COLD_RESET
  41++A3E1 D3 BB       >  out (GeneralSound.CMD), a
  42++A3E3 C9               ret
  43++A3E4
  44++A3E4              ;; Initializes loading module
  45++A3E4              loadModule:
  46++A3E4                  _SendCommand CMD_LOAD_MODULE
  46++A3E4 3E 30       >    ld a, CMD_LOAD_MODULE
  46++A3E6 D3 BB       >  out (GeneralSound.CMD), a
  47++A3E8                  _WaitCommand
  47++A3E8             >.wait
  47++A3E8 DB BB       >    in a, (GeneralSound.CMD)
  47++A3EA 0F          >    rrca
  47++A3EB 38 FB       >    jr c, .wait
  48++A3ED                  _SendCommand CMD_OPEN_STREAM
  48++A3ED 3E D1       >    ld a, CMD_OPEN_STREAM
  48++A3EF D3 BB       >  out (GeneralSound.CMD), a
  49++A3F1                  _WaitCommand
  49++A3F1             >.wait
  49++A3F1 DB BB       >    in a, (GeneralSound.CMD)
  49++A3F3 0F          >    rrca
  49++A3F4 38 FB       >    jr c, .wait
  50++A3F6 C9               ret
  51++A3F7
  52++A3F7              ;; Use it for streaming mod file
  53++A3F7              sendByte:
  54++A3F7 D3 B3            out (DATA), a
  55++A3F9                  _WaitData
  55++A3F9             >.wait
  55++A3F9 DB BB       >    in a, (GeneralSound.CMD)
  55++A3FB 07          >    rlca
  55++A3FC 38 FB       >    jr c, .wait
  56++A3FE C9               ret
  57++A3FF
  58++A3FF              ;; Call it when module was loaded
  59++A3FF              finishLoadingModule:
  60++A3FF                  _SendCommand CMD_CLOSE_STREAM
  60++A3FF 3E D2       >    ld a, CMD_CLOSE_STREAM
  60++A401 D3 BB       >  out (GeneralSound.CMD), a
  61++A403                  _WaitCommand
  61++A403             >.wait
  61++A403 DB BB       >    in a, (GeneralSound.CMD)
  61++A405 0F          >    rrca
  61++A406 38 FB       >    jr c, .wait
  62++A408              rewind:
  63++A408 3E 01            ld a, 1
  63++A40A D3 B3          out (DATA), a
  64++A40C                  _SendCommand CMD_PLAY_MODULE
  64++A40C 3E 31       >    ld a, CMD_PLAY_MODULE
  64++A40E D3 BB       >  out (GeneralSound.CMD), a
  65++A410                  _WaitCommand
  65++A410             >.wait
  65++A410 DB BB       >    in a, (GeneralSound.CMD)
  65++A412 0F          >    rrca
  65++A413 38 FB       >    jr c, .wait
  66++A415 3E 01 32 39      ld a, 1, (state),a
  66++A419 A4
  67++A41A C9               ret
  68++A41B
  69++A41B              ;; Works like pause too
  70++A41B              stopModule:
  71++A41B AF               xor a
  71++A41C 32 39 A4       ld (state), a
  72++A41F                  _SendCommand CMD_STOP_MODULE
  72++A41F 3E 32       >    ld a, CMD_STOP_MODULE
  72++A421 D3 BB       >  out (GeneralSound.CMD), a
  73++A423 C9               ret
  74++A424
  75++A424              continueModule:
  76++A424 3E 01            ld a, 1
  76++A426 32 39 A4       ld (state), a
  77++A429                  _SendCommand CMD_CONTINUE_MODULE
  77++A429 3E 33       >    ld a, CMD_CONTINUE_MODULE
  77++A42B D3 BB       >  out (GeneralSound.CMD), a
  78++A42D C9               ret
  79++A42E
  80++A42E              ; Pauses resumes
  81++A42E              toggleModule:
  82++A42E CD DF 86         call Console.waitForKeyUp
  83++A431 3A 39 A4         ld a, (state)
  83++A434 A7             and a
  84++A435 28 ED            jr z, continueModule
  85++A437 18 E2            jr stopModule
  86++A439
  87++A439 00           state db 0
  88++A43A                  endmodule
  89++A43A
  90++A43A                  endif
# file closed: drivers/general-sound.asm
  26+ A43A
# file closed: drivers/index.asm
  29  A43A
  30  A43A              exit_dos ;выход в DOS
  31  A43A AF           	xor a
  32  A43B              	OS_PROC_CLOSE
  32  A43B 0E 13       >    ld c,#13
  32  A43D E7          >    rst #20
  33  A43E
  34  A43E              start:
  35  A43E              	; IFDEF TRD
  36  A43E              	; align 256 ;временно
  37  A43E              	; ENDIF
  38  A43E              outputBuffer: ;equ #c000
  39  A43E                  ;di
  40  A43E                  ;xor a : ld (#5c6a), a  ; Thank you, Mario Prato, for feedback
  41  A43E                  ;ld (#5c00),a
  42  A43E                  ;ld sp, asmOrg
  43  A43E                  ;call Memory.init
  44  A43E                  ;xor a : out (#fe),a
  45  A43E                  ;ei
  46  A43E
  47  A43E                  ;ld a, 7 : call Memory.setPage
  48  A43E                  ;; Logo
  49  A43E                  ; ld hl, logo, b, Dos.FMODE_READ : call Dos.fopen
  50  A43E                  ; push af
  51  A43E                  ; ld hl, #c000, bc, 6912 : call Dos.fread
  52  A43E                  ; pop af
  53  A43E                  ; call Dos.fclose
  54  A43E
  55  A43E              	; ifdef ZSGMX
  56  A43E              	; call TextMode.disable
  57  A43E              	; endif
  58  A43E
  59  A43E                  ; ld b, 50
  60  A43E              ; 1   halt
  61  A43E                  ; djnz 1b
  62  A43E                  ;; End of logo :-)
  63  A43E
  64  A43E CD 03 80         call TextMode.init
  65  A441
  66  A441                  ; ld hl, initing : call TextMode.printZ
  67  A441                  ; IFNDEF EMU
  68  A441                  ; call Wifi.init
  69  A441                  ; ENDIF
  70  A441
  71  A441 C3 5E 87         jp History.home
  72  A444
  73  A444              ;initing db "Initing Wifi...",13,0
  74  A444 64 61 74 61  logo    db  "data/logo.scr", 0
  74  A448 2F 6C 6F 67
  74  A44C 6F 2E 73 63
  74  A450 72 00
  75  A452                  display "ENDS: ", $
  76  A452                  display "Buff size", #ffff - $
  77  A452
  78  A452                  ;IFDEF ESX
  79  A452                  ;save3dos "moon.bin", asmOrg, $ - asmOrg
  80  A452                  savebin "moonr.apg", asmOrg, $ - asmOrg
  81  A452              	;ELSE
  82  A452                  ;SAVETRD "MOONR.TRD",|"moon.C",asmOrg, $ - asmOrg
  83  A452                  ;ENDIF
# file closed: main.asm
